
### 오늘의 링크

1. 젯브레인 2023학습채널 https://hyperskill.org/tracks/18

1. (2023-07 322p) 최신 Android 13 개발 요리책 Modern Android 13 Development Cookbook https://subscription.packtpub.com/book/mobile/9781803235578/pref

1. (2023-05 704p) Kotlin으로 Android 앱을 빌드하는 방법-제 2 판 How to Build Android Apps with Kotlin - Second Edition https://subscription.packtpub.com/book/mobile/9781837634934/pref

1. (2022-01 356p) Kotlin 디자인 패턴 및 모범 사례 - 제2판 https://subscription.packtpub.com/book/programming/9781801815727/2/ch02lvl1sec12/classes-and-inheritance

1. (2022-03 420.p) WordPress Plugin Development Cookbook https://subscription.packtpub.com/book/web-development/9781801810777/pref

1. (2023-01-01 522.p) PostgreSQL 15 마스터하기 - 제5판 https://subscription.packtpub.com/book/business-other/9781803248349/1


# 230908 금
0930 진도

1. bc (프로그래밍 언어) https://en.wikipedia.org/wiki/Bc_(programming_language)
basic calculator (often referred to as bench calculator)

- `echo "2/3" | bc` 👈 (bc) 소숫점 이하 버림
`echo "2/3" | bc -l` 👈 (bc -l) 표시할 소숫점 이하 자릿수를 지정 안하면 **그냥 20 자리**로 설정 + 수학 함수도 추가

- `time echo "scale=9; 4*a(1)" | bc -l` 👈 (bc -l) 원주율 PI 값 계산.
**time** (뒤에 쓴 명령이 걸린 시간을 표시)
**scale=9** (소숫점 이하의 자릿수를 9자리로 설정)
**4\*a(1)** (1의 아크탄젠트는 45도이며 라디안 단위는 pi/4)

2. 라디안(radian)과 디그리(degree) 수학 이야기 2013. 1. 28. 16:20 https://darkpgmr.tistory.com/26
(1) --> 일상적으로 사용하는 각의 단위는 디그리(degree) --> 원 한바퀴 = (360도) , 반원 = (180도) , 직각 = (90도) ...
(2) --> 라디안(radian) --> 부채꼴의 중심각 기준. 호의 길이가 반지름과 같게 되는 만큼의 각을 1 라디안(radian)
1 radian = (약 57.3도에 해당하는 각) , 2 radian = (약 114.6도)
![ 1 라디안(radian) ](/ilji/2023-09/230908-radian.webp)

3. 역삼각함수란? 구글 클래스룸 역사인, 역코사인, 역탄젠트에 대하여 배우고, 직각삼각형에서 모르는 각을 구하는데 어떻게 쓰이는지 배워 봅시다. https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro

4. BC 표준 라이브러리

| bc | 명령  기능 | 설명 |
|:---:|:---:|:---:|
| s(x) | 사인 | 라디안 단위 의 각도 인 x 를 사용합니다 |
| c(x) | 코사인 | 라디안 단위의 각도 인 x 를 사용합니다 |
| a(x) | 아크탄젠트 | 라디안을 반환합니다 |
| l(x) | 자연로그 | |
| e(x) | 지수 함수 | |
| j(n,x) | 베셀 함수 | x 의 차수 n 베셀 함수를 반환합니다 |

# 230907 목
1010 푸른숲

# 도커 와 도커 컴포즈

- `도커`: 호스트 OS 의 **시스템 자원** 을 **공유** 하면서 `컨테이너` 를 **운영**하는 `가상화 도구`.
(chroot, 네임 스페이스, cgroup 등을 이용해)
- `컨테이너`: **프로세스** 단위로 **격리된** 환경.
동작하는 앱과 이에 필요한 바이너리, 라이브러리 만 담겨있다.
- `도커 컴포즈`: 여러개의 **도커** 를 `한번에`**실행**`하도록` 도와주는 `도구`.
(시스템 구축과 종료, 폐기까지)

# 도커 설치하기

## 1. Fedora 시스템 업데이트
```
sudo dnf -y update
```

페도라 터미널에서 쓰는 색상값을 지정한다.
```
for i in {0..9}; do echo "#"; done

hhh=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)
echo "#--"
echo "\${cBlack} ${cBlack}회색 bLack${cReset} , \${cRed} ${cRed}빨강 Red${cReset} , \${cGreen} ${cGreen}녹색 Green${cReset} , \${cYellow} ${cYellow}노랑 Yellow${cReset} , \${cBlue} ${cBlue}파랑 Blue${cReset}"
echo "\${cMagenta} ${cMagenta}보라 Magenta${cReset} , \${cCyan} ${cCyan}청록 Cyan${cReset}, \${cWhite} ${cWhite}흰색 White${cReset} , \${cReset} ${cReset}색취소"
echo "#--"
echo "\${hhh} ${hhh}회색 bLack${xxx} , \${rrr} ${rrr}빨강 Red${xxx} , \${ggg} ${ggg}녹색 Green${xxx} , \${yyy} ${yyy}노랑 Yellow${xxx} , \${bbb} ${bbb}파랑 Blue${xxx}"
echo "\${mmm} ${mmm}보라 Magenta${xxx} , \${ccc} ${ccc}청록 Cyan${xxx}, \${www} ${www}흰색 White${xxx} , \${xxx} ${xxx}색취소"
echo "#--"
echo "${rrr}#----.----+----.----+----.----+----.----+----.----+----.----+-- (1) "
echo "${ggg}#----.----+----.----+----.----+----.----+----.----+----.--- (2) "
echo "${yyy}#----.----+----.----+----.----+----.----+----.----+---- (3) "
echo "${bbb}#----.----+--- (4-1) ^^^>${uuu}<^^^ 윗쪽으로 Up (4-2) "
echo "${mmm}#----.--- (5) "
echo "${ccc}#--- (6)${xxx} "
```
| lll | 검정 bLack | rrr | 빨강 Red | ggg | 녹색 Green | yyy | 노랑 Yellow | bbb | 파랑 Blue |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| mmm | 보라 Magenta | ccc | 청록 Cyan | www | 흰색 White | xxx | 색취소 | uuu | 윗쪽으로 Up |

## 2. Fedora 리파지토리 추가

도커 설치전에, 다음과 같이 Fedora 리파지토리를 시스템에 추가해야 한다.
```
for i in {0..9}; do echo "#"; done

echo "#-- 시스템 명령어인 dnf 의 플러그인 코어를 받습니다"
echo "#-- ${yyy}(2-1)${xxx} sudo dnf -y install dnf-plugins-core"
sudo dnf -y install dnf-plugins-core
echo "#-- 받으려는 docker-ce 가 있는 위치를 리파지토리에 기록합니다"
echo "#-- ${yyy}(2-2)${xxx} sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__"
sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__
[docker-ce-stable]
name=Docker CE Stable - \$basearch
baseurl=https://download.docker.com/linux/fedora/36/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://download.docker.com/linux/fedora/gpg
__EOF__
echo "#-- ${yyy}(2-3)${xxx} 출처: https://computingforgeeks.com/how-to-install-docker-on-fedora/ == Fedora 를 위한 리파지토리를 시스템에 추가합니다."
```

## 3. Docker 설치
```
for i in {0..9}; do echo "#"; done

echo "#-- docker-ce 를 받습니다."
echo "#-- ${yyy}(3-1)${xxx} sudo dnf makecache"
sudo dnf makecache
echo "#-- ${yyy}(3-2)${xxx} sudo dnf -y install docker-ce docker-ce-cli containerd.io"
sudo dnf -y install docker-ce docker-ce-cli containerd.io
echo "#-- ${yyy}(3-3)${xxx} sudo systemctl enable --now docker"
sudo systemctl enable --now docker
echo "#-- ${yyy}(3-4)${xxx} --------------------"
```

## 4. Docker 설치 확인
```
for i in {0..9}; do echo "#"; done

echo "#-- 줄의 끝에 lines 1-24/24 (END) 가 나오면, 'Q' 를 눌러서 끝내야 합니다."
echo "#-- ${yyy}(4-1)${xxx} press Enter:"
read a
echo "#-- ${yyy}(4-2)${xxx} sudo systemctl status docker"
sudo systemctl status docker
echo "#-- ${yyy}(4-3)${xxx} sudo docker version"
sudo docker version
echo "#-- ${yyy}(4-4)${xxx} --------------------"
```

# wiki.js 를 위한 도커 컴포즈 설치하기

## 도커 컴포즈란
1. 시스템 구축과 관련된 명령어를 `하나의 텍스트 파일` (= 정의 파일) 에 기재.
1. 명령어 한번에 시스템 전체를 실행.
1. 종료와 폐기까지 `한번에 하도록` 도와주는 도구.

👉 도커 컴포즈를 사용하면 여러 개의 명령어를 하나의 정의 파일로 합쳐 실행할 수 있다.

작업 순서:
1. wiki.js 를 운영할 도커 와 그 데이터베이스를 보관하는 디렉토리 만들기
2. 도커 컴포즈 설정파일 만들기
3. 설정파일 대로 도커 컴포즈 (빌드 + 실행) 하기
4. 브라우저에서 (주소:포트번호) 입력
5. 첫번째 등록작업

## 5. 보관하는 디렉토리 만들기

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

db_made="x"
if [ ! -d ${DB_DIR} ]; then
    echo "#-- ${yyy}(5-1)${xxx} sudo mkdir -p ${DB_DIR}"
    sudo mkdir -p ${DB_DIR}
    #-- chcon -R system_u:object_r:container_file_t:s0 ${DB_DIR}
    #-- sudo chown -R systemd-coredump:ssh_keys ${DB_DIR}
    db_made="o"
fi

wiconf_made="x"
if [ ! -d ${WIKI_CONF_DIR} ]; then
    echo "#-- ${yyy}(5-2)${xxx} sudo mkdir -p ${WIKI_CONF_DIR}"
    sudo mkdir -p ${WIKI_CONF_DIR}
    echo "#-- ${yyy}(5-3)${xxx} sudo chown -R ${USER}:${USER} ${WIKI_CONF_DIR}"
    sudo chown -R ${USER}:${USER} ${WIKI_CONF_DIR}
    wiconf_made="o"
fi

echo "===== db_and_wiconf ${db_and_wiconf}"
if [ "x${db_made}" = "xx" ] || [ "x${wiconf_made}" = "xx" ]; then
    echo "#-- ${yyy}(5-4)${xxx} sudo ls -lR --color ${DOCKER_DIR}"
    sudo ls -lR --color ${DOCKER_DIR}
    echo "#-- ${yyy}(5-5)${xxx} ${DB_DIR}, ${WIKI_CONF_DIR} 디렉토리 확인후, 다음 명령으로 삭제하세요."
    echo "#-- sudo rm -rf ${DB_DIR} ${WIKI_CONF_DIR}"
else
    echo "#-- ${yyy}(5-6)${xxx} sudo ls -lR --color ${DOCKER_DIR} 디렉토리를 만들었습니다."
    sudo ls -lR --color ${DOCKER_DIR}
fi
echo "#-- ${yyy}(5-7)${xxx} --------------------"
```

## 6. 설정파일 docker-compose.yml 만들기

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

cat > ${WIKI_CONF_DIR}/docker-compose.yml <<__EOF__
version: "3"
services:
  ${DB_SERVICE}:
    image: postgres:11-alpine
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PSWD}
      POSTGRES_DB: ${DB_NAME}
    logging:
      driver: "none"
    restart: unless-stopped
    volumes:
      - ${DB_DIR}:/var/lib/postgresql/data
    container_name:
      ${DB_CONTAINER}

  ${WIKI_SERVICE}:
    image: requarks/wiki:2
    depends_on:
      - db
    environment:
      DB_TYPE: postgres
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PSWD}
      DB_NAME: ${DB_NAME}
    restart: unless-stopped
    ports:
      - "${WIKI_PORT_NO}:3000"
    container_name:
      ${WIKI_CONTAINER}
__EOF__
echo "#-- ${yyy}(6-1)${xxx} ls -lR ${DOCKER_DIR}"
ls -lR ${DOCKER_DIR}
grep "ports:" -A3 ${WIKI_CONF_DIR}/docker-compose.yml
echo "#-- ${yyy}(6-2)${xxx} --------------------"
```

## 7. 도커 컴포즈 빌드 + 실행

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

echo "#-- ${yyy}(7-1)${xxx} cd ${WIKI_CONF_DIR}"
cd ${WIKI_CONF_DIR}
echo "#-- ${yyy}(7-2)${xxx} sudo dnf -y install docker-compose (설치)"
sudo dnf -y install docker-compose
echo "#-- ${yyy}(7-3)${xxx} rpm -qi docker-compose (내역)"
rpm -qi docker-compose
echo "#-- ${yyy}(7-4)${xxx} sudo docker ps -a"
sudo docker ps -a
echo "#-- ${yyy}(7-5)${xxx} sudo docker-compose pull ${WIKI_SERVICE} (빌드)"
sudo docker-compose pull ${WIKI_SERVICE} ### ### sudo docker-compose up --build ###

cat <<__EOF__
...
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 🔻🔻🔻🔻🔻🔻🔻🔻🔻🔻
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: Browse to http://YOUR-SERVER-IP:3000/ to complete setup!
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 🔻🔻🔻🔻🔻🔻🔻🔻🔻🔻


위와 같은 메세지가 표시되면,

(1) ----> 아래의 명령을 --- 직접 --- 입력해서,

sudo docker ps -a

도커 실행내역을 확인합니다.

(2) ----> 브라우저에서 --- 아래의 주소를 입력해서,

localhost:${WIKI_PORT_NO}

wiki.js 를 실행해서 --- 관리자 등록과 첫 홈페이지를 만듭니다.

----> ${yyy}(7-6)${xxx} press Enter:
__EOF__
read a

echo "#-- ${yyy}(7-7)${xxx} sudo docker-compose up --force-recreate & (빌드한 도커 컴포즈를 실행합니다)"
sudo docker-compose up --force-recreate &
echo "#-- ${yyy}(7-8)${xxx} sudo docker-compose ps -a"
sudo docker-compose ps -a
echo "#-- ${yyy}(7-9)${xxx} --------------------"
```

# 데이터 백업과 리스토어

## 8. 단순백업 보관하기

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

#--> 로컬과 원격 보관장소
this_y4m2=$(date +%Y)-$(date +%m) #- 2022-08
LOCAL_Y2M2=${LOCAL_FOLDER}/${this_y4m2}
if [ ! -d ${LOCAL_Y2M2} ]; then
        echo "#-- ${yyy}(8-1)${xxx} ${LOCAL_Y2M2} 로컬 디렉토리를 만듭니다."
    mkdir -p ${LOCAL_Y2M2}
fi
CLOUD_Y2M2=${CLOUD_FOLDER}/${this_y4m2}
#<-- 로컬과 원격 보관장소

echo "#-- ${yyy}(8-2)${xxx} 위키 도커를 중단합니다."
echo "#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER}"
sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER}
if [ ! -d ${LOCAL_FOLDER} ]; then
    echo "#-- ${yyy}(8-3)${xxx} 보관 폴더를 만듭니다."
    echo "#-- sudo mkdir -p ${LOCAL_FOLDER} ; sudo chown ${USER}:${USER} ${LOCAL_FOLDER}"
    sudo mkdir -p ${LOCAL_FOLDER} ; sudo chown ${USER}:${USER} ${LOCAL_FOLDER}
fi

echo "#-- ${yyy}(8-4)${xxx} 백업을 보관하는 로컬 디렉토리 입니다."
echo "#-- ls -lR ${LOCAL_Y2M2}"
ls -lR ${LOCAL_Y2M2}

ymd_hm=$(date +"%y%m%d%a-%H%M")
current_backup=${DB_NAME}_${ymd_hm}_$(uname -n).sql.7z #- 압축파일 이름
cat <<__EOF__
#-
#- DB 백업
#-
#- (8-5)${xxx} wili.js 데이터베이스를 백업하기 위해서 아래에 ---비밀번호--- 를 입력하세요.
#-
__EOF__
echo "#-- ${yyy}(8-5)${xxx} 오늘 요일이름의 로컬 보관장소에 백업합니다."
echo "#-- sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -si ${LOCAL_Y2M2}/${current_backup} -p"
sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -si ${LOCAL_Y2M2}/${current_backup} -p
echo "#-- ${yyy}(8-6)${xxx} 보관용 로컬 폴더입니다."
echo "#-- ls -lR ${LOCAL_Y2M2}"
ls -lR ${LOCAL_Y2M2}
echo "#-- ${yyy}(8-7)${xxx} 오늘 요일이름의 파일을 클라우드로 복사합니다."
echo "#-- /usr/bin/rclone copy ${LOCAL_Y2M2}/${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/"
/usr/bin/rclone copy ${LOCAL_Y2M2}/${DB_sql7z} ${CLOUD_NAME}:${CLOUD_Y2M2}/
echo "#-- ${yyy}(8-8)${xxx} 클라우드 폴더입니다."
echo "#-- /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}"
/usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
echo "#-- ${yyy}(8-9)${xxx} 위키 도커를 다시 시작합니다."
echo "#-- sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a"
sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
echo "#-- ${yyy}(8-10)${xxx} --------------------"
```
## 9. 백업파일을 DB 에 도로담기

1. 구글 클라우드로 백업했던 wiki.js db 파일을 로컬 폴더로 복사한다.
1. 복사한 db 파일 이름 을 다음과 같이 스크립트를 사용해서 wiki.js 에 올린다.
1. 리스토어 하기 전에, 현재의 데이터베이스를 저장할 것인지 물어서, 답에 따라 현재 db 를 만들어 놓고 나서 리스토어한다

`백업 backup`: 현재의 데이터베이스를 **wikipg-220907수-1802-proenpi4b.sql.7z** 와 같은 이름으로 압축해서 저장한다.
`리스토어 restore`: 압축해서 보관했던 백업 파일을 데이터베이스에 도로 부어 담는다.
`현재 상태의 마지막 백업`: 백업파일을 리스토어 하는 경우, 현재의 db 에 들어있던 데이터는 백업파일에 의해 지워진다. 그래서 일단 현재상태의 db 를 **" last-${DB_CONTAINER}-$(date +%y%m%d_%H%M%S)-$(uname -n).sql.7z "** 등으로 백업하고서 리스토어 하기 위해서 마지막 백업을 실시한다.

```
hhh=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)

for i in {0..9}; do echo "#"; done


#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

#--> 로컬과 원격 보관장소
this_y4m2=$(date +%Y)-$(date +%m) #- 2022-08
LOCAL_Y2M2=${LOCAL_FOLDER}/${this_y4m2}
if [ ! -d ${LOCAL_Y2M2} ]; then
        echo "#-- ${yyy}(9-1)${xxx} ${LOCAL_Y2M2} 로컬 디렉토리를 만듭니다."
    mkdir -p ${LOCAL_Y2M2}
fi
CLOUD_Y2M2=${CLOUD_FOLDER}/${this_y4m2}
#<-- 로컬과 원격 보관장소


echo "#-- ${yyy}(9-2)${xxx} \${restore_sql_7z} = ${restore_sql_7z};"

if [ "x${restore_sql_7z}" = "x" ] || [ ! -f "${restore_sql_7z}" ]; then
    cat <<__EOF__
#-- ${yyy}(9-3)${xxx} ls -lR ${LOCAL_FOLDER} #--- 백업 디렉토리
$(ls -lR ${LOCAL_FOLDER})
#--
#-- 리스토어 할 파일 이름을 아래와 같이 선언하고, 이 스크립트를 실행해야 합니다.
#--
#-- 리스토어 할 파일 이름이 " /home/backup/wikipg/2023-09 " 디렉토리에 있는 " last-${DB_CONTAINER}-230908금-1431-vFedora38.sql.7z " 인 경우:
#-- 
#-- restore_sql_7z="/home/backup/wikipg/2023-09/last-${DB_CONTAINER}-230908금-1431-vFedora38.sql.7z"
#-- 
#-- 이와 같이 선언하고 나서, 이 스크립트를 실행해야 합니다.
#--
#----> Ctrl + C 를 눌러서 중단하세요.
__EOF__
  until [ "x" = "y" ]; do echo "----> [Ctrl] + [C] 를 눌러서 끝냅니다."; read a; done
fi


echo "----> ls -l ${restore_sql_7z}"
ls -l ${restore_sql_7z}

# ----

sql_name=$(basename ${restore_sql_7z}) # 백업파일 이름만 꺼냄
sql_dir=${restore_sql_7z%/$sql_name} # 백업파일 이름을 빼고 나머지 디렉토리만 담음
cat <<__EOF__

restore_sql_7z = "${restore_sql_7z}" # (9-3)
sql_name = ${sql_name} # 백업파일 이름만 꺼냄
sql_dir = ${sql_dir} # 백업파일 이름을 빼고 나머지 디렉토리만 담음
----> Press Enter:
__EOF__
read a

echo "#-- ${yyy}(9-4)${xxx} 현재의 DB 를 last_backup 으로 백업하지 않으려면, ' n ' 을 눌러 주세요."
read a ; echo "${uuu}"
echo "[ ${a} ]"
last_skip="db_backup_ok"
if [ "x$a" = 'xn' ]; then
  cat <<__EOF__
# |
# |
# |
# |
# |
# |
!!!! 주의 !!!! 현재 DB 를 다운로드 + 백업하지 않고, 업로드 합니다.

----> press ' y ' Enter:
__EOF__
  read a ; echo "${uuu}"
  echo "[ ${a} ]"
  if [ "x$a" != "xy" ]; then
    # ----
    rm -f ${zz00log_name}
    until [ "x" = "y" ]; do echo "----> [Ctrl] + [C] 를 눌러서 끝냅니다."; read a; done
  fi
  last_skip="no_backup"
fi

cat <<__EOF__
#-- ${yyy}(9-5)${xxx} 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a

if [ "x${last_skip}" = "xdb_backup_ok" ]; then
  current_backup="last-${DB_CONTAINER}-$(date +%y%m%d_%H%M%S)-$(uname -n).sql.7z"
  cat <<__EOF__
#-- ${yyy}(9-6)${xxx} 지정한 백업파일을 데이터베이스에 붓기 전에,
#--     현재 운영중인 DB 를 먼저 ${LOCAL_Y2M2} 에 백업합니다.
#--
#-- 백업받은 .7z 파일에 지정해 줄 새로운 비밀번호를 입력하세요.
#-- sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -mx=9 -p -si ${LOCAL_Y2M2}/${current_backup}
__EOF__
  sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -mx=9 -p -si ${LOCAL_Y2M2}/${current_backup}
fi
echo "#-- ${yyy}(9-7)${xxx} 오늘 요일이름의 파일을 클라우드로 복사합니다."
echo "#-- /usr/bin/rclone copy ${LOCAL_Y2M2}/${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/"
/usr/bin/rclone copy ${LOCAL_Y2M2}/${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/
echo "#-- ${yyy}(9-8)${xxx} 클라우드 폴더입니다."
echo "#-- /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}"
/usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}

cat <<__EOF__
#-- ${yyy}(9-9)${xxx} 기존의 데이터베이스를 삭제합니다.
#-- sudo docker exec -it ${DB_CONTAINER} dropdb -U ${DB_USER} ${DB_NAME}
__EOF__
sudo docker exec -it ${DB_CONTAINER} dropdb -U ${DB_USER} ${DB_NAME}

cat <<__EOF__
#-- ${yyy}(9-10)${xxx} 빈 데이터베이스를 새로 만듭니다.
#-- sudo docker exec -it ${DB_CONTAINER} createdb -U ${DB_USER} ${DB_NAME}
__EOF__
sudo docker exec -it ${DB_CONTAINER} createdb -U ${DB_USER} ${DB_NAME}

cat <<__EOF__
#-- ${yyy}(9-11)${xxx} 지정한 백업파일을 데이터베이스에 다시 붓습니다. (RESTORE)
#-- 백업할때 입력한 비밀번호를 입력하세요.
#-- time 7za x -so ${restore_sql_7z} | sudo docker exec -i ${DB_CONTAINER} psql -U ${DB_USER} ${DB_NAME}
__EOF__
time 7za x -so ${restore_sql_7z} | sudo docker exec -i ${DB_CONTAINER} psql -U ${DB_USER} ${DB_NAME}

restore_sql_7z="restore finish !" #-- 파일 이름이 다시 쓰이지 않도록 지운다.

cat <<__EOF__
#-- ${yyy}(9-12)${xxx} 멈췄던 위키 컨테이너를 다시 시작합니다.
#-- sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
echo "#-- ${yyy}(9-13)${xxx} 백업 작업이 끝났습니다."
```

결과
```
#
#
#
#-- (9-1) ${restore_sql_7z} = /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z;
----> ls -l /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z
-rw-r--r--. 1 yosj yosj 23026  9월  8일  16:37 /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z

restore_sql_7z = "/home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z" # (9-3)
sql_name = wikidb_230908금-1637_vFedora38.sql.7z # 백업파일 이름만 꺼냄
sql_dir = /home/backup/wikipg/2023-09 # 백업파일 이름을 빼고 나머지 디렉토리만 담음
----> Press Enter:

#-- (9-4) 현재의 DB 를 last_backup 으로 백업하지 않으려면, ' n ' 을 눌러 주세요.
[ n ]
# |
# |
# |
# |
# |
# |
!!!! 주의 !!!! 현재 DB 를 다운로드 + 백업하지 않고, 업로드 합니다.

----> press ' y ' Enter:
[ y ]
#-- (9-5) 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop wikijs ; sudo docker ps -a
CONTAINER ID   IMAGE                COMMAND                   CREATED          STATUS          PORTS                                                 NAMES
9ced4fe78495   requarks/wiki:2      "docker-entrypoint.s…"   44 minutes ago   Up 4 minutes    3443/tcp, 0.0.0.0:9900->3000/tcp, :::9900->3000/tcp   wikijs
b665608edfe3   postgres:11-alpine   "docker-entrypoint.s…"   44 minutes ago   Up 44 minutes   5432/tcp                                              wikipg
wikijs
CONTAINER ID   IMAGE                COMMAND                   CREATED          STATUS                              PORTS      NAMES
9ced4fe78495   requarks/wiki:2      "docker-entrypoint.s…"   44 minutes ago   Exited (0) Less than a second ago              wikijs
b665608edfe3   postgres:11-alpine   "docker-entrypoint.s…"   44 minutes ago   Up 44 minutes                       5432/tcp   wikipg
#-- (9-7) 오늘 요일이름의 파일을 클라우드로 복사합니다.
#-- /usr/bin/rclone copy /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z tpn3mi:wikipg/2023-09/
2023/09/08 17:19:46 ERROR : Local file system at /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z: error reading source root directory: directory not found
2023/09/08 17:19:46 ERROR : Attempt 1/3 failed with 1 errors and: directory not found
2023/09/08 17:19:46 ERROR : Local file system at /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z: error reading source root directory: directory not found
2023/09/08 17:19:46 ERROR : Attempt 2/3 failed with 1 errors and: directory not found
2023/09/08 17:19:46 ERROR : Local file system at /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z: error reading source root directory: directory not found
2023/09/08 17:19:46 ERROR : Attempt 3/3 failed with 1 errors and: directory not found
2023/09/08 17:19:46 Failed to copy: directory not found
#-- (9-8) 클라우드 폴더입니다.
#-- /usr/bin/rclone lsl tpn3mi:wikipg/2023-09
    23138 2023-09-08 16:38:00.000000000 wikidb_230908-1427_vFedora38.sql.7z
    23138 2023-09-08 14:28:08.000000000 wikidb_230908금-1427_vFedora38.sql.7z
    24322 2023-09-08 14:31:41.000000000 wikidb_230908금-1431_vFedora38.sql.7z
    23026 2023-09-08 16:38:01.000000000 wikidb_230908금-1637_vFedora38.sql.7z
    24482 2023-09-08 16:40:15.000000000 wikidb_230908금-1640_vFedora38.sql.7z
#-- (9-9) 기존의 데이터베이스를 삭제합니다.
#-- sudo docker exec -it wikipg dropdb -U imwiki wikidb
#-- (9-10) 빈 데이터베이스를 새로 만듭니다.
#-- sudo docker exec -it wikipg createdb -U imwiki wikidb
#-- (9-11) 지정한 백업파일을 데이터베이스에 다시 붓습니다. (RESTORE)
#-- 백업할때 입력한 비밀번호를 입력하세요.
#-- time 7za x -so /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z | sudo docker exec -i wikipg psql -U imwiki wikidb

SET
SET
SET
ERROR:  role "imwiki" already exists
ALTER ROLE
You are now connected to database "template1" as user "imwiki".
SET

...

ALTER TABLE
ALTER TABLE
ALTER TABLE

real	1m31.252s
user	0m0.064s
sys	0m0.045s
#-- (9-12) 멈췄던 위키 컨테이너를 다시 시작합니다.
#-- sudo docker start wikijs ; sudo docker ps -a
wikijs
CONTAINER ID   IMAGE                COMMAND                   CREATED          STATUS                  PORTS                                                 NAMES
9ced4fe78495   requarks/wiki:2      "docker-entrypoint.s…"   46 minutes ago   Up Less than a second   3443/tcp, 0.0.0.0:9900->3000/tcp, :::9900->3000/tcp   wikijs
b665608edfe3   postgres:11-alpine   "docker-entrypoint.s…"   46 minutes ago   Up 46 minutes           5432/tcp                                              wikipg
#-- (9-13) 백업 작업이 끝났습니다.
17:21:23금230908 yosj@vFedora38 ~
```

# 230906 수
0930 진도

1. 1029 여임대인전화,군에간아들500여일후제대후 지방근무로 전세끼고매매검토중, 연락요망.
1. 타 자료 복사
1. gimp사진수정 > 사진폴더 만들고 업로드 > 링크
1. wikijs 내부망에서 공유하기 - 공유기 세팅 / windows-virtualbox 포트포워딩
1. Dropbox 사용 - 3개 장치만 가능.
1. wiki.js 데이터베이스 백업
1. Container & K8S & Automation/Docker Docker 명령어 정리 승어리(Won) 2019. 1. 30. 14:23 https://captcha.tistory.com/49

1. FFmpeg 및 대안을 사용하여 WebM을 MP3로 변환하는 방법 작성자: Christine Smith • 2023-05-31 15:56:08 • 검증된 솔루션 https://videoconverter.wondershare.com/convert-mp3/ffmpeg-webm-to-mp3.html
1. FFmpeg 다운로드 https://www.ffmpeg.org/download.html
https://mirror.fcix.net/rpmfusion/free/fedora/releases/38/Everything/x86_64/os/repoview/ffmpeg.html 에서 `ffmpeg-*.rpm` 을 다운로드 한다.
```
sudo dnf install ./ffmpeg-6.0-6.fc38.x86_64.rpm
```
FILE="230905-탐사...소리-74M.webm" ; ffmpeg -i "${FILE}" -vn -ab 128k -ar 44100 -y "${FILE%.[Ww][Ee][Bb][Mm]}.mp3"


# 230905 화
1010 푸른숲

1. yes24 ebook PC 뷰어 다운로드
https://www.yes24.com/notice/eBookGuide/guide_pc.aspx
1. 팬데믹 프로그램 종료, 가족저축 중단, 인플레이션으로 비용증가.
1조달러 신용카드빚, 연체율 3.8%, 소비자대출 연체 5.4%, 자동차대출 연체 3.6%, 신용카드 이자율 21%
Buy Now Pay Later 옵션 의존 > 가구,TV 아니고 식료품 21%
한국 생활비, 주택, 교육비 문제 - thedailyupside.com
구글엑셀 - 금전출납부
구글keep - 즉시메모
wiki.js - 글쓰기
keepassXC + onedrive - 암호관리
1. Spring Boot 3 및 React를 사용한 풀 스택 개발 - Fourth Edition https://subscription.packtpub.com/book/web-development/9781805122463/1
Full Stack Development with Spring Boot 3 and React - If you’re an existing Java developer who wants to go full stack or pick up another frontend framework, this book is... By Juha Hinkula Oct 2023
1. 워드프레스 플러그인 개발 쿡북 WordPress Plugin Development Cookbook - Third Edition - WordPress is one of the most widely used, powerful, and open content management systems (CMSs). Whether you're a si... By Yannick Lefebvre Mar 2022 420 page https://subscription.packtpub.com/book/web-development/9781801810777/pref
1. WooCommerce 마스터하기 4 WooCommerce는 온라인 상점 구축을 위한 가장 유연한 플랫폼 중 하나입니다. 유연성으로 v를 제공할 수 있습니다. By Patrick Rauland Mar 2020 334 pages
1. WordPress 5 Cookbook 워드프레스 5 요리책 WordPress는 수년 동안 가장 인기있는 콘텐츠 관리 시스템 (CMS)이었으며 현재 30 % 이상을 지원하고 있습니다. By Rakhitha Nimesh Ratnayake Mar 2020 660 pages
1. keePassXC 다운로드 https://keepassxc.org/download/#
브라우저 확장 프로그램 다운로드 -- 컴퓨터에 KeePassXC가 설정되면 KeePassXC 브라우저 확장 프로그램을 다운로드하여 브라우저에서 온라인 비밀번호를 자동으로 입력합니다.
[ FireFox 용 ](https://addons.mozilla.org/en-US/firefox/addon/keepassxc-browser/) 다운로드
[ Chrome 용 ](https://chrome.google.com/webstore/detail/keepassxc-browser/oboonakemofpalcgghocfoadofidjkkk) 다운로드
[ Edge 용 ](https://microsoftedge.microsoft.com/addons/detail/keepassxcbrowser/pdffhmdngciaglkoonimfcmckehcpafo) 다운로드
1. vcruntime140_1.dll 오류 - 다운로드 해결방법(매우 간단) 김세인트 컴퓨터공학과 / 그외  2022. 8. 7. https://mk28.tistory.com/273#google_vignette

# 230904 월

1. mysql 에서 한글 사용하려면,
1. [MySQL] 데이터 타입(data_type) 정리 https://spiderwebcoding.tistory.com/5
1. MySQL에서 한글 인코딩 문제 해결하기 jimin_lee·2021년 3월 1일 https://velog.io/@jimin_lee/MySQL%EC%97%90%EC%84%9C-%ED%95%9C%EA%B8%80-%EC%9D%B8%EC%BD%94%EB%94%A9-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0
1. [MySQL] Load Data 시도 중 secure_file_priv 문제 직면 수노 SUNHO 2017. 10. 26. 09:30 https://sssunho.tistory.com/56
1. 올인원 비디오 변환기 https://videoconverter.wondershare.com/convert-mp3/ffmpeg-webm-to-mp3.html
1. 펌) 유독 한국에서만 흥행했던 영화들 ㄷㄷㄷㄷㄷ [37]18:24:41심푸순&나물밥상 https://www.ddanzi.com/index.php?mid=free&statusList=HOT%2CHOTBEST%2CHOTAC%2CHOTBESTAC&document_srl=781183024
1. [!긴급편성!] 홍범도 장군 흉상 철거? 이완용도 이러지는 않았다!!! 우리가 북한과 다른 이유? 독립운동사를 왜곡하는 것은 반헌법적인 것! #심용환 #현재사는심용환 #홍범도 현재사는 심용환 구독자 16.9만명 조회수 4.2만회  1일 전 https://www.youtube.com/watch?v=19qyfJfR7Wk
1. Ubuntu 및 기타 Linux 배포판에서 YouTube 비디오를 다운로드하는 3가지 쉬운 방법 이러한 애플리케이션을 사용하여 Ubuntu 및 기타 Linux 배포판에서 YouTube, Vimeo, Dailymotion 및 Facebook 비디오를 다운로드하세요. 아비셰크 프라카시 2023년 5월 7일 https://itsfoss.com/download-youtube-videos-ubuntu/
```
sudo dnf in yt-dlp
```
1. docker 설치 https://docs.docker.com/engine/install/fedora/

(1) 옛버전 삭제
```
sudo dnf remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
```
(2) 리파지토리 셋업
```
sudo dnf -y install dnf-plugins-core
sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
```
(3) 도커 엔진 설치
If prompted to accept the GPG key, verify that the fingerprint matches 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35, and if so, accept it.
```
sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```
(4) 도커 시작
```
sudo systemctl start docker
```
1. Fedora 38 등에서 Docker Compose 를 설치하고 사용하기 ByJosphat Mutai-August 17, 2023 https://computingforgeeks.com/install-and-use-docker-compose-on-fedora/#google_vignette
1단계: Docker 엔진 설치
2단계: Fedora에 Docker Compose 설치
2단계: 방법 1: 바이너리 파일에서 Docker Compose를 설치합니다.
2단계: 방법 2: OS 저장소에서 Fedora에 Docker Compose 설치(최신 패키지가 아님)

2단계: 방법 1: Fedora 업스트림 리포지토리에서 사용 가능한 Docker Compose 버전을 설치하려면 다음 명령을 실행하세요.
```
sudo dnf install docker-compose
rpm -qi docker-compose
```
3단계: Compose 명령줄 완성 구성
 Compose에는 bash 및 zsh 셸에 대한 명령 완성 기능이 제공됩니다  .

배시 사용자의 경우
완성 스크립트를 /etc/bash_completion.d/에 넣으세요.
```
sudo curl -L https://raw.githubusercontent.com/docker/compose/master/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose
source /etc/bash_completion.d/docker-compose
```

## Fedora Update

### 1. 비번스킵
```
sudo vi /etc/sudoers # G10kyyp2xwcw<USERNAME><ESC>:x!<ENTER>
```

#### 1.1 호스트 이름을 vFed37 로 바꾼다
```
sudo hostnamectl set-hostname vFed37
```

#### 1.2 Google 크롬 리포지토리 활성화
```
sudo dnf config-manager --set-enabled google-chrome
```

### 2. 추가로 프로그램 설치
```
sudo dnf install make automake autoconf gcc dkms \
    kernel-debug-devel kernel-devel wget vim-enhanced vim-common \
    mc git p7zip gnome-tweak-tool rclone \
    snapd keepassxc fedora-workstation-repositories \
    google-chrome-stable \
    livecd-tools liveusb-creator -y
```

#### 2.1 커널 버전 확인
```
rpm -qa | grep kernel | sort | grep kernel
```

#### 2.2 원격 셀 sshd 실행
```
sudo systemctl enable sshd
sudo systemctl start sshd
```

### 3. vbox 그룹 추가
```
grep vboxsf /etc/group | grep ${USER}
grep vboxsf /etc/group
```

#### 3.1 vboxsf 그룹 추가하고 다시 확인
```
sudo gpasswd -a ${USER} vboxsf
grep vboxsf /etc/group
```

#### 3.2 vboxsf 그룹에 사용자가 추가됐다면, 이 시스템을 다시 시작해야 한다.
```
sudo reboot
```

### 4. 게스트 확장 CD 이미지 삽입

vfedora 초기화 작업을 진행하기 전에,
화면 맨 윗줄에 표시된 (파일 , 머신 , 보기 , 입력 , 장치 , 도움말) 메뉴에서,

[장치] 클릭 >> [게스트 확장 CD 이미지 삽입] 을 클릭하고,
자동으로 시작하기로 한 프로그램 . . . 실행하시겠습니까? >> [실행] 을 클릭.

#### 4.1 윈도우에서 탐색기 창을 열고, "다운로드" 폴더에 "bada" 라는 폴더를 새로 만든다.

#### 4.2 자동시작 프로그램을 실행한다.
```
sudo /sbin/rcvboxadd quicksetup all ; sudo /sbin/rcvboxadd setup
```

#### 4.3 윈도우와 연결하는 폴더를 ${HOME}/wind_bada 라는 이름으로 연결한다.
```
ln -s /media/sf_Downloads/bada/ ${HOME}/wind_bada
```

#### 4.4 호스트(host) 인 윈도우 폴더가 게스트i(guest) 인 fedora 에 마운트 되었는지 확인한다.
```
ls -l ${HOME}
ls -l ~/wind_data
```

### 5. VundleVim 설치
```
sudo dnf install git gcc vim-enhanced vim-common p7zip

git clone https://github.com/susabolca/Vundle.vim ${HOME}/.vim/bundle/Vundle.vim
```

#### 5.1 proen 서버에 미리 만들어둔 파일을 ${HOME} 디렉토리로 복사한다.
```
rsync -avzr -e 'ssh -p 15822' proenpi@proen.duckdns.org:ar*/my*/li*/DOTbashrc ~/.bashrc
rsync -avzr -e 'ssh -p 15822' proenpi@proen.duckdns.org:ar*/my*/li*/DOTvimrc ~/.vimrc
```

#### 5.2 Bundle 을 설치한다
```
vim +BundleInstall +qall
```

### 6. 한글 폰트파일 설치
```
sudo rsync -avzr -e 'ssh -p 15822' proenpi@proen.duckdns.org:ar*/my*/li*/font*7z /usr/share/fonts/

cd /usr/share/fonts/ ; 7za x ./font*.7z
sudo chown root:root D2Coding KoPub jeju_ttf naver-nanum seoul
sudo chmod 755 D2Coding KoPub jeju_ttf naver-nanum seoul
sudo chmod 644 D2Coding/* KoPub/* jeju_ttf/* naver-nanum/* seoul/*
```

#### 6.1 snap 링크 설치 확인
```
sudo ln -s /var/lib/snapd/snap /snap
ls -l --color /snap
```

#### 6.2 sdkman 설치
```
curl -s \"https://get.sdkman.io\" | bash
```

# 230903 일

1. Excel을 MySQL로 가져오기: 4가지 쉬운 방법 by Dhanashree Published: & Updated:  Apr 4, 2023 https://nanonets.com/blog/import-excel-into-mysql/
1. How to Install MySQL on Fedora? author thedeepak https://www.geeksforgeeks.org/how-to-install-mysql-on-fedora/
1. Linux에서 Docker를 사용하여 MySQL을 설정하는 방법 Karthick 이 작성 : 2021년 12월 6일마지막 업데이트 날짜 2022년 12월 7일 https://ostechnix.com/setup-mysql-with-docker-in-linux/
1. Fedora 38/37/36/35/34/33에서 Mysql Workbench 설치 및 사용 에 의해클린스만 외테요-2023년 8월 23일 https://computingforgeeks.com/install-and-use-mysql-workbench-on-fedora/?expand_article=1

## Linux 에서 Docker 를 사용하여 MySQL 을 설정하는 방법
by Karthick Published: December 6, 2021 Last Updated on December 7, 2022 https://ostechnix.com/setup-mysql-with-docker-in-linux/

### 1. Install Docker
```
sudo docker --version
sudo docker-compose --version
```

### 2. Download MySQL Docker Image
```
docker pull mysql:latest
docker images mysql
```

### 3. Launch MySQL Container
```
docker run --name mysql -p 7700:3306 -v mysql_volume:/var/lib/mysql/ -d -e "MYSQL_ROOT_PASSWORD=temp123" mysql
```
여러줄로 나누어 표시:
```
docker run --name mysql \
    -p 7700:3306 \
    -v mysql_volume:/var/lib/mysql/ \
    -d \
    -e "MYSQL_RANDOM_ROOT_PASSWORD=1" \
    \ #-- 또는 -e "MYSQL_ROOT_PASSWORD=temp123"
    mysql
```
`--name` → 컨테이너에 이름을 지정합니다. 이 플래그를 지정하지 않으면 docker는 무작위로 생성된 이름을 할당합니다.

`-p` → 포트번호 매핑. MySQL은 3306 포트 에서 수신 대기하므로 호스트 시스템의 포트 (7700 → 3306) 를 도커 컨테이너에 매핑합니다 . 호스트 포트번호는 반드시 7700 이어야 하는 것은 아니며, 사용할 수 있는 포트번호면 무엇이든 가능합니다.
로컬 머신에서 다음 netstat 명령을 실행하여 컨테이너가 시작된 후 매핑된 포트가 수신 대기 중인지 여부를 확인하세요.
```
netstat -tlnup | grep -i 7700
```
`-v` → 컨테이너에 볼륨을 연결합니다.
docker의 기본 동작은 컨테이너가 제거되면 데이터를 유지하지 않으므로 모든 데이터가 손실된다는 것입니다. 그래서 영구 저장소를 생성하기 위해 'mysql_volume' 이라는 볼륨을 localhost 에 생성했습니다.
MySQL은 컨테이너 내부에 위치한 `/var/lib/mysql/` 에 데이터를 저장하고, 이곳이 여기서는 컨테이너 외부인 localhost 디렉토리의 `/var/lib/docker/volumes/mysql_volume1/_data` 가 영구 저장되는 곳으로 매핑됩나다.

`-d` → 분리 모드에서 컨테이너를 시작하고 실행합니다. 플래그 를 생략하면 -d터미널에 컨테이너 시작 로그가 표시되며 컨테이너에 연결하려면 새 터미널 세션을 열어야 합니다.

`-e` → 환경 변수. 아래 매개변수 중 하나를 사용하여 mysql 루트 사용자 비밀번호를 설정 해야 합니다 .

- `MYSQL_ROOT_PASSWORD` → 이 환경 변수를 사용하여 자신만의 비밀번호를 설정하세요.
- `MYSQL_ALLOW_EMPTY_PASSWORD` → 공백 또는 Null 비밀번호가 설정됩니다. `MYSQL_ALLOW_EMPTY_PASSWORD=1` 을 설정해야 합니다.
- `MYSQL_RANDOM_ROOT_PASSWORD` → 컨테이너가 시작되면 임의의 비밀번호가 생성됩니다. `MYSQL_RANDOM_ROOT_PASSWORD=1` 임의의 비밀번호를 생성하도록 설정해야 합니다 .

### 4. MySQL 컨테이너 상태 확인

다음 명령을 사용하여 시작된 컨테이너 상태를 확인할 수 있습니다.
```
docker ps -a
```

### 5. MySQL 데이터베이스에 연결

다음 명령을 실행하여 MySQL 컨테이너에 연결합니다.
```
docker exec -it mysql bash
```

컨테이너를 시작할 때 `MYSQL_RANDOM_ROOT_PASSWORD=1` 을 사용했다면, 로그에서 자동으로 생성된 비밀번호를 얻을 수 있습니다.

```
docker logs mysql | grep "GENERATED ROOT PASSWORD"
```

비밀번호를 입력해서 시작합니다.
```
mysql -u root -p
```

자동으로 생성된 루트 비밀번호는 길어서 기억할 수 없습니다. 다음 쿼리를 실행하여 루트 비밀번호를 **my_new_pswd** 로 재설정할 수 있습니다.
```
mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'my_new_pswd';
```

### 6. 샘플 데이터 로딩

mysql 을 설정하는 주요 목적은 일부 데이터를 로드하고 이에 대해 쿼리를 실행하는 것입니다. 데이터를 로드할 수 있는 몇 가지 방법이 있습니다. 다음에 쿼리가 포함된 "load_data.sql" 이라는 샘플 파일이 있습니다.
```
CREATE DATABASE IF NOT EXISTS football;

USE football;

CREATE TABLE IF NOT EXISTS players (
    player_name     VARCHAR(16)     NOT NULL,
    player_age      INT             NOT NULL,
    player_club     VARCHAR(16)     NOT NULL,
    player_country  VARCHAR(16)     NOT NULL
);

INSERT INTO players VALUES ("Messi",34,"PSG","Argentina");
INSERT INTO players VALUES ("Ronaldo",36,"MANU","Portugal");
INSERT INTO players VALUES ("Neymar",29,"PSG","Brazil");
INSERT INTO players VALUES ("Kane",28,"SPURS","England");
INSERT INTO players VALUES ("E Hazard",30,"MADRID","Belgium");
```

첫 번째 접근 방식은 "docker cp" 명령을 사용하여 로컬 시스템의 데이터를 도커 컨테이너로 복사하는 것입니다.
```
docker cp load_data.sql mysql:/tmp
docker exec -it mysql bash
ls -l /tmp/
```

이제 mysql 클라이언트에 연결하여 소스 명령을 실행하거나 파일을 mysql 클라이언트로 리디렉션할 수 있습니다.
```
mysql -u root -p
mysql> source /tmp/load_data.sql
```
또는
```
mysql -u root -p < /tmp/load_data.sql
```

데이터베이스에 연결하고 테이블을 쿼리합니다.
```
mysql -u root -p
show databases;
use football;
show tables;
select * from players;
```

두 번째 접근 방식은 docker exec 명령을 실행할 때 .sql 파일을 리디렉션하는 것입니다.
```
docker exec -i mysql mysql -u root -p < load_data.sql
```

## 7. Docker-Compose 를 사용하여 MySQL 컨테이너 설정
by Karthick Published: December 6, 2021 Last Updated on December 7, 2022 https://ostechnix.com/setup-mysql-with-docker-in-linux/

이미지를 가져와서 docker run 명령을 실행하는 대신, docker-compose 를 사용하여 컨테이너를 빠르게 가동할 수 있습니다. Docker-compose 는 생성할 컨테이너가 두 개 이상인 경우에 가장 적합합니다.

1. docker-compose 의 마지막 버전을 확인한다. https://github.com/docker/compose/releases
1. 마지막 버전을 가져온다.
```
DOCKER_COMPOSE_LAST_VERSION="v2.21.0" #-- 2023-09-04
sudo curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_LAST_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```
3. 파일의 퍼미션을 지정해주고, 설치한 docker-compose 의 버전을 확인한다.
```
sudo chmod +x /usr/local/bin/docker-compose
sudo docker-compose version
```


### docker-compose.yml 또는 docker-compose.yaml 이라는 파일을 만듭니다.

다음 yaml 코드를 복사하여 붙여넣습니다. 이는 이전 섹션에서 수동으로 실행한 것과 동일합니다.
```
version: '3.8'
services:
  database:
    image: mysql:latest
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: temp1234
    ports:
      - "7700:3306"
    volumes:
      - /home/docker/mysql:/var/lib/mysql
```
> - mysql_volume:/var/lib/mysql
> volumes:
>   mysql_compose_volume:

이제 MySQL 도커 컨테이너를 가동하는 다음 명령을 실행하십시오.
```
docker-compose up
```

docker-compose 를 사용하여 시작된 컨테이너의 상태를 확인하려면 다음 명령을 실행하십시오.
```
docker-compose ps -a
```

### Bash 스크립트를 만들고 한번에 실행할 수 있습니다.

```
23:12:41일230903 yos@yscart ~/git-projects/fedora-sh/13-xls2mysql-docker-compose
13-xls2mysql-docker-compose $ cat 00-docker-compose-mysql-설치.sh 
#!/bin/sh

source ${HOME}/bin/color_base #-- 221027목-1257 CMD_DIR CMD_NAME cmdRun cmdCont cmdYenter echoSeq 
MEMO="00 docker-compose 로 mysql 설치하기"
cat <<__EOF__
${cMagenta}>>>>>>>>>>${cGreen} $0 ${cMagenta}||| ${cCyan}${MEMO} ${cMagenta}>>>>>>>>>>${cReset}
__EOF__
#--zz00logs_folder="${HOME}/zz00logs" ; if [ ! -d "${zz00logs_folder}" ]; then cmdRun "mkdir ${zz00logs_folder}" "로그 폴더" ; fi
#--zz00log_name="${zz00logs_folder}/zz.$(date +"%y%m%d%a-%H%M%S")__RUNNING_${CMD_NAME}" ; touch ${zz00log_name}
# ----


#cmdRun "sudo docker-compose ps -a" "운영중인 MySQL DB 도커들"
##for out in $(sudo docker ps -a | awk '{print $NF}')
##do
##  if [ "x$out" != "xNAMES" ]; then
##    DB_IP=$(sudo docker inspect ${out} | grep '"IPAddress"' | tail -n 1 | awk -F : '{print $2}' | awk -F \" '{print $2}')
##    echo "${out}  ${DB_IP}"
##  fi
##done

CONTAINER_NAME=myxlsct
PORT_NO=7700
DATABASE_NAME=hajdb
#-xx LOG_NAME=myxlsctlog
#-xx USER_NAME=myxlsctroot

echo "${cRed}[ ${cYellow}${CONTAINER_NAME} ${cGreen}${DATABASE_NAME} ${cBlue}${USER_NAME} ${Red}] -OK-${cReset}"
#-xx echo "${cRed}[ ${cYellow}${CONTAINER_NAME} ${cGreen}${DATABASE_NAME} ${cBlue}${USER_NAME} ${cCyan}${LOG_NAME} ${Red}] -OK-${cReset}"

#--

DOCKER_NETWORK_NAME=goodworld

return_value=$(sudo docker network ls | grep "${DOCKER_NETWORK_NAME}")
if [ "x${return_value}" = "x" ]; then
  cmdCont "sudo docker network create ${DOCKER_NETWORK_NAME}"
fi

#--

# DATABASE_FOLDER=${HOME}/docker-data/database/${CONTAINER_NAME}
DATABASE_FOLDER=/home/docker/${CONTAINER_NAME}

if [ ! -d ${DATABASE_FOLDER} ]; then
  echo "----> ${cGreen}sudo mkdir -p ${DATABASE_FOLDER}${cReset}"
  sudo mkdir -p ${DATABASE_FOLDER}
  cmdRun "sudo chcon -R system_u:object_r:container_file_t:s0 ${DATABASE_FOLDER}"
  cmdRun "sudo chown -R systemd-coredump:ssh_keys ${DATABASE_FOLDER}"
  cmdRun "ls -lZ ${DATABASE_FOLDER}" "디렉토리를 만들었습니다."
else
  cmdRun "ls -l ${DATABASE_FOLDER}"
  echo "${cRed}!!!!${cMagenta} ----> ${cCyan}${DATABASE_FOLDER}${cReset} 디렉토리가 있으므로, 진행을 중단합니다."
  exit -1
fi

IS_DATABASE=$(sudo docker ps -a | grep ${CONTAINER_NAME})
if [ "x${IS_DATABASE}" != "x" ]; then
  sudo docker ps -a | grep ${IS_DATABASE}
  CAT <<__EOF__
${cRed}!!!!${cMagenta} ----> ${cCyan}${CONTAINER_NAME}${cReset} 도커가 있으므로, 진행을 중단합니다.
__EOF__
  exit -1
fi

# ----> MySQL 용 도커 설치

# cmdCont "$(cat <<__EOF__
XML_FILE="docker-compose.yml"
if [ -f "${XML_FILE}" ]; then
  cmdRun "ls -l ${XML_FILE}"
  cat <<__EOF__
${cRed}!!!!${cMagenta} ----> ${cCyan}${XML_FILE}${cReset} 파일이 있으므로, 진행을 중단합니다.
__EOF__
  exit -1
fi

cat > ${XML_FILE} <<__EOF__
version: '3.8'
services:
  database:
    image: mysql:latest
    container_name: myxlsct
    environment:
      MYSQL_RANDOM_ROOT_PASSWORD: 1
    ports:
      - "7700:3306"
    volumes:
      - /home/docker/mysql:/var/lib/mysql
__EOF__
#-- volumes: - /home/docker/mysql:/var/lib/mysql
#-- mysql 데이터 위치 - 도커바깥 PC의 위치=내가 지정 : 도커가 쓰는 도커안쪽 위치

cmdRun "cat ${XML_FILE}"

cmdRun "sudo docker-compose up &" "sudo docker logs ${CONTAINER_NAME} 2>&1 | grep --color PASSWORD # <---- (0) 표시된 비밀번호를 복사하세요."


echo "${cCyan}#----> db 초기화 작업이 끝날때까지 최대 2 분간 기다립니다."
sleep 15
for i in 1 2 3 4 5 6 7 8
do
  return_value=$(sudo docker logs ${CONTAINER_NAME} 2>&1 | grep PASSWORD)
  if [ "x${return_value}" = "x" ]; then
    cmdRun "sleep 15s" "#-- 비밀번호 확인 ${i}"
  else
    break
  fi
done

#--

if [ "x${return_value}" = "x" ]; then
  cmdCont "sudo docker logs ${CONTAINER_NAME} 2>&1 | grep --color PASSWORD" "${cRed}# <---- 비밀번호를 계속 확인해야 합니다."
else
  cmdRun "sudo docker logs ${CONTAINER_NAME} 2>&1 | grep --color PASSWORD" "# <---- (0) 위에 표시된 비밀번호를 복사하세요."
fi

cat <<__EOF__
sudo docker exec -it ${CONTAINER_NAME} mysql -u root -p ${cMagenta}# <---- ${cYellow}(1) ${cMagenta}Enter password: 가 나오면, GENERATED ROOT PASSWORD 를 여기에 붙여넣기 합니다.${cReset}

ALTER USER 'root'@'localhost' IDENTIFIED BY '<>-<>-<>'; ${cGreen}-- -- -- -- ${cYellow}(2) ${cMangeta}<>-<>-<> 자리에 비번을 넣습니다. 복사할때 앞의 ${cGreen}초록색 -- -- -- -- ${cMagenta} 까지만 복사해야 합니다.${cReset}
             |
       | 위와 같이 (1) ~ (2) 를 진행해야 설치가 끝납니다.
__EOF__
cmdRun "ls --color ${CMD_DIR}" ; ls --color ${logs_folder}


# alter user 'root'@'%' identified by '<>-<>-<>' ; grant all privileges on *.* to 'root'@'%' with grant option ; create database if not exists ${DATABASE_NAME} character set utf8 ; create user '${USER_NAME}'@'%' identified by '<>-<>-<>' ; grant all privileges on *.* to '${USER_NAME}'@'%' with grant option ; exit ; ${cGreen}-- -- -- -- ${cYellow}(2) ${cMangeta}<>-<>-<> 자리에 비번을 넣습니다. 복사할때 앞의 ${cGreen}초록색 -- -- -- -- ${cMagenta} 까지만 복사해야 합니다.${cReset}
# sudo docker exec -it ${CONTAINER_NAME} /bin/bash ; sudo docker restart ${CONTAINER_NAME} ; sudo docker ps -a ; ls --color ${CMD_DIR} ; ls --color ${logs_folder} ${cMagenta}# <---- ${cYellow}(3) ${cMagenta}docker 를 다시 시작해서 아래의 (4) 를 실행할 준비를 합니다.${cReset}
# echo "character-set-server=utf8" >> /etc/mysql/mysql.conf.d/mysqld.cnf ; tail -3 /etc/mysql/mysql.conf.d/mysqld.cnf ; exit ${cMagenta}# <---- ${cYellow}(4) ${cMagenta}docker 에서 utf8 을 쓰도록 지정합니다.${cReset}


# ----
#--rm -f ${zz00log_name} ; zz00log_name="${zz00logs_folder}/zz.$(date +"%y%m%d%a-%H%M%S")..${CMD_NAME}" ; touch ${zz00log_name}
#--ls --color     ${zz00log_name}
cat <<__EOF__
${cRed}<<<<<<<<<<${cBlue} $0 ${cRed}||| ${cMagenta}${MEMO} ${cRed}<<<<<<<<<<${cReset}
__EOF__
```

### 8. MySQL Workbench를 사용하여 MySQL 데이터베이스에 연결

지금까지 우리는 컨테이너 내부에서 mysql 클라이언트를 사용하여 데이터베이스에 연결하는 방법을 살펴보았습니다. mysql workbench, dbeaver, Heidi SQL 등과 같은 GUI 클라이언트를 사용하여 데이터베이스에 연결할 수도 있습니다.

어떤 GUI 클라이언트를 사용하고 있는지에 관계없이 주목해야 할 중요한 점은 컨테이너를 시작할 때 어떤 포트가 매핑되었는지입니다.

내 경우에는 localhost (`7700`) -> 컨테이너 (`3306`) 를 매핑했습니다. 따라서 데이터베이스에 연결해야 한다면 `localhost:7700` 또는 `127.0.01:7700` 에 연결해야 합니다.

### 8.1. Linux에 MySQL 워크벤치 설치

패키지 파일을 다운로드 하려면 [ 공식 사이트 ](https://dev.mysql.com/downloads/workbench/) 로 이동하세요. .deb 또는 .rpm 파일 을 다운로드하려면 운영 체제를 선택해야 합니다.
> Fedora 38 (x86, 64-bit), RPM Package  8.0.34  36.7M  [ Download ] 👈 선택
> (mysql-workbench-community-8.0.34-1.fc38.x86_64.rpm)  MD5: 6ce1e5a83d831434d9fba36b4927d969
> Fedora 38 (x86, 64-bit), RPM Package Debug Information  8.0.34  47.1M  
[ Download ]
> (mysql-workbench-community-debuginfo-8.0.34-1.fc38.x86_64.rpm)  MD5: a92ac950f0370846be6f5e698c75ede1

```
sudo dnf install ~/다운로드/mysql-workbench-community-8.0.34-1.fc38.x86_64.rpm
```
설치가 완료되면 메뉴나 대시보드에서 mysql Workbench를 시작할 수 있습니다.

### 8.2. MySQL 데이터베이스에 연결

Docker 컨테이너 내부에서 실행되는 데이터베이스에 연결합니다. 컨테이너 설정 방법에 따라 `localhost:3306` 또는 `localhost:<port-no>` 연결 을 시도해야 합니다.

데이터베이스에 연결하기 전에 "Test Connection" 를 눌러 MySQL 워크벤치가 데이터베이스 인스턴스에 성공적으로 연결할 수 있는지 확인할 수 있습니다.

## Excel을 MySQL로 가져오기: 4가지 쉬운 방법
by Dhanashree Published: & Updated:  Apr 4, 2023 https://nanonets.com/blog/import-excel-into-mysql/

### 방법 1: LOAD DATA INFILE 사용

가장 효율적인 방법 중 하나는 LOAD DATA 문을 사용하는 것입니다. 이 방법에서는 먼저 Excel 파일을 CSV 형식으로 변환한 다음 LOAD DATA 문을 사용하여 이를 MySQL 테이블로 가져와야 합니다.

#### (1단계): Excel 파일을 CSV 형식으로 변환
#### (2단계) MySQL Workbench를 열고 MySQL 서버에 연결
#### (3단계) LOAD DATA 문 입력
MySQL Workbench에 LOAD DATA 문을 입력하여 CSV 파일을 MySQL 테이블로 가져옵니다. LOAD DATA 문 구문은 다음과 같습니다.
```
LOAD DATA INFILE 'file_path/file_name.csv' -- csv 파일경로와 파일이름.
INTO TABLE table_name -- 담을 MySQL 테아블 이름.
FIELDS TERMINATED BY ',' -- 필드를 구분하는 기호.
ENCLOSED BY '"' -- 텍스트 구분 기호.
LINES TERMINATED BY '\n' -- 줄의 종결자.
IGNORE 1 ROWS; -- CSV 파일의 헤더 행 (1행) 을 건너뛰기.
```

#### (4단계): LOAD DATA 문을 실행합니다.


### 방법 2: MySQL Workbench 사용

MySQL Workbench는 MySQL 데이터베이스 관리에 널리 사용되는 도구이며 Excel을 포함한 다양한 소스에서 데이터를 가져오기 위한 사용하기 쉬운 인터페이스를 제공합니다. 

1. MySQL Workbench를 열고 MySQL 서버에 연결합니다.
1. 기본 메뉴에서 서버를 클릭한 다음 데이터 가져오기를 클릭하세요.
1. 데이터 가져오기 창에서 자체 포함 파일에서 가져오기를 선택하고 Excel 파일의 위치를 ​​찾습니다.
1. 대상 스키마에서 데이터를 가져올 데이터베이스를 선택합니다.
1. 기본 대상 개체 옵션에서 새 테이블 만들기를 선택하고 가져온 데이터를 보관할 새 테이블의 이름을 입력합니다.
1. 고급 옵션에서 Excel 파일에 열 머리글이 있는 경우 첫 번째 행을 열 이름으로 사용을 선택합니다.
1. 가져오기 시작을 클릭하여 가져오기 프로세스를 시작합니다.
1. 가져오기 프로세스가 완료될 때까지 기다립니다. Excel 파일의 크기와 가져온 데이터의 양에 따라 시간이 걸릴 수 있습니다.
1. 가져오기가 완료되면 데이터를 성공적으로 가져왔음을 확인하는 메시지가 표시됩니다.

### 방법 3: 프로그래밍 언어 사용: Apache 또는 Pandas

Apache와 Pandas는 Excel 데이터를 MySQL 데이터베이스로 가져오는 데 널리 사용되는 두 가지 도구입니다. Apache는 대규모 데이터 세트를 처리하는 확장 가능하고 효율적인 방법을 제공하는 오픈 소스 데이터 처리 도구입니다. 그리고 Pandas는 사용하기 쉬운 데이터 구조와 데이터 분석 도구를 제공하는 Python 라이브러리입니다.

#### (1) 아파치 사용

1. 다음 명령을 실행하여 필수 종속성을 설치합니다.
```
pip install apache-airflow[mysql]
```

2. 새 Python 파일을 열고 필요한 라이브러리를 가져옵니다.
```
import pandas as pd
from sqlalchemy import create_engine
```

3. read_excel() 함수를 사용하여 Excel 데이터를 pandas DataFrame에 로드합니다.
```
df = pd.read_excel('filename.xlsx')
```

4. create_engine() 함수를 사용하여 MySQL 데이터베이스에 대한 연결을 만듭니다.
```
engine = create_engine('mysql://username:password@host/database')
Use the to_sql() function to write the DataFrame to the MySQL database
df.to_sql(name='table_name', con=engine, if_exists='append', index=False)
```

#### (2) 팬더 사용:

1. 다음 명령을 실행하여 필수 종속성을 설치합니다.
```
pip install pandas mysql-connector-python
```

2. 새 Python 파일을 열고 필요한 라이브러리를 가져옵니다.
```
import pandas as pd
import mysql.connector
```

3. read_excel() 함수를 사용하여 Excel 데이터를 pandas DataFrame에 로드합니다.
```
df = pd.read_excel('filename.xlsx')
```

4. mysql.connector.connect() 함수를 사용하여 MySQL 데이터베이스에 대한 연결을 만듭니다.
```
connection = mysql.connector.connect(host='hostname',
user='username',
password='password',
database='database')
```

5. 커서 개체를 만들고 SQL 쿼리를 실행하여 MySQL 테이블에 데이터를 삽입합니다.
```
cursor = connection.cursor()
query = 'INSERT INTO table_name (column1, column2, column3) VALUES (%s, %s, %s)'
for row in df.itertuples():
cursor.execute(query, (row.column1, row.column2, row.column3))
connection.commit()
```

6. filename.xlsx, 사용자 이름, 비밀번호, 호스트, 데이터베이스, table_name, 컬럼1, 컬럼2, 컬럼3을 사용 사례에 적합한 값으로 바꿔야 합니다.

```
DOCKER_NAME="xlsmycon" ; DATABASE_NAME="medicare" ; TABLE_NAME="jaego" ; USER_NAME="hanuj"

sudo docker exec -it ${DOCKER_NAME} mysql -u root -p # <---- (1) Enter password: 가 나오면, GENERATED ROOT PASSWORD 를 여기에 붙여넣기 합니다.

alter user 'root'@'%' identified by '<>-<>-<>' ; -- '<>-<>-<>' 자리에 비번을 넣습니다.

grant all privileges on *.* to 'root'@'%' with grant option ;

create database if not exists ${DATABASE_NAME} character set utf8 ;

create user '${USER_NAME}'@'%' identified by '<>-<>-<>' ;
grant all privileges on *.* to '${USER_NAME}'@'%' with grant option ;

sudo docker exec -it ${DOCKER_NAME} /bin/bash ;
sudo docker restart ${DOCKER_NAME} ;
sudo docker ps -a ;
```

# 230902 토

1. 촛불집회전 시청광장 이재명지사 행진 (서울시의회 앞, 코리아나호텔+조선일보 옆)
![ 시청광장 집회참석 이재명지사 ](/ilji/2023-09/230902-시청광장-이재명대표.webp)
출처: 해민 핸폰

# 230901 금
1030 푸른숲

1. ss핸폰에서 푸른숲 와이파이 인식안됨.
1. 오픈 소스 원격 데스크톱이자 TeamViewer의 대안입니다. rustdesk.com https://github.com/rustdesk/rustdesk?ref=itsfoss.com
1. 모든 우분투 사용자가 알아야 할 13가지 키보드 단축키 - 키보드 단축키를 알면 생산성이 향상됩니다. 다음은 전문가처럼 Ubuntu를 사용하는 데 도움이 되는 몇 가지 유용한 Ubuntu 단축키입니다. 아비셰크 프라카시 2023년 8월 21일 https://itsfoss.com/ubuntu-shortcuts/?ref=foss-weekly-newsletter
1. VLC에서 자막을 사용하는 방법 - VLC 미디어 플레이어를 사용한 자막 재생 및 관리에 대한 초보자 가이드입니다. 사가르 샤르마 2023년 8월 21일 https://itsfoss.com/vlc-use-subtitles/?ref=foss-weekly-newsletter
1. 직무 인사이트 풀스택 소프트웨어 엔지니어가 되려면 어떻게 해야 할까요? 스와보미르 시비엥토니오프스키 2023년 6월 15일 https://hyperskill.org/blog/post/how-to-become-a-full-stack-software-engineer?utm_source=newsletter&utm_medium=email&utm_campaign=august_episode_1
1. Ktor 2023 Roadmap Hadi Hariri December 16, 2022 https://blog.jetbrains.com/ktor/2022/12/16/ktor-2023-roadmap/
1. Free From Google: Generative AI Learning Path https://www.kdnuggets.com/2023/07/free-google-generative-ai-learning-path.html?utm_source=newsletter&utm_medium=email&utm_campaign=august_episode_1
1. Telegram Conversation Summarizer Bot with ChatGPT and Flask (Quart) by Aliona Matveeva Apr 20, 2023 30 min read https://hyperskill.org/blog/post/telegram-conversation-summarizer-bot?utm_source=newsletter&utm_medium=email&utm_campaign=august_episode_1
1. AI Assistant in JetBrains IDEs Dmitry Jemerov June 26, 2023 https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/
1. AI의 헛소리 매튜 호이저 6분 읽기 4월 24일 https://mheusser.medium.com/the-bullshitization-of-ai-45c701dac4c
1. Top 15 AI Companies Hiring in 2023 – By Salary Range July 21st 2023 13min by @reclaimai https://hackernoon.com/top-15-ai-companies-hiring-in-2023-by-salary-range?utm_source=newsletter&utm_medium=email&utm_campaign=august_episode_1

┏━┳┓
┃╌┃┃🇰🇷
┣━╋┫
┗━┻┛

### `날짜 역순` 으로 `한달치만` 기록하고, 달이 바뀌면 다음과 같이 처리한다. 
1. Page Action --> Move/Rename --> Pages 에서 옮기려는 `2023-09 일지` 를 클릭 --> 아랫쪽 `[en v]`옆의 Path 에 `/ ilji/2309` 입력하고 --> `[v Select]` 클릭해서  파일 이름을 바꾼다. 
1. 다시 불러오기 `Ctrl + R` 하면 --> 윗작업의 결과로 `"/ home"` 파일이 `"/ ilji/2309"` 파일로 바뀌었기 때문에 `"/ home"` 파일이 없으므로 --> 나온 화면에서 `[+ CREATE HOME PAGE]` 를 누른 다음,
Title:
`2023-10 일지`
Short:
`작성중`
Path:
`/ home`
으로 지정해서 `"/ home"` 파일을 새로 만든다. 
1. HP ENVY-7640 printer 인쇄시 (레이아웃 `세로방향` / 설정 더보기 > 용지 크기 (`A4`) / 시트당 페이지 수 (`1`) / 여백 맞춤 > 상하 `10m/m`, 좌우 `5m/m` / 양면 `[v]`양면에 인쇄 / `[-]` 위로 넘김)

✨
✨

### Zoom 테스트
Zoom 테스트 미팅 https://support.zoom.us/hc/ko-kr/articles/115002262083-Zoom-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AF%B8%ED%8C%85-%EC%B0%B8%EC%97%AC%ED%95%98%EA%B8%B0

남양주평생학습포털다산서당
https://dasanedu.nyj.go.kr/home/myLectureList.do

1. 💗❤️💚🐾📌😊😃😝🤣🤗🌞🔥🍊🍓●➡️➜🔎📈🔽✅⌚⭐❱❱💡🔋🔉💸
💰🎁1️⃣2️⃣3️⃣🔗👈👉🔼🎨👀🚀🎯💰🔑⚡☕💬🎂✨🧩🛍️🚩🐈🐾🐱🐕
🐒🎗☢️️️️👹🌙🇰🇷🌳🚲🔵🚙🔱
📌 유니코드 상자그리기 기호 wepplication.github.io/tools/charMap/#unicode-2500-257F
📌 이모지 https://wepplication.github.io/tools/charMap/#emoji
📌 특수문자 이모티콘 모음 https://wepplication.github.io/tools/charMap/#specialChar

✨
✨

1. (2018-08 178.p) Kotlin Quick Start Guide By Marko Devcic $25.99 Publication ISBN 9781789344189 https://subscription.packtpub.com/book/programming/9781789344189/1
1. (2022-03 184.p) Kotlin 다중 플랫폼 모바일로 애플리케이션 개발 간소화 로베르트 나기 https://subscription.packtpub.com/book/programming/9781801812580/3
1. (2018-05 310.p) Spring 5 및 Kotlin으로 애플리케이션 구축
작업 환경 준비 https://subscription.packtpub.com/book/web-development/9781788394802/1/ch01lvl1sec05/preparing-the-working-environment
1. (2019-01 392.p) Android 애플리케이션 개발을 위한 Spring 배우기
(4) Android용 스프링 모듈 https://subscription.packtpub.com/book/programming/9781789349252/4
1. (2022-12 270.p) Spring Boot 3.0 학습 - 제3판 그렉 L. 턴키 스트 $35.99 ISBN 9781803233307 https://subscription.packtpub.com/book/web-development/9781803233307/2/ch02lvl1sec03/technical-requirements
1. Build RESTful APIs Using Kotlin and Spring Boot [Video] By Dilip Sundarraj $49.99 Video https://subscription.packtpub.com/video/web-development/9781804616451/p10/video10_6/integration-test-for-the-get-endpoint-to-retrieve-all-the-courses
1. Jetpack 및 Kotlin을 사용하여 최신 Android 개발을 시작하세요. https://subscription.packtpub.com/book/mobile/9781801811071/pref
1. Jetpack Compose를 사용한 Android UI 개발 https://subscription.packtpub.com/book/business-and-other/9781801812160/1
git clone https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose.git
1. LibreOffice Calc Guide 7.2 https://books.libreoffice.org/en/CG72/CG72.html

