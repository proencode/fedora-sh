
### 오늘의 링크

1. 젯브레인 2023학습채널 https://hyperskill.org/tracks/18

1. (2023-07 322p) 최신 Android 13 개발 요리책 Modern Android 13 Development Cookbook https://subscription.packtpub.com/book/mobile/9781803235578/pref

1. (2023-05 704p) Kotlin으로 Android 앱을 빌드하는 방법-제 2 판 How to Build Android Apps with Kotlin - Second Edition https://subscription.packtpub.com/book/mobile/9781837634934/pref

1. (2022-01 356p) Kotlin 디자인 패턴 및 모범 사례 - 제2판 https://subscription.packtpub.com/book/programming/9781801815727/2/ch02lvl1sec12/classes-and-inheritance

1. (2022-03 420.p) WordPress Plugin Development Cookbook https://subscription.packtpub.com/book/web-development/9781801810777/pref

1. (2023-01-01 522.p) PostgreSQL 15 마스터하기 - 제5판 https://subscription.packtpub.com/book/business-other/9781803248349/1


1. Run Linux on ESP32 - how to run the Linux kernel on an ESP32 Tam Hanna 구독자 2.39천명 조회수 3.2만회  9일 전 https://www.youtube.com/watch?v=5oKeVyxgwzk
1. 웹개발 이렇게 쉬웠나? 웹사이트 7분만에 개발하고 실전 배포하기 조코딩 JoCoding 구독자 55.2만명 조회수 35만회  1년 전  조코딩의 코딩 기초와 웹 프로그래밍 (2022) https://www.youtube.com/watch?v=4mRae9N2pU4
1. I fixed a C64 using a $20 OSCILLOSCOPE Sayaka's Digital Attic 구독자 3.08천명 조회수 3.4만회 https://www.youtube.com/watch?v=7kkzIV5yTPQ
1. 매일 이 주식을 사모으세요. 역대급 부자 될 기회를 절대 놓치지 마세요! (중국전문가 어반대 교수 안유화) 월급쟁이부자들TV 구독자 116만명 조회수 22만회  2주 전 https://www.youtube.com/watch?v=tdUKslC-HlM
1. 코딩 교육 끝판왕 등장?! 코딩쌤과 코린이를 위한 교재 추천! / 아두이노로 만드는 20가지 프로젝트 키트/파이썬과 마이크로비트로 배우는 실전 코딩 프로젝트 키트(+이벤트안내) 나도메이커 구독자 1.3만명 조회수 17회  51분 전 https://www.youtube.com/watch?v=5Qr7ymcFa38
1. Testing out the Milk-V Duo - The new $9 RISC-V eSBC that runs Linux!  Platima Tinkers 구독자 2.19천명 조회수 31,009회  2023. 9. 2. https://www.youtube.com/watch?v=YqUtGk0DHbQ&t=1231s
1. 맨눈으로 절대 못 보는 수소와 산소를 발견한 과학자들! 도대체 어떻게 발견했을까?  리뷰엉이: Owl's Review 구독자 151만명 조회수 612,208회  2022. 10. 15. https://www.youtube.com/watch?v=SoVV8KHpM3U
도서 '다정한 물리학'은 아래 링크로 구매할 수 있습니다.
교보문고 : https://bit.ly/3VoO5N8
예스24 : https://bit.ly/3CXjWgJ
알라딘 : https://bit.ly/3SZW6q1


# 230922 금
1020 진도

1. value_wikijs_file_test.sh 를 추가한다.
```
#!/bin/sh

BIN_VALUE="${HOME}/bin/value_wikijs"
#-- if [ -f "~/bin/qqq*" ];then echo "Found"; else echo "Not found"; fi
if [ ! -f "${BIN_VALUE}*.sh" ]; then
	#-- a.sh: 행 5번: [: /home/yosj/bin/value_wikijs-230922-120744-new.sh: 이항 연산자가 필요합니다 #-- 오류가 나므로, ${BIN_VALUE}*.sh 대신 "${BIN_VALUE}*.sh" 로 표기해야 함.
	#-- 최초에 지정해 주는 값.
	DOCKER_DIR=/home/docker #-- dwjs (2-1) 도커 디렉토리 홈
	DATABASE_NAME=wiki_postgres
	DB_user_NAME=iamwiki #-- dwjs (3-13) 데이터베이스 유저 이름
	NEW_MADE_FILE=${BIN_VALUE}-$(date +%y%m%d-%H%M%S)-first.sh
	cat >> ${NEW_MADE_FILE} <<__EOF__
#-- ${NEW_MADE_FILE} --
DOCKER_DIR=${DOCKER_DIR} #-- dwjs (2-1) 도커 디렉토리 홈
DATABASE_NAME=${DATABASE_NAME} #-- dwjs (3-4) 데이터베이스 이름
DB_user_NAME=${DB_user_NAME} #-- dwjs (3-13) 데이터베이스 유저 이름
__EOF__
	echo "(1) sleep 1.1 #-- 위 ${NEW_MADE_FILE} 파일은 임시이므로, 1.1초 지연후 LAST_MADE_FILE 파일 이름을 만든다."
	sleep 1.1
	#-- 첫 작업이므로 여기에서 선언할 것은 위에것 뿐이다.
else
	LAST_DEFINE_SH="$(ls -ltr ${BIN_VALUE}*.sh | tail -1 | awk '{print $9}')"
	echo "(3) LAST_DEFINE_SH [=${LAST_DEFINE_SH}]"
	$(sh ${LAST_DEFINE_SH}) #-- 여기서 선언을 해서 아래쪽에서 쓸수 있도록 한다.
fi

last_file=$(grep DOCKER_DIR ${BIN_VALUE}*.sh | awk -F"=" '{print $2}' | awk -F"#" '{print $1}' | sed -e 's/^ *//g' -e 's/ *$//g') #-- 앞뒤 공백 제거
echo "(4) last_file [=${last_file}]=\$(grep DOCKER_DIR ${BIN_VALUE}*.sh | awk -F\"=\" '{print \$2}' | awk -F\"#\" '{print \$1}' | sed -e 's/^ *//g' -e 's/ *$//g') #-- 앞뒤 공백 제거"
#-- perl 의 chomp 와 같이 문자열의 앞뒤에 있는 공백만 제거하려면, https://free-jonathan.tistory.com/9
#-- sed -e 's/^ *//g' -e 's/ *$//g'
LAST_DEFINE_SH=$(ls -ltr ${BIN_VALUE}*.sh | tail -1 | awk '{print $9}' | sed -e 's/^ *//g' -e 's/ *$//g') #-- ~/bin/value-*.sh 파일중 최근것.
echo "(5) LAST_DEFINE_SH [=${LAST_DEFINE_SH}]=\$(ls -ltr \${BIN_VALUE}*.sh | tail -1 | awk '{print \$9}' | sed -e 's/^ *//g' -e 's/ *$//g') #-- ~/bin/value-*.sh 파일중 최근것."
tempname=$(grep DOCKER_DIR ${LAST_DEFINE_SH} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}') #-- DOCKER_DIR 의 값을 꺼내서 rempname 에 담는다.
echo "(6) \${tempname} [=${tempname}]=\$(grep DOCKER_DIR \${LAST_DEFINE_SH} [=${LAST_DEFINE_SH}] | awk -F\"=\" '{print \$2}') #-- DOCKER_DIR 의 값을 꺼내서 rempname 에 담는다."

LAST_MADE_FILE=${BIN_VALUE}-$(date +%y%m%d-%H%M%S).sh
cat >> ${LAST_MADE_FILE} <<__EOF__
#-- ${LAST_MADE_FILE} --
DOCKER_DIR=${DOCKER_DIR} #-- dwjs (2-1) 도커 디렉토리 홈
DATABASE_NAME=${DATABASE_NAME} #-- dwjs (3-4) 데이터베이스 이름
DB_user_NAME=${DB_user_NAME} #-- dwjs (3-13) 데이터베이스 유저 이름
__EOF__
echo "(7) more ${BIN_VALUE}*.sh"
cnt=0
ls ${BIN_VALUE}*.sh | while read line
do
	cnt=$(( cnt + 1 ))
	echo "v v v v v v v v v v"
	echo "(8-$cnt) cat $line"
	cat $line
	echo "^ ^ ^ ^ ^ ^ ^ ^ ^ ^"
done
```

# 230921 목
0920 진도

1. 이재명 대표 두 번째 체포동의안 국회 통과… 앞으로 어떻게 되나
BBC news 코리아 230921 https://www.bbc.com/korean/articles/cxeg9zgv8dvo
21일 오후 서울 여의도 국회의사당에서 열린 본회의에서 이재명 민주당 대표 체포동의안 표결을 진행한 결과 재적의원 298명 중 295명이 참여해 찬성 149표, 반대 136표, 기권 6표, 무효 4표로 동의안이 가결됐다.
체포동의안이 통과되려면 출석의원 과반인 148명이 동의해야 하는 상황이었다.
서울중앙지방검찰청 반부패수사1부(엄희준 부장검사)는 18일 이 대표에 대해 특정경제범죄 가중처벌법상 배임과 특정범죄 가중처벌법상 뇌물, 위증교사, 외국환거래법 위반 혐의로 구속영장을 청구했다.
윤석열 대통령은 유엔 총회 참석차 방문 중인 미국에서 체포동의안을 재가한 것으로 알려졌다. 법무부는 19일 서울중앙지방법원 판사의 요구에 따라 국회에 체포동의 요청을 제출했다고 밝혔다.
1. 정준희의 해시티비 https://www.youtube.com/@j.hashtv/videos

# 230920 수
0940 진도

1. 이승엽통화 단체여행못함통보, 따로 가기로 함.

# 230919 화

1. 이발
1. 이승엽,김성식 통화 고구마쌀롱 litt.ly/gogumassalon 9/27한 여행패키지

# 230918 월

1. 슬리퍼 다이소장현 3,000
 
# Wiki.js 설치하기 - 짧은 버전

```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)
```

시스템 업데이트

```
sudo dnf -y update
echo "----> (1-1) --------------------"
```

## 1. 도커 설치

```
sudo dnf -y install dnf-plugins-core
echo "----> (1-2) --------------------"
sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__
[docker-ce-stable]
name=Docker CE Stable - \$basearch
baseurl=https://download.docker.com/linux/fedora/36/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://download.docker.com/linux/fedora/gpg
__EOF__
echo "----> (1-3) --------------------"
sudo dnf makecache
sudo dnf -y install docker-ce docker-ce-cli containerd.io
sudo systemctl enable --now docker
echo "----> (1-4) --------------------"
sudo systemctl status docker
sudo docker version
echo "----> (1-5) --------------------"
sudo dnf -y install docker-compose
rpm -qi docker-compose
sudo docker ps -a
echo "----> (1-6) --------------------"



DOCKER_DIR=/home/docker #-- dwjs (2-1) 도커 디렉토리 홈
```

## 2. 데이터베이스가 사용하는 디렉토리를 만든다.

```
```







# Wiki.js 설치하기 - 긴 버전

출처: https://computingforgeeks.com/how-to-install-docker-on-fedora/

1. 표시하는 문자에 색깔을 지정하고, 복사/붙여넣기 한 스크립트를 실행할때, 위아래 사이를 구분해 주는 칸 띄우기 문장.
```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)

for i in {0..9}; do echo "#"; done
```
| lll | 검정 b'L'ack | rrr | 빨강 Red | ggg | 녹색 Green | yyy | 노랑 Yellow | bbb | 파랑 Blue |
|:---|---:|:---:|:---:|:---:|:---:|:---:|---|:---:|:---:|
|:---|---:|:---:|:---:|:---:|:---:|:---:|---|:---:|:---:|
| mmm | 보라 Magenta | ccc | 청록 Cyan | www | 흰색 White | xxx | 색 표시 끝냄 | uuu | 윗쪽으로 Up |
|  | -- LEFT SIDE -- |  | RIGHT SIDE |  | -- CENTER -- |  | NO MARKING |  |  |

```
| lll | 검정 b'L'ack | rrr | 빨강 Red | ggg | 녹색 Green | yyy | 노랑 Yellow | bbb | 파랑 Blue |
|:---|---:|:---:|:---:|:---:|:---:|:---:|---|:---:|:---:|
|:---|---:|:---:|:---:|:---:|:---:|:---:|---|:---:|:---:|
| mmm | 보라 Magenta | ccc | 청록 Cyan | www | 흰색 White | xxx | 색 표시 끝냄 | uuu | 윗쪽으로 Up |
|  | -- LEFT SIDE -- |  | RIGHT SIDE |  | -- CENTER -- |  | NO MARKING |  |  |
```

## 1. 도커 프로그램 설치

1. 📌 이모지 https://wepplication.github.io/tools/charMap/#emoji
1. 시스템을 최신버전으로 유지하기 위해 다음을 실행한다.
```
echo "## 1. 도커 프로그램 설치"
echo "##----------------------"
sudo dnf -y update
echo "🎶 (1-1) 시스템을 최신버전으로 유지하기 위해 다음을 실행한다."
```

2. 시스템 명령어인 dnf 의 플러그인 코어를 받는다.
```
for i in {0..3}; do echo "#"; done

sudo dnf -y install dnf-plugins-core
echo "🎶 (1-2) 시스템 명령어인 dnf 의 플러그인 코어를 받는다."
```

3. 지금 받으려는 docker-ce 가 있는 위치를 리파지토리에 기록한다.
```
for i in {0..3}; do echo "#"; done

sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__
[docker-ce-stable]
name=Docker CE Stable - \$basearch
baseurl=https://download.docker.com/linux/fedora/36/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://download.docker.com/linux/fedora/gpg
__EOF__
echo "🎶 (1-3) 지금 받으려는 docker-ce 가 있는 위치를 리파지토리에 기록한다."
```

4. docker-ce 를 받는다.
```
for i in {0..3}; do echo "#"; done

sudo dnf makecache
sudo dnf -y install docker-ce docker-ce-cli containerd.io
sudo systemctl enable --now docker
echo "🎶 (1-4) docker-ce 를 받는다."
```

5. Docker 설치 확인
줄의 끝에 lines 1-24/24 (END) 가 나오면, 'Q' 를 눌러서 끝내야 한다.
```
for i in {0..3}; do echo "#"; done

sudo systemctl status docker
sudo docker version
echo "🎶 (1-5) Docker 설치 확인"
```

6. docker-compose 를 설치한다.
```
for i in {0..3}; do echo "#"; done

sudo dnf -y install docker-compose
rpm -qi docker-compose
sudo docker ps -a
echo "🎶 (1-6) docker-compose 를 설치한다."
```

## 2. 필요한 디렉토리 작성

```
for i in {0..3}; do echo "#"; done

echo "## 2. 필요한 디렉토리 작성"
echo "##------------------------"

last_file="$(ls -ltr ~/bin/wikijs_name_define-*.txt | tail -1 | awk '{print $9}')"

tempname=$(grep DOCKER_DIR ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="/home/docker"
fi
echo "🖍️ (2-1) 도커 디렉토리 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DOCKER_DIR="${tempname}"
echo "(2-2) 도커 디렉토리 = ${DOCKER_DIR}"

tempname=$(grep YML_DIR ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wikijs_yml"
fi
echo "🖍️ (2-3) docker-compose.yml 을 보관하는 ${DOCKER_DIR} 아래의 디렉토리 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
YML_DIR="${DOCKER_DIR}/${tempname}" #-- dwjs (2-4) docker-compose.yml 을 보관하는 ${DOCKER_DIR} 아래의 디렉토리
if [ -d ${YML_DIR} ]; then
    echo "(2-4) ${YML_DIR} 디렉토리가 있으므로, 내용을 확인해봐서 쓰지 않는 것이면, 이 디렉토리를 지우고 다시 만들어야 합니다."
    echo "      sudo rm -rf ${YML_DIR} ; sudo mkdir -p ${YML_DIR}"
else
    echo "(2-5) sudo mkdir -p ${YML_DIR}"
    sudo mkdir -p ${YML_DIR}
fi
echo "(2-6) sudo ls -alR ${YML_DIR}"
sudo ls -alR ${YML_DIR}
echo "(2-7) docker-compose.yml 을 보관하는 디렉토리 = ${YML_DIR}"

tempname=$(grep YML_NAME ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="docker-compose.yml"
fi
echo "🖍️ (2-8) docker-compose.yml 이름을 지정 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
YML_NAME="${YML_DIR}/${tempname}" #-- dwjs (2-9) docker-compose.yml 이름을 지정
echo "🎶 (2-9) docker-compose.yml 이름을 지정 = ${YML_NAME}"
```

## 3. 데이터베이스 서비스

```
last_file="$(ls -ltr ~/bin/wikijs_name_define-*.txt | tail -1 | awk '{print $9}')"

tempname=$(grep DATABASE_SERVICE ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="db_srv"
fi
echo "🖍️ (3-1) 데이터베이스 서비스 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DATABASE_SERVICE="${tempname}" #-- dwjs (3-2) 데이터베이스 서비스 이름
echo "(3-2) 데이터베이스 서비스 이름 = ${DATABASE_SERVICE}"

tempname=$(grep DATABASE_NAME ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wikidb"
fi
echo "🖍️ (3-3) 데이터베이스 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DATABASE_NAME="${tempname}" #-- dwjs (3-4) 데이터베이스 이름
echo "(3-4) 데이터베이스 이름 = ${DATABASE_NAME}"

tempname=$(grep DATABASE_DIR ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wikijs_data"
fi
echo "🖍️ (3-5) wiki 데이터베이스 보관 디렉토리 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DATABASE_DIR="${DOCKER_DIR}/${tempname}" #-- dwjs (3-5) wiki 데이터베이스 보관 디렉토리
if [ -d ${DATABASE_DIR} ]; then
    echo "(3-6) ${DATABASE_DIR} 디렉토리가 있으므로, 내용을 확인해봐서 쓰지 않는 것이면, 이 디렉토리를 지우고 다시 만들어야 합니다."
    echo "      sudo rm -rf ${DATABASE_DIR} ; sudo mkdir -p ${DATABASE_DIR}"
else
    echo "(3-7) sudo mkdir -p ${DATABASE_DIR}"
    sudo mkdir -p ${DATABASE_DIR}
fi
echo "(3-8) sudo ls -alR ${DATABASE_DIR}"
sudo ls -alR ${DATABASE_DIR}
echo "(3-9) wiki 데이터베이스 보관 디렉토리 = ${DATABASE_DIR}"

tempname=$(grep DATABASE_CONTAINER ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="pgwikic"
fi
echo "🖍️ (3-10) 데이터베이스 컨테이너 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DATABASE_CONTAINER="${tempname}" #-- dwjs (3-11) 데이터베이스 컨테이너 이름
echo "(3-11) 데이터베이스 컨테이너 이름 = ${DATABASE_CONTAINER}"

tempname=$(grep DB_user_NAME ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="imwiki"
fi
echo "🖍️ (3-12) 데이터베이스 유저 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DB_user_NAME="${tempname}" #-- dwjs (3-13) 데이터베이스 유저 이름
echo "(3-13) 데이터베이스 유저 이름 = ${DB_user_NAME}"

tempname=$(grep DB_user_PASS ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wikipswd"
fi
echo "🖍️ (3-14) 데이터베이스 유저 비번 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DB_user_PASS="${tempname}" #-- dwjs (3-15) 데이터베이스 유저 비번
echo "🎶 (3-15) 데이터베이스 유저 비번 = ${DB_user_PASS}"
```

## 4. 위키 서비스

```
last_file="$(ls -ltr ~/bin/wikijs_name_define-*.txt | tail -1 | awk '{print $9}')"

tempname=$(grep WIKI_SERVICE ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wiki_srv"
fi
echo "🖍️ (4-1) 위키 서비스 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
WIKI_SERVICE="${tempname}" #-- dwjs (4-2) 위키 서비스 이름
echo "(4-2) 위키 서비스 이름 = ${WIKI_SERVICE}"

tempname=$(grep WIKI_PORT_NO ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="7700"
fi
echo "🖍️ (4-3) 위키 포트 번호 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
WIKI_PORT_NO="${tempname}" #-- dwjs (4-4) 위키 포트 번호
echo "(4-4) 위키 포트 번호 = ${WIKI_PORT_NO}"

tempname=$(grep WIKI_CONTAINER ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wikijsc"
fi
echo "🖍️ (4-5) 위키 컨테이너 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    WIKI_CONTAINER=${a}
fi
WIKI_CONTAINER="${tempname}" #-- dwjs (4-6) 위키 컨테이너"
echo "(4-6) 위키 컨테이너 = ${WIKI_CONTAINER}"

tempname=$(grep CLOUD_NAME ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="tp3mi" #-- rclone 백업용 클라우드 이름
fi
echo "🖍️ (4-7) rclone 백업용 클라우드 이름 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
CLOUD_NAME="${tempname}" #-- dwjs (4-8) rclone 백업용 클라우드 이름
echo "(4-8) rclone 백업용 클라우드 이름 = ${CLOUD_NAME}"

cat > ${YML_NAME} <<__EOF__
version: "3"
services:
  ${DATABASE_SERVICE}:
    image: postgres:11-alpine
    environment:
      POSTGRES_USER: ${DB_user_NAME}
      POSTGRES_PASSWORD: ${DB_user_PASS}
      POSTGRES_DB: ${DATABASE_NAME}
    logging:
      driver: "none"
    restart: unless-stopped
    volumes:
      - ${DATABASE_DIR}:/var/lib/postgresql/data
    container_name:
      ${DATABASE_CONTAINER}

  ${WIKI_SERVICE}:
    image: requarks/wiki:2
    depends_on:
      - ${DATABASE_SERVICE}
    environment:
      DB_TYPE: postgres
      DB_HOST: ${DATABASE_SERVICE}
      DB_PORT: 5432
      DB_USER: ${DB_user_NAME}
      DB_PASS: ${DB_user_PASS}
      DB_NAME: ${DATABASE_NAME}
    restart: unless-stopped
    ports:
      - "${WIKI_PORT_NO}:3000"
    container_name:
      ${WIKI_CONTAINER}
__EOF__

echo "(4-9) ls -lR ${YML_NAME}"
ls -lR ${YML_NAME}
echo "(4-10) cat ${YML_NAME}"
cat ${YML_NAME}

if [ ! -d ~/bin ]; then
    mkdir ~/bin
fi
NAME_DEFINE_FILE=~/bin/wikijs_name_define-$(date +%y%m%d-%H%M%S).txt #-- bash 변수를 저장한다.
cat > ${NAME_DEFINE_FILE} <<__EOF__
DOCKER_DIR=${DOCKER_DIR} #-- dwjs (2-1) 도커 디렉토리 홈
DATABASE_DIR=${DATABASE_DIR} #-- (2-2) dwjs wiki 데이터베이스 보관 디렉토리
YML_DIR=${YML_DIR} #-- dwjs (2-3) docker-compose.yml 을 보관하는 ${DOCKER_DIR} 아래의 디렉토리
YML_NAME=${YML_NAME} #-- dwjs (2-9) docker-compose.yml 이름을 지정
DATABASE_SERVICE=${DATABASE_SERVICE} #-- dwjs (3-2) 데이터베이스 서비스 이름
DATABASE_NAME=${DATABASE_NAME} #-- dwjs (3-4) 데이터베이스 이름
DATABASE_DIR=${DATABASE_DIR} #-- dwjs (3-5) wiki 데이터베이스 보관 디렉토리
DATABASE_CONTAINER=${DATABASE_CONTAINER} #-- dwjs (3-11) 데이터베이스 컨테이너 이름
DB_user_NAME=${DB_user_NAME} #-- dwjs (3-13) 데이터베이스 유저 이름
DB_user_PASS=${DB_user_PASS} #-- dwjs (3-15) 데이터베이스 유저 비번
WIKI_SERVICE=${WIKI_SERVICE} #-- dwjs (4-2) 위키 서비스 이름
WIKI_PORT_NO=${WIKI_PORT_NO} #-- dwjs (4-4) 위키 포트 번호
WIKI_CONTAINER=${WIKI_CONTAINER} #-- dwjs (4-6) 위키 컨테이너
CLOUD_NAME=${CLOUD_NAME} #-- dwjs (4-8) rclone 백업용 클라우드 이름
__EOF__
echo "(4-11) cat ${NAME_DEFINE_FILE}"
$(cat ${NAME_DEFINE_FILE})
echo "🎶 (4-12) --------------------"
```

## 5. 도커 컴포즈 빌드 + 실행

```
for i in {0..9}; do echo "#"; done

echo "(5-1) ls -l ~/bin/wikijs_name_define-*.txt"
ls -l ~/bin/wikijs_name_define-*.txt

last_file="$(ls -ltr ~/bin/wikijs_name_define-*.txt | tail -1 | awk '{print $9}')"

tempname=$(grep YML_DIR ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="wikijs_yml"
fi
echo "🖍️ (5-2) docker-compose.yml 을 보관하는 ${DOCKER_DIR} 아래의 디렉토리 : [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
YML_DIR="${DOCKER_DIR}/${tempname}" #-- dwjs (5-2) docker-compose.yml 을 보관하는 ${DOCKER_DIR} 아래의 디렉토리

echo "(5-3) cd ${YML_DIR} #-- docker-compose.yml 보관 디렉토리"
cd ${YML_DIR}
echo "(5-4) sudo dnf -y install docker-compose (설치)"
sudo dnf -y install docker-compose
echo "(5-5) rpm -qi docker-compose (내역)"
rpm -qi docker-compose
echo "(5-6) sudo docker ps -a"
sudo docker ps -a
echo "(5-7) sudo docker-compose pull wiki_srv (빌드)"
sudo docker-compose pull wiki_srv
### ### sudo docker-compose up --build 를 쓰지 않음 ###

cat <<__EOF__
...
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 🔻🔻🔻🔻🔻🔻🔻🔻🔻🔻
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: Browse to http://YOUR-SERVER-IP:3000/ to complete setup!
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 🔻🔻🔻🔻🔻🔻🔻🔻🔻🔻


위와 같은 메세지가 표시되면,

(1) ----> 아래의 명령을 --- 직접 --- 입력해서,

sudo docker ps -a

도커 실행내역을 확인합니다.

(2) ----> 브라우저에서 --- 아래의 주소를 입력해서,

localhost:${WIKI_PORT_NO}

wiki.js 를 실행해서 --- 관리자 등록과 첫 홈페이지를 만듭니다.

🖍️ (5-8) press Enter:
__EOF__
read a

echo "(5-9) sudo docker-compose up --force-recreate & (빌드한 도커 컴포즈를 실행합니다)"
sudo docker-compose up --force-recreate &
echo "(5-10) sudo docker-compose ps -a"
sudo docker-compose ps -a
echo "🎶 (5-11) --------------------"
```

# 데이터 백업과 리스토어

## 6. 단순백업 보관하기

```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)
for i in {0..9}; do echo "#"; done

last_file="$(ls -ltr ~/bin/wikijs_name_define-*.txt | tail -1 | awk '{print $9}')"

echo "(6-1) grep DATABASE_CONTAINER ~/bin/wikijs_name_define-*.txt ---> last_file = ${last_file}"
grep DATABASE_CONTAINER ~/bin/wikijs_name_define-*.txt
echo "$(grep DATABASE_CONTAINER ${last_file}) <----"
tempname=$(grep DATABASE_CONTAINER ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="pgwikic"
fi
echo "🖍️ (6-2) 데이터베이스 컨테이너 이름: [ 그냥 엔터 = ${tempname} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DATABASE_CONTAINER=${tempname}
echo "🎶 (6-3) 데이터베이스 컨테이너 = ${DATABASE_CONTAINER}"

echo "(6-4) grep DB_user_NAME ~/bin/wikijs_name_define-*.txt ---> last_file = ${last_file}"
grep DB_user_NAME ~/bin/wikijs_name_define-*.txt
echo "$(grep DB_user_NAME ${last_file}) <----"
tempname=$(grep DB_user_NAME ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="imwiki"
fi
echo "🖍️ (6-5) 데이터베이스 유저 이름: [ 그냥 엔터 = ${DB_user_NAME} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
DB_user_NAME=${tempname}
echo "🎶 (6-6) 데이터베이스 유저 이름 = ${DB_user_NAME}"

this_y4m2=$(date +%Y)-$(date +%m) #- 2022-08 과 같이 만든다.
LOCAL_Y2M2=/home/backup/${DATABASE_CONTAINER}/${this_y4m2}
if [ ! -d ${LOCAL_Y2M2} ]; then
    echo "(6-7) ${LOCAL_Y2M2} 로컬 디렉토리를 만듭니다."
    mkdir -p ${LOCAL_Y2M2}
fi

echo "(6-8) grep CLOUD_NAME ~/bin/wikijs_name_define-*.txt ---> last_file = ${last_file}"
grep CLOUD_NAME ~/bin/wikijs_name_define-*.txt
echo "$(grep CLOUD_NAME ${last_file}) <----"
tempname=$(grep CLOUD_NAME ${last_file} | awk -F"=" '{print $2}' | awk -F"#" '{print $1}')
if [ "x${tempname}" = "x" ]; then
    tempname="tp3mi" #-- rclone 백업용 클라우드 이름
fi
echo "🖍️ (6-9) rclone 백업용 클라우드 이름: [ 그냥 엔터 = ${CLOUD_NAME} ]"
read a
if [ "x${a}" != "x" ]; then
    tempname=${a}
fi
CLOUD_NAME=${tempname}
echo "(6-10) rclone lsf ${CLOUD_NAME}"
rclone lsf ${CLOUD_NAME}
echo "🖍️ (6-11) press Enter:"
read a







if [ "x${CLOUD_NAME} = "x" ]; then
    echo "(5-7) 클라우드 이름이 없어서 중단합니다."
else
    CLOUD_Y2M2=${DATABASE_CONTAINER}/${this_y4m2}
    echo "(5-8) 위키 도커를 중단합니다."
    echo "sudo docker ps -a ; sudo docker stop ${DATABASE_CONTAINER}"
    sudo docker ps -a ; sudo docker stop ${DATABASE_CONTAINER}

    ymd_hm=$(date +"%y%m%d%a-%H%M")
    current_backup=${DATABASE_NAME}_${ymd_hm}_$(uname -n).sql.7z #- 압축파일 이름
    cat <<__EOF__
#-
#- DB 백업
#-
#- (5-9) wili.js 데이터베이스를 백업하기 위해서 아래에 ---비밀번호--- 를 입력하세요.
#-
__EOF__
echo "🎶 (6-6) 데이터베이스 유저 이름 = ${CLOUD_NAME}"
    echo "(5-10) 오늘 요일이름의 로컬 보관장소에 백업합니다."
    echo "sudo docker exec ${DATABASE_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -si ${LOCAL_Y2M2}/${current_backup} -p"
    sudo docker exec ${DATABASE_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -si ${LOCAL_Y2M2}/${current_backup} -p
    echo "(5-11) 보관용 로컬 폴더입니다."
    echo "ls -lR ${LOCAL_Y2M2}"
    ls -lR ${LOCAL_Y2M2}
    # echo "#-- (5-12) 오늘 요일이름의 파일을 클라우드로 복사합니다."
    # echo "#-- sudo /usr/bin/rclone copy ${LOCAL_Y2M2}/${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/"
    # sudo /usr/bin/rclone copy ${LOCAL_Y2M2}/${DB_sql7z} ${CLOUD_NAME}:${CLOUD_Y2M2}/
    # echo "#-- (5-13) 클라우드 폴더입니다."
    # echo "#-- /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}"
    # /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
    echo "(5-14) 위키 도커를 다시 시작합니다."
    echo "sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a"
    sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
fi
echo "🎶 (5-15) --------------------"
```
## 6. 백업파일을 DB 에 도로담기

1. 구글 클라우드로 백업했던 wiki.js db 파일을 로컬 폴더로 복사한다.
1. 복사한 db 파일 이름 을 다음과 같이 스크립트를 사용해서 wiki.js 에 올린다.
1. 리스토어 하기 전에, 현재의 데이터베이스를 저장할 것인지 물어서, 답에 따라 현재 db 를 만들어 놓고 나서 리스토어한다

`백업 backup`: 현재의 데이터베이스를 **wikipg-220907수-1802-proenpi4b.sql.7z** 와 같은 이름으로 압축해서 저장한다.
`리스토어 restore`: 압축해서 보관했던 백업 파일을 데이터베이스에 도로 부어 담는다.
`현재 상태의 마지막 백업`: 백업파일을 리스토어 하는 경우, 현재의 db 에 들어있던 데이터는 백업파일에 의해 지워진다. 그래서 일단 현재상태의 db 를 **" last-\${DB_CONTAINER}-\$(date +%y%m%d_%H%M%S)-\$(uname -n).sql.7z "** 등으로 백업하고서 리스토어 하기 위해서 마지막 백업을 실시한다.

```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

#--> 로컬과 원격 보관장소
this_y4m2=$(date +%Y)-$(date +%m) #- 2022-08
LOCAL_Y2M2=${LOCAL_FOLDER}/${this_y4m2}
if [ ! -d ${LOCAL_Y2M2} ]; then
    echo "#-- (9-1) ${LOCAL_Y2M2} 로컬 디렉토리를 만듭니다."
    mkdir -p ${LOCAL_Y2M2}
fi
CLOUD_Y2M2=${CLOUD_FOLDER}/${this_y4m2}
#<-- 로컬과 원격 보관장소

echo "#-- 복구하려는 백업 파일 이름 zzz = ${zzz}"

#-- ----> 리스토어 파일이 있으면 현재의 DB 를 백업하고 리스토어 한다.
if [ "x${zzz}" = "x" ] || [ ! -f "${zzz}" ]; then
    #-- ----> 리스토어 파일이 없으면 여기서 끝냄.
    cat <<__EOF__
#-- (9-2) ls -lR ${LOCAL_FOLDER} #--- 백업 디렉토리 내용
$(ls -lR ${LOCAL_FOLDER})
#--
#-- (9-3) 지정한 (리스토어 할) ${zzz} 파일이 존재하지 않습니다.
#--
#-- 리스토어 할 파일 이름이 " /home/backup/wikipg/2023-09 " 디렉토리에 있는 " last-${DB_CONTAINER}-230908금-1431-vFedora38.sql.7z " 인 경우:
#-- 
#-- zzz="/home/backup/wikipg/2023-09/last-${DB_CONTAINER}-230908금-1431-vFedora38.sql.7z"
#--
#-- (복구하려는 파일 이름을 담은 변수의 이름이 zzz 임.)
#--
#-- 이와 같이 Bash Terminal 에서 선언하고 나서, 이 스크립트를 실행해야 합니다.
#-- 
#-- (9-4) ${zzz} 파일이 없으므로 작업을 중단합니다.
__EOF__
    #-- <---- 리스토어 파일이 없으면 여기서 끝냄.
else
    #-- ----> 리스토어 할 .7z 파일이 있다.
    sql_name=$(basename ${zzz}) # 백업파일 이름만 꺼냄
    sql_dir=${zzz%/$sql_name} # 백업파일 이름을 빼고 나머지 디렉토리만 담음
    cat <<__EOF__
zzz = "${zzz}"
sql_name = ${sql_name} # 백업파일 이름만 꺼냄
sql_dir = ${sql_dir} # 백업파일 이름을 빼고 나머지 디렉토리만 담음

🖍️ (9-5) 현재의 DB 를 백업하지 않으려면, 소문자 'n' 을 눌러 주세요."
__EOF__
    read n_is_no_backup ; echo "${uuu}"
    echo "[ ${n_is_no_backup} ]"
    if [ "x$n_is_no_backup" = 'xn' ]; then
        #-- ----> 현재의 DB 를 백업하지 않는다 선택.
        cat <<__EOF__
# |
# |
# |
# |
# |
# | !!!! 주의 !!!! 현재 DB 를 다운로드 + 백업하지 않고, 업로드 합니다.
# |
# | 여기서 소문자 'y' 를 누르면 현재의 DB 백업을 하지 않습니다.
# |
# | 다른 글자거나 그냥 Enter 를 누르면 백업이 진행됩니다.
# |
🖍️ 백업 하지 않고 = 'y' Enter:
__EOF__
        read y_is_No_Backup ; echo "${uuu}"
        echo "[ ${y_is_No_Backup} ]"
        #-- --> '백업 받기 전' 위키 컨테이너 정지
        cat <<__EOF__
#-- (9-6) 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
        sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
        #-- <-- '백업 받기 전' 위키 컨테이너 정지
        if [ "x$y_is_No_Backup" != 'xy' ]; then
            #-- ----> 현재 DB 를 다운로드 + 백업 합니다.
            current_backup="${LOCAL_Y2M2}/last-${DB_CONTAINER}-$(date +%y%m%d_%H%M%S)-$(uname -n).sql.7z"
            cat <<__EOF__
#-- (9-7) 지정한 백업파일을 데이터베이스에 붓기 전에,
#-- 현재 운영중인 DB 를 먼저 ${LOCAL_Y2M2} 에 백업합니다.
#--
#-- 백업받은 .7z 파일에 지정해 줄 ${mmm}새로운 비밀번호를 입력하세요.
#-- sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -mx=9 -p -si ${current_backup}
__EOF__
            sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -mx=9 -p -si ${current_backup}
            cat <<__EOF__
#-- (9-8) 오늘 요일이름의 파일을 클라우드로 복사합니다.
#-- sudo /usr/bin/rclone copy ${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/
__EOF__
            sudo /usr/bin/rclone copy ${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/
            cat <<__EOF__
#-- (9-9) 클라우드 폴더입니다.
#-- /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
__EOF__
            /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
            #-- <---- 현재 DB 를 다운로드 + 백업 합니다.
        fi
        #-- <---- 현재의 DB 를 last_backup 으로 백업하지 않는다 선택.
    else
        #-- ----> 현재의 DB 를 last_backup 으로 백업한다 선택.
        #-- --> 위키 컨테이너 정지
        cat <<__EOF__
#-- (9-10) 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
        sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
        #-- <-- 위키 컨테이너 정지
        #-- <---- 현재의 DB 를 last_backup 으로 백업한다 선택.
    fi
    cat <<__EOF__
#-- (9-11) 기존의 데이터베이스를 삭제합니다.
#-- sudo docker exec -it ${DB_CONTAINER} dropdb -U ${DB_USER} ${DB_NAME}
__EOF__
    sudo docker exec -it ${DB_CONTAINER} dropdb -U ${DB_USER} ${DB_NAME}
cat <<__EOF__
#-- (9-12) 빈 데이터베이스를 새로 만듭니다.
#-- sudo docker exec -it ${DB_CONTAINER} createdb -U ${DB_USER} ${DB_NAME}
__EOF__
    sudo docker exec -it ${DB_CONTAINER} createdb -U ${DB_USER} ${DB_NAME}
    cat <<__EOF__
#-- (9-13) 지정한 백업파일을 데이터베이스에 다시 붓습니다. (RESTORE)
#-- 백업할때 입력한 ${mmm}비밀번호를 입력하세요.
#-- time 7za x -so ${zzz} | sudo docker exec -i ${DB_CONTAINER} psql -U ${DB_USER} ${DB_NAME}
__EOF__
    time 7za x -so ${zzz} | sudo docker exec -i ${DB_CONTAINER} psql -U ${DB_USER} ${DB_NAME}
    cat <<__EOF__
#-- (9-14) 멈췄던 위키 컨테이너를 다시 시작합니다.
#-- sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
    sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
    echo "#-- (9-15) 백업 작업이 끝났습니다."
    #-- <---- 리스토어 할 .7z 파일이 있다.
fi
zzz=""
#-- <---- 리스토어 파일이 있으면 현재의 DB 를 백업하고 리스토어 한다.
```

# 230917 일

진접도서관 희망도서 신청

| # | 제목 | 신청일 |
|:---:|:----:|:----:|
| 28 | 디케의 눈물 | 2023.09.17 신청중 신청취소 |
| 27 | 어쩌다 보니 지구 반대편 | 2023.07.15 소장중 |
| 26 | 시민주권 시대의 정치경제론 | 2023.06.19 소장중 |
| 25 | 일본 관찰 30년 | 2023.06.18 소장중 |
| 24 | 과학샘의 그라운딩, 자연에서 춤추다 | 2023.03.04 소장중 |
| 23 | 정세현의 통찰 | 2023.02.13 소장중 |
| 22 | 조국의 법고전 산책 | 2022.11.08 소장중 |
| 21 | 분노가 세상을 바꾼다 | 2022.10.17 소장중 |
| 20 | 과학드림의 이상하게 빠져드는 과학책 | 2022.05.15 소장중 |
| 19 | 유대인의 하루는 저녁 6시에 시작된다 | 2022.03.25 소장중 |
| 18 | 대전환의 시대, 새로운 대한민국이 온다 | 2022.03.04 소장중 |
| 17 | 그리드 (기후 위기 시대, 제2의 전기 인프라 혁명이 온다) | 2021.07.04 취소됨 |
| 16 | 조국의 시간 | 진접푸른숲도서관신청일 | 2021.05.30 소장중 |
| 15 | 선천적 수포자를 위한 수학 2 | 고등편 | 2021.04.28 소장중 |
| 14 | 물리학과 대승기신론 | 2021.04.25 취소됨 |
| 13 | 비극의 탄생 (50인의 증언으로 새롭게 밝히는 박원순 사건의 진상) | 2021.03.15 소장중 |
| 12 | 쟁점 한국사 (현대편) | 2020.12.24 처리중 |
| 11 | 쟁점 한국사 (전근대편) | 2020.12.24 처리중 |
| 10 | K-컬처 in 쿠바 (쿠바에서 한류를 찾다) | 2020.12.21 처리중 |
| 9 | 영양치료 (만성병 난치병) | 2020.12.21 취소됨 |
| 8 | 생명경제로의 전환 (유럽 최고 석학 자크 아탈리) | 2020.12.13 처리중 |
| 7 | AngularJS 활용편 (2권중 2번째책) | 2014.06.04 취소됨 |
| 6 | AngularJS 기초편 | 2014.06.04 취소됨 |
| 5 | AngularJS 기초편 | 2014.06.04 취소됨 |
| 4 | 트위터 부트스트랩 | 2014.03.11 취소됨 |
| 3 | 강소기업 성장통을 넘다 | 2014.03.07 취소됨 |
| 2 | 나홀로 개발자를 위한 안드로이드 게임 프로그래밍 | 2013.12.27 취소됨 |
| 1 | 유니티로 만드는 게임 개발 총론 | 2013.12.27 취소됨 |

# 230916 토
1230 진도

1. 60x40 접는책상 왕도매 37,000 원, 다이소 5,000 원 , 홈플러스다이소 5,000 원

# MySQL 을 도커로 설치하기

출처: Docker로 MySQL 설치 (docker-compose.yml) Docker 2022. 9. 11. 14:53 https://tychejin.tistory.com/393

## 1. 도커 설치하기

출처: https://computingforgeeks.com/how-to-install-docker-on-fedora/

10. 표시하는 문자에 색깔을 지정하고, 복사/붙여넣기 한 스크립트를 실행할때, 위아래 사이를 구분해 주는 칸 띄우기 문장.
```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)

for i in {0..9}; do echo "#"; done
```

11. 시스템을 최신버전으로 유지하기 위해 다음을 실행한다.
```
sudo dnf -y update
```

12. 시스템 명령어인 dnf 의 플러그인 코어를 받는다.
```
sudo dnf -y install dnf-plugins-core
echo "----> (12-1) --------------------"
```

13. 지금 받으려는 docker-ce 가 있는 위치를 리파지토리에 기록한다.
```
for i in {0..3}; do echo "#"; done

sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__
[docker-ce-stable]
name=Docker CE Stable - \$basearch
baseurl=https://download.docker.com/linux/fedora/36/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://download.docker.com/linux/fedora/gpg
__EOF__
echo "----> (13-1) --------------------"
```

14. docker-ce 를 받는다.
```
sudo dnf makecache
sudo dnf -y install docker-ce docker-ce-cli containerd.io
sudo systemctl enable --now docker
echo "----> (14-1) --------------------"
```

15. Docker 설치 확인
줄의 끝에 lines 1-24/24 (END) 가 나오면, 'Q' 를 눌러서 끝내야 한다.
```
sudo systemctl status docker
sudo docker version
echo "----> (15-1) --------------------"
```

16.  docker-compose 를 설치한다.
```
sudo dnf -y install docker-compose
rpm -qi docker-compose
sudo docker ps -a
echo "----> (16-1) --------------------"
```

## 2. 보관하는 디렉토리 만들기

21. 데이터베이스가 사용할 디렉토리를 만든다.
```
for i in {0..3}; do echo "#"; done

if [ -d /home/docker/logidb ]; then
    sudo ls -alR /home/docker/logidb
    echo "----> (21-1) 디렉토리가 있으므로, 내용을 확인하고, sudo rm -rf /home/docker/mysqldb 명령으로 삭제해야 합니다."
else
    sudo mkdir -p /home/docker/logidb
    sudo ls -alR /home/docker/logidb
    echo "----> (21-2) 디렉토리를 만들었습니다."
fi
echo "----> (21-3) --------------------"
```

22. docker-compose.yml 을 보관하는 디렉토리를 만든다.
```
for i in {0..3}; do echo "#"; done

if [ -d /home/docker/logidb_conf ]; then
    sudo ls -alR /home/docker/logidb_conf
    echo "----> (22-1) 디렉토리가 있으므로, 내용을 확인하고, sudo rm -rf /home/docker/logidb_conf 명령으로 삭제해야 합니다."
else
    sudo mkdir -p /home/docker/logidb_conf
    sudo chown ${USER}:${USER} /home/docker/logidb_conf
    sudo ls -alR /home/docker/logidb_conf
    echo "----> (22-2) 디렉토리를 만들었습니다."
fi
echo "----> (22-3) --------------------"
```

## 3. docker-compose.yml 설정파일 만들기

31. 바로 yml 파일을 만든다.
```
for i in {0..3}; do echo "#"; done

tee /home/docker/logidb_conf/docker-compose.yml <<__EOF__
version: "3"
services:
    logisvc:
        image: mysql:latest
        container_name: logicon
        ports:
            - "3306:3306"
        volumes:
            - /home/docker/logidb:/var/lib/mysql
        environment:
            MYSQL_ROOT_USER: root
            MYSQL_RANDOM_ROOT_PASSWORD: 1
            MYSQL_ROOT_PASSWORD: ok2023
            MYSQL_ROOT_DATABASE: logixls
            TZ: Asia/Seoul
        restart: unless-stopped
        command:
            - --character-set-server=utf8mb4
            - --collation-server=utf8mb4_unicode_ci
__EOF__
sudo ls -l /home/docker/logidb_conf/
echo "----> (31-1) --------------------"
```

32. docker_compose.yml 파일이 저장된 위치로 가서 실행해야 한다.
```
cd /home/docker/logidb_conf
echo "----> (32-1) --------------------"
```

33. docker-compose.yml 내의 이미지들을 모두 다운받는다. `pull` + `서비스_이름` 지정해도 됨.
```
sudo docker-compose pull logisvc
echo "----> (33-1) --------------------"
```

34. docker-compose 를 실행한다.
```
sudo docker-compose up -d
echo "----> (34-1) --------------------"
```

35. 도커가 실행되고 있는지 확인한다.
```
sudo docker-compose ps -a
echo "----> (35-1) --------------------"
```

36. 컨테이너를 시작할 때 MYSQL_RANDOM_ROOT_PASSWORD=1 을 사용했다면, 로그에서 자동으로 생성된 비밀번호를 얻을 수 있습니다.

```
sudo docker logs logicon | grep "GENERATED ROOT PASSWORD"
echo "----> (36-1) --------------------"
```

37. 도커의 mysql 로 로그인 할때 저 비밀번호를 사용한다.
```
sudo docker exec -it logicon mysql -u root -p
echo "----> (37-1) --------------------"
```

38. mysql 로 로그인이 되면, 다음 명령으로 비밀번호를 바꾼다.

출처: mysql workbench를 docker 내에서 mysql 실행에 연결하는 방법은 무엇입니까? 질문됨 7년 9개월 전 6개월 전에 수정됨 156,000회 조회됨 https://stackoverflow.com/questions/33827342/how-to-connect-mysql-workbench-to-running-mysql-inside-docker

`alter user 'root'@'localhost' identified by '새비밀번호';`

`update mysql.user set host = '%' where user='root'; -- 외부에서 도커 안으로 들어오도록 하기위해서.`

39. docker-compose 를 중지시킨다.
```
sudo docker-compose stop
```



# 230915 금
0910 진도

1. (펌) 재밌는 구글 이모지 합치기.jpg [2]21:43:39중복확인 https://www.ddanzi.com/free/782042959
1. 230914비고모두로매출명세서집계.xls

(10-1)
| 명세서-일자 | 명세서-번호 | 명세서-건수 | 매출구분 | 창고 |
|:------:|:------:|:------:|:------:|:------:|
| 명세서 | 명세번호 |  | 매출구분 | 창고 |
| 일자 | 번호 | 건수 |
| 2023-09-13 | 1 | 10 | 매출 | 기준창고 |
| 2023-09-13 | 31 | 1 | 반품매출(미결) | 기준창고 |
| 2023-09-13 | 474 | 1 | 미출고 | 기준창고 |
| 2023-09-13 | 475 | 1 | 매출 | 기준창고 | 
| [ 합 계 ] |  | 1311 |  |  | 

(10-2)
| 코드 | 매출처명 | 명세-공급가액 | 명세-세액 | 명세-합계금액 | 
|:------:|:------:|:------:|:------:|:------:|
| 코드 | 매출처명 | 명세금액 |  |  | 
|  |  | 공급가액 | 세액 | 합계금액 | 
| 44005 | [행사외]닥터고운선 신사/이동훈 | 1709091 | 170909 | 1880000 | 
| 36967 | [행사외]스노우의원 청주/신익수(구,샤인빔의원) | 0 | 0 | 0 | 
| 37998 | 샤인빔의원 화성/장지석 | 0 | 0 | 0 | 
| 35645 | [기타][캐나다] GET UNBLEMISHED SKIN / 벤쿠버 징징카이 | 85727 | 8573 | 94300 | 
|  |  | 107325089 | 8564502 | 115889591 | 

(10-3)
| 코드 | 실납처명 | 비고 | 적요 | 할인금액 | 
|:------:|:------:|:------:|:------:|:------:|
| 코드 | 실납처명 | 비고 | 적요 | 할인금액 | 
|  |  |  |  |  | 
| 44005 | [행사외]닥터고운선 신사/이동훈 | 택배 |  | 0 | 
| 36967 | [행사외]스노우의원 청주/신익수(구,샤인빔의원) | cj 신청완료 |  | 0 | 
| 37998 | 샤인빔의원 화성/장지석 | 보관분 |  | 0 | 
| 35645 | [기타][캐나다] GET UNBLEMISHED SKIN / 벤쿠버 징징카이 | 해외운송비 $94.3 |  | 0 | 
|  |  |  |  | 0 | 

(10-4)
| 영업담당 | 거래명세서-출력횟수 | 거래명세서 출력시간 | 거래명세서 출력자 | 출고지시서-출력횟수 | 
|:------:|:------:|:------:|:------:|:------:|
| 영업담당 | 거래명세서 | 거래명세서 출력시간 | 거래명세서 출력자 | 출고지시서 | 
|  | 출력횟수 | 출력시간 | 출력자 | 출력횟수 | 
| 유성열 | 1 | 2023-09-13 오전 10:26:43 | 박형배 | 0 | 
| 박상봉 | 0 |  |  | 0 | 
| 이경석 | 0 |  |  | 0 | 
| 심상윤 | 0 |  |  | 0 | 

(10-5)
| 출고지시서 출력시간 | 출고지시서 출력자 | 인수증확인-명세서 | 인수증확인0향정 | 인수증확인-생물 | 
|:------:|:------:|:------:|:------:|:------:|
| 출고지시서 출력시간 | 출고지시서 출력자 | 인수증확인 |  |  | 
| 출력시간 | 출력자 | 명세서 | 향정 | 생물 | 
|  |  |  |  |  | 
|  |  |  |  |  | 
|  |  |  |  |  | 
|  |  |  |  |  | 

(10-6)
| 전표 | 검수 | 거래장 | 마감 | 세금계산서 | 
|:------:|:------:|:------:|:------:|:------:|
| 전표 | 검수 | 거래장 | 마감 | 세금계산서 | 
|  |  |  |  |  | 
| N | N | N | N | N | 
| N | N | N | N | N | 
| N | N | N | N | N | 
| N | N | N | N | N | 

(10-7)
| 배송 | 배송방법 | 배송정보-주문자명 | 배송정보-전화번호 | 배송정보-핸드폰번호 | 
|:------:|:------:|:------:|:------:|:------:|
| 배송 | 배송방법 | 배송정보 |  |  | 
|  |  | 주문자명 | 전화번호 | 핸드폰번호 | 
| N | 택배 |  |  |  | 
| N | 택배 |  |  |  | 
| N | 택배 |  |  |  | 
| N | 택배 |  |  |  | 

(10-8)
| 비송정보-우편번호 | 배송정보-배송지 주소 | 배송정보-메모 | 등록일자 | 등록자 | 
|:------:|:------:|:------:|:------:|:------:|
|  |  |  | 등록일자 | 등록자 | 
| 우편번호 | 배송지 주소 | 메모 |  |  | 
|  |  |  | 2023-09-12 10:30:09 | 정란 | 
|  |  |  | 2023-09-13 09:33:18 | 정란 | 
|  |  |  | 2023-09-13 16:34:03 | 우나영 | 
|  |  |  | 2023-09-13 16:36:12 | 우나영 | 

(10-9)
| 수정일자 | 수정자 | 빈칸 | 회계발행 | 인터페이스 | 
|:------:|:------:|:------:|:------:|:------:|
| 수정일자 | 수정자 |  | 회계발행 | 인터페이스 | 
|  |  |  |  |  | 
| 2023-09-12 16:44:09 | 정란 |  | N | N | 
| 2023-09-13 09:33:18 | 정란 |  | N | N | 
| 2023-09-13 16:34:03 | 우나영 |  | N | N | 
| 2023-09-13 16:36:12 | 우나영 |  | N | N | 

(10-10)
| 세액구분 | 거래처종류 | 신고여부-공급내역 | 신고여부-마약류 | 신고여부-의료기기 | 분리구분 | 사업자번호 | 
|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| 세액구분 | 거래처종류 | 신고여부 |  |  | 분리구분 | 사업자번호 | 
|  |  | 공급내역 | 마약류 | 의료기기 |  |  | 
| 과세 | 제조사 | N | N | N | 분리그룹3 | 226-28-58603 | 
| 과세 | 제조사 | N | N | N | 분리그룹3 | 570-33-00735 | 
| 과세 | 제조사 | N | N | N | 분리그룹3 | 575-13-01217 | 
| 과세 | 제조사 | N | N | N | 분리그룹3 |  | 

- .csv 에서 "||" 와 같이 중간에 데이터가 없으면 합쳐사 표현되므로, "| |" 처럼 띄어줘야 한다.

2. 230912-재고현황.xls

(4-1)
| 제조사명 | 코드 | 제품명 | 규격 | 이월수량 |
|:----:|:----:|:----:|:----:|:----:|
| (주)경원정밀 | 10081 | [부품]크라이오랩_CRYO ROLLER |  |  |
| (주)경원정밀 | 10082 | [부품]크라이오랩_CRYO ROLLER PIN |  |  |
|  |  | [(주)경원정밀] 소계 |  |  |
| (주)메디안스랩 | 08281 | # 3차)랩) 아줄렌 앰플크림 | 50ml | 799 |
| (주)메디안스랩 | 08684 | # 글루틴 비타씨 앰플 컴플렉스 시트마스크 | 30g | 16,448 |
| (주)메디안스랩 | 06713 | # 랩) 아줄렌 컴플렉스 앰플 72% | 50ml | 321 |
| (주)메디안스랩 | 07058 | # 랩) 히스토 라이트닝크림마스크 | 250g | 2,169 |
| (주)메디안스랩 | 09978 | # 샘플 - 아줄렌디엔에이크림&톤업크림 | 1ml |  |
| (주)메디안스랩 | 10422 | # 샘플 - 히스토랩 14종 |  |  |
| (주)메디안스랩 | 09986 | # SRGF H1 리셋앰플 | 5ml*8ea |  |
| (주)메디안스랩 | 06418 | #샘플 - 히스토랩 4종앰플 |  |  |
| (주)메디안스랩 | 10514 | 히스토랩 앰플블루세트[아줄렌&히알루론] |  |  |
|  |  | [(주)메디안스랩] 소계 |  | 1,985,083 |
| (주)비아이 | 08817 | EDS) 고주파랩_청소솔 |  |  |
|  |  | [(주)비아이] 소계 |  |  |
| (주)비알코스 | 06775 | 씨리얼 화이트닝 마스크팩/미백 | 25ml (살구) | 14,507 |
|  |  | [(주)비알코스] 소계 |  | 14,507 |
| (주)삼경세라믹 | 10578 | [부품]크라이오랩_온도센서 [NTC 103F343 L2000] |  |  |
|  |  | [(주)삼경세라믹] 소계 |  |  |
| 히트커뮤니케이션 | 08248 | 쇼케이스 - 히스토랩[블랙] |  |  |
|  |  | [히트커뮤니케이션] 소계 |  | 42 |
| Perlong Medical Equipment Co., LTD | 09598 | [부품]아쿠아랩_더스트통[셕션진공용기 1000ml] |  |  |
|  |  | [Perlong Medical Equipment Co., LTD] 소계 |  |  |
|  |  | 합   계 |  | 3,157,232 |

(4-2)
| 단가 | 이월재고액 | 매입수량 | 단가 | 금액 | 매출수량 | 단가 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 0.00 |  | 700 | 5,028.57 | 3,520,000 | 300 | 0.00 |
| 0.00 |  | 760 | 1,100.00 | 836,000 | 360 | 0.00 |
|  |  | 1,460 |  | 4,356,000 | 660 |  |
| 3,300.00 | 2,636,700 | 6,459 | 3,300.00 | 21,314,700 | 6,921 | 6,002.34 |
| 525.00 | 8,635,200 | 267,210 | 541.12 | 144,592,875 | 260,834 | 1,316.88 |
| 9,000.00 | 2,889,000 | 53,211 | 6,605.23 | 351,471,099 | 45,650 | 11,000.01 |
| 5,500.00 | 11,929,500 | 14,351 | 4,866.38 | 69,837,350 | 18,408 | 14,302.01 |
| 0.00 |  | 332,272 | 135.31 | 44,960,324 | 296,946 | 0.22 |
| 0.00 |  |  | 0.00 |  | 283 | 0.00 |
| 0.00 |  | 1,992 | 24,563.30 | 48,930,103 | 1,476 | 57,431.79 |
| 0.00 |  |  | 0.00 |  | 1,020 | 19.61 |
| 0.00 |  | 1,000 | 22,907.50 | 22,907,500 | 968 | 31,500.00 |
|  | 2,257,553,729 | 20,423,368 |  | 28,472,821,393 | 21,082,791 |  |
| 0.00 |  | 518 | 1,317.03 | 682,220 | 544 | 522.60 |
|  |  | 518 |  | 682,220 | 544 |  |
| 165.00 | 2,393,655 | 12,400 | 225.56 | 2,797,000 | 26,524 | 240.24 |
|  | 2,393,655 | 12,400 |  | 2,797,000 | 26,524 |  |
| 0.00 |  | 200 | 3,300.00 | 660,000 |  | 0.00 |
|  |  | 200 |  | 660,000 |  |  |
| 0.00 |  | 355 | 281,920.21 | 100,081,676 | 322 | 0.00 |
|  | 17,464,328 | 455 |  | 129,293,866 | 446 |  |
| 0.00 |  | 405 | 38,392.22 | 15,548,851 | 406 | 573.39 |
|  |  | 405 |  | 15,548,851 | 406 |  |
|  | 2,774,824,389 | 43,046,228 |  | 39,180,058,777 | 41,895,320 |  |

(4-3)
| 금액 | 재고수량 | 단가 | 보험% | 재고금액 | 보험단가 | 보험재고금액 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|  | 400 | 5,500.00 | 0.00 | 2,200,000 | 0.00 |  |
|  | 400 | 1,100.00 | 0.00 | 440,000 | 0.00 |  |
|  | 800 |  |  | 2,640,000 |  |  |
| 41,542,176 | 337 | 3,300.00 | 86.80 | 1,112,100 | 25,000.00 | 8,425,000 |
| 343,488,213 | 22,824 | 579.70 | 71.02 | 13,231,073 | 2,000.00 | 45,648,000 |
| 502,150,341 | 7,882 | 3,967.70 | 86.32 | 31,273,411 | 29,000.00 | 228,578,000 |
| 263,271,400 | -1,888 | 3,479.30 | 88.00 | -6,568,918 | 29,000.00 | -54,752,000 |
| 64,017 | 35,326 | 149.60 | 0.00 | 5,284,770 | 0.00 |  |
|  | -283 | .00 | 0.00 |  | 0.00 |  |
| 84,769,324 | 516 | 10,542.40 | 92.63 | 5,439,878 | 143,000.00 | 73,788,000 |
| 20,000 | -1,020 | 800.00 | 0.00 | -816,000 | 0.00 |  |
| 30,492,000 | 32 | 22,907.50 | 65.29 | 733,040 | 66,000.00 | 2,112,000 |
| 51,547,785,565 | 1,325,660 |  |  | 1,217,857,351 |  | 6,216,047,900 |
| 284,292 | -26 | 1,210.00 | 82.71 | -31,460 | 7,000.00 | -182,000 |
| 284,292 | -26 |  |  | -31,460 |  | -182,000 |
| 6,372,143 | 383 | 155.00 | 84.50 | 59,365 | 1,000.00 | 383,000 |
| 6,372,143 | 383 |  |  | 59,365 |  | 383,000 |
|  | 200 | 3,300.00 | 0.00 | 660,000 | 0.00 |  |
|  | 200 |  |  | 660,000 |  |  |
|  | 33 | 360,506.00 | -36,050,500.00 | 11,896,698 | 1.00 | 33 |
|  | 51 |  |  | 17,413,405 |  | 51 |
| 232,795 | -1 | 59,400.00 | -5,939,900.00 | -59,400 | 1.00 | -1 |
| 232,795 | -1 |  |  | -59,400 |  | -1 |
| 60,245,956,493 | 4,308,140 |  |  | 2,353,965,773 |  | 7,874,776,688 |

(4-4)
| 차액(보험재고-재고) | 보험코드 | 코드 | 발주처명 | 표준코드 | 제품기타코드 |
|:----:|:----:|:----:|:----:|:----:|:----:|
| -2,200,000 |  | 42076 | (주)경원정밀 |  |  |
| -440,000 |  | 42076 | (주)경원정밀 |  |  |
| -2,640,000 |  |  |  |  |  |
| 7,312,900 |  | 32067 | (주)메디안스랩 |  |  |
| 32,416,927 |  | 30705 | (주)헤븐코스 |  | 8809412755131 |
| 197,304,589 |  | 32067 | (주)메디안스랩 |  | 8809412751911 |
| -48,183,082 |  | 32067 | (주)메디안스랩 |  | 8809412752642 |
| -5,284,770 |  | 32067 | (주)메디안스랩 |  |  |
|  |  | 32067 | (주)메디안스랩 |  |  |
| 68,348,122 |  | 32067 | (주)메디안스랩 |  |  |
| 816,000 |  | 32067 | (주)메디안스랩 |  |  |
| 1,378,960 |  | 32067 | (주)메디안스랩 |  |  |
| 4,998,190,541 |  |  |  |  |  |
| -150,540 |  | 42676 | (주)비아이 |  |  |
| -150,540 |  |  |  |  |  |
| 323,635 |  | 32245 | (주)비알코스 |  |  |
| 323,635 |  |  |  |  |  |
| -660,000 |  | 43976 | (주)삼경세라믹 |  |  |
| -660,000 |  |  |  |  |  |
| -11,896,665 |  | 28269 | 히트커뮤니케이션 |  |  |
| -17,413,354 |  |  |  |  |  |
| 59,399 |  | 42012 | Perlong Medical Equipment Co., LTD |  |  |
| 59,399 |  |  |  |  |  |
| 5,520,810,890 |  |  |  |  |  |

2. cat f-read.sh 
```
#!/bin/sh

file_name="01-jaego.csv"
for i in {1..15}
do
	echo "----> head -${i} ${file_name} | tail -1 #-- file_name 의 앞에서 i 번째 줄까지 읽어들여서, 마지막 한줄 (-1 = 일) 만 표시한다."
	head -${i} ${file_name} | tail -1
	echo "----> head -${i} ${file_name} | tail -1 | grep -o '|' | wc -l #-- i 번째 내용에서 '|' 만 꺼내 표시하면서 줄바꾸고 (grep -o), 이렇게 줄이 몇갠지 (wc -l = 엘) 센다."
	head -${i} ${file_name} | tail -1 | grep -o '|' | wc -l
done
```

# 230914 목
1000 푸른숲

1. MySQL Workbench 및 PhpMyAdmin이 포함된 MySQL Docker 컨테이너
데이터베이스 관리를 위해 MySQL Workbench 및 phpMyAdmin을 사용하여 Docker 컨테이너에서 MySQL 데이터베이스 연결 코드로드 6분 읽기 2022년 7월 2일 https://code-road.medium.com/introducing-mysql-docker-container-for-mysql-workbench-and-phpmyadmin-8fe1e599d82a

## MySQL 을 도커로 설치하기

출처: Docker로 MySQL 설치 (docker-compose.yml) Docker 2022. 9. 11. 14:53 https://tychejin.tistory.com/393

### 1. 도커 설치하기

출처: https://computingforgeeks.com/how-to-install-docker-on-fedora/

10. 표시하는 문자에 색깔을 지정하고, 복사/붙여넣기 한 스크립트를 실행할때, 위아래 사이를 구분해 주는 칸 띄우기 문장.
```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)

for i in {0..9}; do echo "#"; done
```

11. 시스템을 최신버전으로 유기하기 위해 다음을 실행한다.
```
sudo dnf -y update
```

12. 시스템 명령어인 dnf 의 플러그인 코어를 받는다.
```
sudo dnf -y install dnf-plugins-core
```

13. 지금 받으려는 docker-ce 가 있는 위치를 리파지토리에 기록한다.
```
for i in {0..3}; do echo "#"; done

sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__
[docker-ce-stable]
name=Docker CE Stable - \$basearch
baseurl=https://download.docker.com/linux/fedora/36/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://download.docker.com/linux/fedora/gpg
__EOF__
```

14. docker-ce 를 받는다.
```
sudo dnf makecache
sudo dnf -y install docker-ce docker-ce-cli containerd.io
sudo systemctl enable --now docker
```

15. Docker 설치 확인
줄의 끝에 lines 1-24/24 (END) 가 나오면, 'Q' 를 눌러서 끝내야 한다.
```
sudo systemctl status docker
sudo docker version
```

16.  docker-compose 를 설치한다.
```
sudo dnf -y install docker-compose
rpm -qi docker-compose
sudo docker ps -a
```

### 2. 보관하는 디렉토리 만들기

21. 데이터베이스가 사용할 디렉토리를 만든다.
```
for i in {0..3}; do echo "#"; done

if [ -d /home/docker/logidb ]; then
    sudo ls -alR /home/docker/logidb
    echo "----> 디렉토리가 있으므로, 내용을 확인하고, sudo rm -rf /home/docker/mysqldb 명령으로 삭제해야 합니다."
else
    sudo mkdir -p /home/docker/logidb
    sudo ls -alR /home/docker/logidb
    echo "----> 디렉토리를 만들었습니다."
fi
```

22. docker-compose.yml 을 보관하는 디렉토리를 만든다.
```
for i in {0..3}; do echo "#"; done

if [ -d /home/docker/logidb_conf ]; then
    sudo ls -alR /home/docker/logidb_conf
    echo "----> 디렉토리가 있으므로, 내용을 확인하고, sudo rm -rf /home/docker/logidb_conf 명령으로 삭제해야 합니다."
else
    sudo mkdir -p /home/docker/logidb_conf
    sudo chown ${USER}:${USER} /home/docker/logidb_conf
    sudo ls -alR /home/docker/logidb_conf
    echo "----> 디렉토리를 만들었습니다."
fi
```

### 3. docker-compose.yml 설정파일 만들기

31. 바로 yml 파일을 만든다.
```
for i in {0..3}; do echo "#"; done

tee /home/docker/logidb_conf/docker-compose.yml <<__EOF__
version: "3"
services:
    logisvc:
        image: mysql:latest
        container_name: logicon
        ports:
            - "3306:3306"
        volumes:
            - /home/docker/logidb:/var/lib/mysql
        environment:
            MYSQL_ROOT_USER: root
            MYSQL_RANDOM_ROOT_PASSWORD: 1
            MYSQL_ROOT_PASSWORD: ok2023
            MYSQL_ROOT_DATABASE: logixls
            TZ: Asia/Seoul
        restart: unless-stopped
        command:
            - --character-set-server=utf8mb4
            - --collation-server=utf8mb4_unicode_ci
__EOF__
sudo ls -l /home/docker/logidb_conf/
```

32. docker_compose.yml 파일이 저장된 위치로 간다.
```
cd /home/docker/logidb_conf
```

33. docker-compose.yml 내의 이미지들을 모두 다운받는다. `pull` + `서비스_이름` 지정해도 됨.
```
sudo docker-compose pull logisvc
```

34. docker-compose 를 실행한다.
```
sudo docker-compose up -d
```

35. 도커가 실행되고 있는지 확인한다.
```
sudo docker-compose ps -a
```

36. 컨테이너를 시작할 때 MYSQL_RANDOM_ROOT_PASSWORD=1 을 사용했다면, 로그에서 자동으로 생성된 비밀번호를 얻을 수 있습니다.

```
sudo docker logs logicon | grep "GENERATED ROOT PASSWORD"
```

37. 도커의 mysql 로 로그인 할때 저 비밀번호를 사용한다.
```
sudo docker exec -it logicon mysql -u root -p
```

38. mysql 로 로그인이 되면, 다음 명령으로 비밀번호를 바꾼다.

출처: mysql workbench를 docker 내에서 mysql 실행에 연결하는 방법은 무엇입니까? 질문됨 7년 9개월 전 6개월 전에 수정됨 156,000회 조회됨 https://stackoverflow.com/questions/33827342/how-to-connect-mysql-workbench-to-running-mysql-inside-docker
```
alter user 'root'@'localhost' identified by '새비밀번호';
update mysql.user set host = '%' where user='root'; -- 외부에서 도커 안으로 들어오도록 하기위해서.
```

39. docker-compose 를 중지시킨다.
```
sudo docker-compose stop
```

# 230913 수
0920 진도

1. Oracle VM VirtualBox 용량 늘리기 blackarea·2022년 6월 8일 https://velog.io/@blackarea/Oracle-VM-VirtualBox-%EC%9A%A9%EB%9F%89-%EB%8A%98%EC%9D%B4%EA%B8%B0
```
sudo dnf in gparted #-- (1) 다운로드
sudo gparted #-- (2) 실행
```
(3) 늘리려는 드라이브 빨간색 네모상자 클릭
(4) 화살표 부분을 마우스로 쭉 늘려주고, [ Resize ] 클릭
(5) 초록색 체크표시 클릭

1. Excel에서 알파벳 순서를 기준으로 최대/최소 문자열을 찾고 추출하는 방법은 무엇입니까? https://www.extendoffice.com/documents/excel/4937-excel-max-text-value-in-column.html
(1) 알파벳 순서를 기준으로 최대 문자열을 찾습니다. (제일 큰 숫자)
```
=INDEX(A3:A445,MATCH(0,COUNTIF(A3:A445,">"&A3:A445),))
```

(2) 알파벳 순서를 기준으로 최소 문자열을 찾습니다. (제일 작은 숫자)
```
=INDEX(A3:A445,MATCH(0,COUNTIF(A3:A445,"<"&A3:A445),))
```


# 230912 화
1000 푸른숲

1. JetBrains 도구 상자 앱 (IDE를 쉽게 관리하세요) https://www.jetbrains.com/toolbox-app/
1. 미로 제작 by Anton Yarkov CORE · Sep. 06, 23 · Tutorial https://dzone.com/articles/crafting-mazes?edition=841493
1. Kotlin, Spring Boot 및 Vue.js를 사용하여 CRUD 앱 만들기 Kotlin, Spring Boot 및 Vue.js를 사용하여 CRUD 앱 만들기 https://dzone.com/articles/using-kotlin-spring-boot-and-vuejs-to-make-a-crud
```
git clone https://github.com/oktadeveloper/okta-kotlin-spring-boot-vue-example.git
```
1. rclone 목록에서 첫번째 디렉토리만 확인하는 스크립트.
```
cat 14-y5ncmi-230912화212829.lsl | awk '{print $4}' | awk -F"/" '{print $1}' | uniq | sort | uniq 
```
1. How to Make a Raspberry Pi NAS - A NAS-Berry that Runs OpenMediaVault Core Electronics 구독자 9.67만명 조회수 1.4만회  6개월 전 https://www.youtube.com/watch?v=zISwEoywvX4

# 230911 월
0920 진도

1. Manning: 1940년 다트머스 대학에서 열린 미국 수학회 회의에서 벨 연구소의 연구원인 조지 스티비츠(George Stibitz)는 원격 컴퓨팅에 대한 최초의 공개 시연을 했습니다. Stibitz는 참석자들이 전화선을 사용하여 뉴욕시에 있는 Bell Labs의 복소수 계산기에 계산 결과를 보낼 수 있는 터미널을 설치했습니다.
https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC 수리 계산기와 초기 컴퓨터 사이의 명령들은 주로 인간이 직접 전달했다. 조지 스티비츠(George Stibitz)는 1940년 9월에 전신기(teletype machine)를 사용해서 뉴욕에 있는 복소수 계산기(Complex Number Calculator)에 명령어들을 보내고 결과를 받았다. 컴퓨터에 전신기 같은 출력 시스템을 연결하는 것은 1962년 J.C.R. Licklider가 소위 '행성간 네트워크'라고 불리던 작업 그룹을 발전시키면서 큰 관심을 기울였던 것이었다. 이 '행성 간 네트워크'는 나중에 알파넷의 전신이 되었다.
1964년 다트머스(Dartmouth)의 연구자들이 대형 컴퓨터 시스템을 사용하는 사람들을 위한 시분할 시스템을 개발했다. 같은 해, 매사추세츠 공과대학교에서는 제너럴 일렉트릭사와 벨 연구소의 지원을 받던 한 연구 그룹이 컴퓨터(DEC's PDP-8)을 사용해 전화 연결을 관리하고 연결 경로를 제어했다. 1968년에는 파울 바란(Paul Baran)이 컴퓨터 시스템들간에 하나의 패킷교환 네트워크에 사용될 수 있는 패킷들 또는 데이터그램으로 구성된 하나의 네트워크 시스템을 제안하였다. 1969년, 캘리포니아 대학교 로스앤젤레스, SRI (in Stanford), 캘리포니아 대학교 산타바버라, 그리고 유타 대학교는 50 kbit/sec 회선들을 이용해서 알파넷망의 시초인 망을 구성했다.
![ remote computing demo in 1940 ](/ilji/2023-09/230911-1300_manning_remote-computing-demo-1940.webp)
1. Tech Brew 멋진 소비자 기술 - 귀하가 인터넷 액세스 요구에 따라 Chrome을 사용하는 전 세계 브라우저 사용자 중 약 60% 에 속한다고 가정하고 The Verge에서 제공하는 몇 가지 유용한 지침
https://links.morningbrew.com/c/bCd?mblid=5eccf2a3a6ce&mbcid=32635418.167825&mid=db30df5cf56610950d7c52cc3ccfea4d
을 전달.
![ 멋진 소비자 기술 ](/ilji/2023-09/230908-2031_tech_brew_멋진_소비자_기술.webp)
1. Leo at Code4Startup leo@code4startup.com Build Your SaaS AI Web Platform From Zero to Production 230913수 예정.

# 230909 토

1. Fedora의 Dropbox – 초보자를 위한 쉬운 설치 가이드 작성자 : Aadesh / 2022년 5월 31일 https://www.linuxfordevices.com/tutorials/linux/dropbox-on-fedora
1. Fedora에 NextCloud를 설치하는 방법 2023년 6월 13일, 전용 서버 호스팅 , 자습서 에서 Hitesh Jethva (607) https://www.atlantic.net/dedicated-server-hosting/how-to-install-nextcloud-on-fedora/
1. MEGA vs Google Drive vs Dropbox vs OneDrive vs SugarSync 등 2023년 마우리시오 프린츨라우 작성자: Mauricio Prinzlau ( CEO 겸 공동 창립자 ) — 마지막 업데이트:2023년 6월 02일 https://www.cloudwards.net/mega-vs-google-drive-vs-skydrive-vs-sugarsync/
1. OneDrive 클라이언트 Fedora 38 설치 - 단계별 2023년 4월 21일 | +gnu+linux+전도사. https://tutorialforlinux.com/2023/04/21/onedrive-client-fedora-38-installation-step-by-step/
GNU/Linux에서 OneDrive 클라이언트를 시작하는 방법 2022년 7월 1일 | +gnu+linux+전도사. https://tutorialforlinux.com/2022/07/01/how-to-getting-started-with-onedrive-client-on-gnu-linux/

## DropBox 설치 (무료 요금제 2 GB)

다음과 같이 dnf 명령으로 dropbox 를 설치한다.
```
sudo dnf install nautilus-dropbox
```

또는, https://www.dropbox.com/install 링크에서 `Ubuntu 22.10 이상(.deb)	64비트` 또는 `Fedora 37 이상(.rpm) 64비트` 를 다운받고, 다음 명령으로 다운로드한 파일을 지정해서 설치한다.
```
sudo dnf in ./nautilus-dropbox-2022.12.05-1.fedora.x86_64.rpm 
```

## OneDrive 설치 (무료 요금제 5 GB)

### 1. 프로그램 설치
```
echo "#-- (1) sudo dnf in onedrive ('OneDrive 클라이언트'프로그램을 설치합니다.)"
sudo dnf in onedrive
echo "#-- (1) --------------------"
```

### 2. 클라이언트 설정

```
for i in {0..5}; do echo "#"; done

echo "#-- (2) onedrive (Linux에서 OneDrive 클라이언트를 설정합니다.)"
onedrive
echo "#-- (2) --------------------"
#
#
#
#
```
### 3. 글로벌 Azure AD 끝점 인증

앞의 스크립트를 실행하면 다음과 같이 화면에 나온다.

┏━━━━━━━━━━━━━━━━━━━━━━
┃╌`Configuring Global Azure AD Endpoints` (글로벌 Azure AD 끝점 구성)
┃╌`Authorize this app visiting:` (아래 링크로 가서 이 앱을 인증한다.)
┃╌
┃╌`https://login.microsoftonline.com/common/oauth2/v2.0/authorize?cli`
┃╌`ent_id=asdfxxx...zzzqwerty&scope=Files.ReadWrite%20Files.ReadWrite`
┃╌`.All%20Sites.ReadWrite.All%20offline_access&response_type=code&pro`
┃╌`mpt=login&redirect_uri=https://login.microsoftonline.com/common/oa`
┃╌`uth2/nativeclient`
┃╌
┃╌`Enter the response uri: `
┗━━━━━━━━━━━━━━━━━━━━━━

1. 이 화면에서, `Authorize this app visiting:` 문장 아래에 나온 링크에 커서를 대고 오른쪽 마우스버튼을 클릭해서 `링크 열기(O)` 를 클릭해서 Microsoft 자격 증명으로 로그인하여 앱을 허용한다.
또는,
위 문장 아래에 나온 링크를 `[Ctrl] + c` 로 복사한다.
그런 다음 브라우저 창에 `[Ctrl] + v` 로 붙여넣어 Microsoft 자격 증명으로 로그인하여 앱을 허용한다.

2. 브라우저 창은 공백이 되는데, 브라우저 주소창의 응답 URI를 다시 `[Ctrl] + c` 로 복사한다.
3. 마지막으로 설정을 끝내기 위해,
```
Enter the response uri:
```

위와같이 대기하고 있는 터미널에 `[Ctrl] + v` 로 붙여넣고 `Enter` 를 누르면 다음과 같이 등록이 끝난다.

┏━━━━━━━━━━━━━━━━━━━━━━
┃╌`Application has been successfully authorised, however no additiona`
┃╌`l command switches were provided.`
┃╌
┃╌`Please use 'onedrive --help' for further assistance in regards to `
┃╌`running this application.`
┗━━━━━━━━━━━━━━━━━━━━━━
`onedrive --help` 를 입력해서 사용방법을 확인할수 있다.

### 4. OneDrive 파일 동기화

1. 구성을 테스트하기 위해 시험 실행을 시도할 수 있다. 실제로는 동기화가 되지 않는다.
```
echo "(4-1a) onedrive --synchronize --verbose --dry-run ('OneDrive' 동기화를 테스트만 하고 동기화는 시작하지 않습니다.)"
onedrive --synchronize --verbose --dry-run
echo "(4-1b) --------------------"
```

2. 동기화를 실제로 실행하려면:
```
echo "(4-2a) onedrive --synchronize ('OneDrive' 동기화를 시작합니다.)"
onedrive --synchronize
echo "(4-2b) --------------------"
```
이렇게 하면 `OneDrive 계정`의 파일이 `~/OneDrive` 라는 이름의 로컬 디렉터리에 동기화 된다.

3. 그러나 `~/OneDrive` 에 저장된 로컬 파일을 `최종적인 실제 소스`로 사용하려면, 다음 동기화 명령을 사용해야 한다.
```
echo "(4-3a) onedrive --synchronize --local-first"
echo "('~/OneDrive' 에 저장된 로컬 파일이 '최종적인 실제 소스' 이므로 'OneDrive' 와 동기화 할때 '~/OneDrive' 의 파일을 최종본으로 처리하도록 강제합니다.)"
echo "🖍️ press Enter:"
read a
onedrive --synchronize --local-first
echo "(4-3b) --------------------"
```

4. 선택한 디렉터리만 동기화하는 경우:
```
echo "(4-4a) ls ~/OneDrive"
echo "(~/OneDrive 아래에 있는, 지정한 디렉토리만 동기화 합니다.)"
ls ~/OneDrive
echo "(4-4b) onedrive --synchronize --single-directory '<dir_name>'"
echo "(예를 들어, 전체 경로가 '~/OneDrive/mydir' 인 경우, 위 명령에서 '<dir_name>' 을 `mydir` 로 바꾸면 됩니다.")"
echo "🖍️ Enter <dir_name>:"
read dir_name
if [ "x$dir_name" != "x" ]; then
    echo "(4-4c) onedrive --synchronize --single-directory '${dir_name}'"
    echo "🖍️ press 'y' and Enter: [ '${dir_name}` is OK ]"
    read a
    if [ "x$a" != "x" ]; then
        echo "#-- (4-4d) onedrive --synchronize --single-directory '${dir_name}'"
        onedrive --synchronize --single-directory "${dir_name}"
    fi
fi
echo "#-- (4-4e) --------------------"
```
5. 한쪽 방향으로 `다운로드만` 하도록 동기화 하려면:
```
echo "(4-5a) onedrive --synchronize --download-only"
echo "(한쪽 방향으로만 다운로드 하도록 동기화 합니다.)"
echo "🖍️ press Enter:"
read a
onedrive --synchronize --download-only
echo "#-- (4-5b) --------------------"
```
6. 한쪽 방향으로 `업로드만` 하도록 동기화 하려면:
```
echo "(4-6a) onedrive --synchronize --upload-only"
echo "(한쪽 방향으로만 업로드 하도록 동기화 합니다.)"
echo "🖍️ press Enter:"
read a
onedrive --synchronize --upload-only
echo "(4-6b) --------------------"
```
7. `업로드만` 하도록 지정하지만 업로드 받는 쪽에만 있는 데이터를 삭제는 하지 않으려면:

위의 경우에 특히 주의할 것은,
`OneDrive` 에는 파일이나 폴더가 `있는데`, **로컬**에는 **없는** 경우:
**로컬** 쪽에서 `OneDrive` 쪽으로 `업로드만` 하도록 지정이 돼 있으므로,
**로컬** 쪽에는 없으니,---> `OneDrive` 쪽의 파일이나 폴더가 `삭제` 된다.

따라서, 다운로드는 안하고 업로드만 하려고 하는데,
`OneDrive` 의 파일/폴더는 유지해야 하는 경우,
다음과 같이 지정해야 한다.
```
echo "(4-7a) onedrive --synchronize --upload-only --no-remote-delete"
echo "(업로드만 하지만 업로드 받는쪽을 삭제하지는 않도록 동기화 합니다.)"
echo "🖍️ press Enter:"
read a
onedrive --synchronize --upload-only --no-remote-delete
echo "(4-7b) --------------------"
```

## MEGA drive 설치 (무료 요금제 20 GB)

1. mega.io

무료 요금제인 경우, 1일 4GB 까지만 다운로드 가능하고, 이후 최대 24시간 이후에 다시 다운로드가 가능하다.
유료 요금제인 경우, 요금제에 따라 1TB, 2TB, 8TB, 16TB 까지로, 사실상 제한이 없는거나 마찬가지.

# 230908 금
0930 진도

1. bc (프로그래밍 언어) https://en.wikipedia.org/wiki/Bc_(programming_language)
basic calculator (often referred to as bench calculator)

- `echo "2/3" | bc` 👈 (bc) 소숫점 이하 버림
`echo "2/3" | bc -l` 👈 (bc -l) 표시할 소숫점 이하 자릿수를 지정 안하면 **그냥 20 자리**로 설정 + 수학 함수도 추가

- `time echo "scale=9; 4*a(1)" | bc -l` 👈 (bc -l) 원주율 PI 값 계산.
**time** (뒤에 쓴 명령이 걸린 시간을 표시)
**scale=9** (소숫점 이하의 자릿수를 9자리로 설정)
**4\*a(1)** (1의 아크탄젠트는 45도이며 라디안 단위는 pi/4)

```
x="" ;for i in {101..110} ;do x="${x}....+...${i: -2}" ;done ;echo $x ;time echo "scale=1000; 4*a(1)" | bc -l ;echo $x #-- 뒤에서부터 자를때는 " -2" 와 같이 한칸 띄워야 한다.
```

2. 라디안(radian)과 디그리(degree) 수학 이야기 2013. 1. 28. 16:20 https://darkpgmr.tistory.com/26
(1) --> 일상적으로 사용하는 각의 단위는 디그리(degree) --> 원 한바퀴 = (360도) , 반원 = (180도) , 직각 = (90도) ...
(2) --> 라디안(radian) --> 부채꼴의 중심각 기준. 호의 길이가 반지름과 같게 되는 만큼의 각을 1 라디안(radian)
1 radian = (약 57.3도에 해당하는 각) , 2 radian = (약 114.6도)
![ 1 라디안(radian) ](/ilji/2023-09/230908-radian.webp)

3. 역삼각함수란? 구글 클래스룸 역사인, 역코사인, 역탄젠트에 대하여 배우고, 직각삼각형에서 모르는 각을 구하는데 어떻게 쓰이는지 배워 봅시다. https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro

4. BC 표준 라이브러리

| bc | 명령  기능 | 설명 |
|:---:|:---:|:---:|
| s(x) | 사인 | 라디안 단위 의 각도 인 x 를 사용합니다 |
| c(x) | 코사인 | 라디안 단위의 각도 인 x 를 사용합니다 |
| a(x) | 아크탄젠트 | 라디안을 반환합니다 |
| l(x) | 자연로그 | |
| e(x) | 지수 함수 | |
| j(n,x) | 베셀 함수 | x 의 차수 n 베셀 함수를 반환합니다 |

# 230907 목
1010 푸른숲

# 도커 와 도커 컴포즈

- `도커`: 호스트 OS 의 **시스템 자원** 을 **공유** 하면서 `컨테이너` 를 **운영**하는 `가상화 도구`.
(chroot, 네임 스페이스, cgroup 등을 이용해)
- `컨테이너`: **프로세스** 단위로 **격리된** 환경.
동작하는 앱과 이에 필요한 바이너리, 라이브러리 만 담겨있다.
- `도커 컴포즈`: 여러개의 **도커** 를 `한번에`**실행**`하도록` 도와주는 `도구`.
(시스템 구축과 종료, 폐기까지)

# 도커 설치하기

## 1. Fedora 시스템 업데이트
```
sudo dnf -y update
```

페도라 터미널에서 쓰는 색상값을 지정한다.
```
for i in {0..9}; do echo "#"; done

#-- cBlack=$(tput bold)$(tput setaf 0); cRed=$(tput bold)$(tput setaf 1);
#-- cGreen=$(tput bold)$(tput setaf 2); cYellow=$(tput bold)$(tput setaf 3);
#-- cBlue=$(tput bold)$(tput setaf 4); cMagenta=$(tput bold)$(tput setaf 5);
#-- cCyan=$(tput bold)$(tput setaf 6); cWhite=$(tput bold)$(tput setaf 7);
#-- cReset=$(tput bold)$(tput sgr0); cUp=$(tput cuu 2)

lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1);
ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3);
bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5);
ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7);
xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)

echo "#--"
echo "\${cBlack} ${cBlack}회색 bLack${cReset} , \${cRed} ${cRed}빨강 Red${cReset} , \${cGreen} ${cGreen}녹색 Green${cReset} , \${cYellow} ${cYellow}노랑 Yellow${cReset} , \${cBlue} ${cBlue}파랑 Blue${cReset}"
echo "\${cMagenta} ${cMagenta}보라 Magenta${cReset} , \${cCyan} ${cCyan}청록 Cyan${cReset}, \${cWhite} ${cWhite}흰색 White${cReset} , \${cReset} ${cReset}색취소"
echo "#--"
echo "\${hhh} ${hhh}회색 bLack${xxx} , \${rrr} ${rrr}빨강 Red${xxx} , \${ggg} ${ggg}녹색 Green${xxx} , \${yyy} ${yyy}노랑 Yellow${xxx} , \${bbb} ${bbb}파랑 Blue${xxx}"
echo "\${mmm} ${mmm}보라 Magenta${xxx} , \${ccc} ${ccc}청록 Cyan${xxx}, \${www} ${www}흰색 White${xxx} , \${xxx} ${xxx}색취소"
echo "#--"
echo "${rrr}#----.----+----.----+----.----+----.----+----.----+----.----+-- (1) "
echo "${ggg}#----.----+----.----+----.----+----.----+----.----+----.--- (2) "
echo "${yyy}#----.----+----.----+----.----+----.----+----.----+---- (3) "
echo "${bbb}#----.----+--- (4-1) ^^^>${uuu}<^^^ 윗쪽으로 Up (4-2) "
echo "${mmm}#----.--- (5) "
echo "${ccc}#--- (6)${xxx} "
```
| lll | 검정 bLack | rrr | 빨강 Red | ggg | 녹색 Green | yyy | 노랑 Yellow | bbb | 파랑 Blue |
|:---|:---:|---:|:---:|---:|:---:|:---:|:---:|:---:|:---:|
| mmm | 보라 Magenta | ccc | 청록 Cyan | www | 흰색 White | xxx | 색취소 | uuu | 윗쪽으로 Up |

## 2. Fedora 리파지토리 추가

도커 설치전에, 다음과 같이 Fedora 리파지토리를 시스템에 추가해야 한다.
```
for i in {0..9}; do echo "#"; done

echo "#-- 시스템 명령어인 dnf 의 플러그인 코어를 받습니다"
echo "#-- ${bbb}(2-1)${xxx} sudo dnf -y install dnf-plugins-core"
sudo dnf -y install dnf-plugins-core
echo "#-- 받으려는 docker-ce 가 있는 위치를 리파지토리에 기록합니다"
echo "#-- ${bbb}(2-2)${xxx} sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__"
sudo tee /etc/yum.repos.d/docker-ce.repo << __EOF__
[docker-ce-stable]
name=Docker CE Stable - \$basearch
baseurl=https://download.docker.com/linux/fedora/36/\$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://download.docker.com/linux/fedora/gpg
__EOF__
echo "#-- ${bbb}(2-3)${xxx} 출처: https://computingforgeeks.com/how-to-install-docker-on-fedora/ == Fedora 를 위한 리파지토리를 시스템에 추가합니다."
```

## 3. Docker 설치
```
for i in {0..9}; do echo "#"; done

echo "#-- docker-ce 를 받습니다."
echo "#-- ${bbb}(3-1)${xxx} sudo dnf makecache"
sudo dnf makecache
echo "#-- ${bbb}(3-2)${xxx} sudo dnf -y install docker-ce docker-ce-cli containerd.io"
sudo dnf -y install docker-ce docker-ce-cli containerd.io
echo "#-- ${bbb}(3-3)${xxx} sudo systemctl enable --now docker"
sudo systemctl enable --now docker
echo "#-- ${bbb}(3-4)${xxx} --------------------"
```

## 4. Docker 설치 확인
```
for i in {0..9}; do echo "#"; done

echo "줄의 끝에 lines 1-24/24 (END) 가 나오면, 'Q' 를 눌러서 끝내야 합니다."
echo "🖍️ ${bbb}(4-1)${xxx} press Enter:"
read a
echo "${bbb}(4-2)${xxx} sudo systemctl status docker"
sudo systemctl status docker
echo "${bbb}(4-3)${xxx} sudo docker version"
sudo docker version
echo "${bbb}(4-4)${xxx} --------------------"
```

# wiki.js 를 위한 도커 컴포즈 설치하기

## 도커 컴포즈란
1. 시스템 구축과 관련된 명령어를 `하나의 텍스트 파일` (= 정의 파일) 에 기재.
1. 명령어 한번에 시스템 전체를 실행.
1. 종료와 폐기까지 `한번에 하도록` 도와주는 도구.

👉 도커 컴포즈를 사용하면 여러 개의 명령어를 하나의 정의 파일로 합쳐 실행할 수 있다.

작업 순서:
1. wiki.js 를 운영할 도커 와 그 데이터베이스를 보관하는 디렉토리 만들기
2. 도커 컴포즈 설정파일 만들기
3. 설정파일 대로 도커 컴포즈 (빌드 + 실행) 하기
4. 브라우저에서 (주소:포트번호) 입력
5. 첫번째 등록작업

## 5. 보관하는 디렉토리 만들기

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

db_made="x"
if [ ! -d ${DB_DIR} ]; then
    echo "#-- ${bbb}(5-1)${xxx} sudo mkdir -p ${DB_DIR}"
    sudo mkdir -p ${DB_DIR}
    #-- chcon -R system_u:object_r:container_file_t:s0 ${DB_DIR}
    #-- sudo chown -R systemd-coredump:ssh_keys ${DB_DIR}
    db_made="o"
fi

wiconf_made="x"
if [ ! -d ${WIKI_CONF_DIR} ]; then
    echo "#-- ${bbb}(5-2)${xxx} sudo mkdir -p ${WIKI_CONF_DIR}"
    sudo mkdir -p ${WIKI_CONF_DIR}
    echo "#-- ${bbb}(5-3)${xxx} sudo chown -R ${USER}:${USER} ${WIKI_CONF_DIR}"
    sudo chown -R ${USER}:${USER} ${WIKI_CONF_DIR}
    wiconf_made="o"
fi

echo "===== db_and_wiconf ${db_and_wiconf}"
if [ "x${db_made}" = "xx" ] || [ "x${wiconf_made}" = "xx" ]; then
    echo "#-- ${bbb}(5-4)${xxx} sudo ls -lR --color ${DOCKER_DIR}"
    sudo ls -lR --color ${DOCKER_DIR}
    echo "#-- ${bbb}(5-5)${xxx} ${DB_DIR}, ${WIKI_CONF_DIR} 디렉토리 확인후, 다음 명령으로 삭제하세요."
    echo "#-- sudo rm -rf ${DB_DIR} ${WIKI_CONF_DIR}"
else
    echo "#-- ${bbb}(5-6)${xxx} sudo ls -lR --color ${DOCKER_DIR} 디렉토리를 만들었습니다."
    sudo ls -lR --color ${DOCKER_DIR}
fi
echo "#-- ${bbb}(5-7)${xxx} --------------------"
```

## 6. 설정파일 docker-compose.yml 만들기

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

cat > ${WIKI_CONF_DIR}/docker-compose.yml <<__EOF__
version: "3"
services:
  ${DB_SERVICE}:
    image: postgres:11-alpine
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PSWD}
      POSTGRES_DB: ${DB_NAME}
    logging:
      driver: "none"
    restart: unless-stopped
    volumes:
      - ${DB_DIR}:/var/lib/postgresql/data
    container_name:
      ${DB_CONTAINER}

  ${WIKI_SERVICE}:
    image: requarks/wiki:2
    depends_on:
      - db
    environment:
      DB_TYPE: postgres
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PSWD}
      DB_NAME: ${DB_NAME}
    restart: unless-stopped
    ports:
      - "${WIKI_PORT_NO}:3000"
    container_name:
      ${WIKI_CONTAINER}
__EOF__
echo "#-- ${bbb}(6-1)${xxx} ls -lR ${DOCKER_DIR}"
ls -lR ${DOCKER_DIR}
grep "ports:" -A3 ${WIKI_CONF_DIR}/docker-compose.yml
echo "#-- ${bbb}(6-2)${xxx} --------------------"
```

## 7. 도커 컴포즈 빌드 + 실행

```
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

echo "#-- ${bbb}(7-1)${xxx} cd ${WIKI_CONF_DIR}"
cd ${WIKI_CONF_DIR}
echo "#-- ${bbb}(7-2)${xxx} sudo dnf -y install docker-compose (설치)"
sudo dnf -y install docker-compose
echo "#-- ${bbb}(7-3)${xxx} rpm -qi docker-compose (내역)"
rpm -qi docker-compose
echo "#-- ${bbb}(7-4)${xxx} sudo docker ps -a"
sudo docker ps -a
echo "#-- ${bbb}(7-5)${xxx} sudo docker-compose pull ${WIKI_SERVICE} (빌드)"
sudo docker-compose pull ${WIKI_SERVICE} ### ### sudo docker-compose up --build ###

cat <<__EOF__
...
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 🔻🔻🔻🔻🔻🔻🔻🔻🔻🔻
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: Browse to http://YOUR-SERVER-IP:3000/ to complete setup!
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 
${WIKIJS_CONTAINER_NAME}  | 2023-07-07T08:19:07.832Z [MASTER] info: 🔻🔻🔻🔻🔻🔻🔻🔻🔻🔻


위와 같은 메세지가 표시되면,

(1) ----> 아래의 명령을 --- 직접 --- 입력해서,

sudo docker ps -a

도커 실행내역을 확인합니다.

(2) ----> 브라우저에서 --- 아래의 주소를 입력해서,

localhost:${WIKI_PORT_NO}

wiki.js 를 실행해서 --- 관리자 등록과 첫 홈페이지를 만듭니다.

----> ${bbb}(7-6)${xxx} press Enter:
__EOF__
read a

echo "#-- ${bbb}(7-7)${xxx} sudo docker-compose up --force-recreate & (빌드한 도커 컴포즈를 실행합니다)"
sudo docker-compose up --force-recreate &
echo "#-- ${bbb}(7-8)${xxx} sudo docker-compose ps -a"
sudo docker-compose ps -a
echo "#-- ${bbb}(7-9)${xxx} --------------------"
```

# 데이터 백업과 리스토어

## 8. 단순백업 보관하기

```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

#--> 로컬과 원격 보관장소
this_y4m2=$(date +%Y)-$(date +%m) #- 2022-08
LOCAL_Y2M2=${LOCAL_FOLDER}/${this_y4m2}
if [ ! -d ${LOCAL_Y2M2} ]; then
        echo "#-- ${bbb}(8-1)${xxx} ${LOCAL_Y2M2} 로컬 디렉토리를 만듭니다."
    mkdir -p ${LOCAL_Y2M2}
fi
CLOUD_Y2M2=${CLOUD_FOLDER}/${this_y4m2}
#<-- 로컬과 원격 보관장소

echo "#-- ${bbb}(8-2)${xxx} 위키 도커를 중단합니다."
echo "#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER}"
sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER}
if [ ! -d ${LOCAL_FOLDER} ]; then
    echo "#-- ${bbb}(8-3)${xxx} 보관 폴더를 만듭니다."
    echo "#-- sudo mkdir -p ${LOCAL_FOLDER} ; sudo chown ${USER}:${USER} ${LOCAL_FOLDER}"
    sudo mkdir -p ${LOCAL_FOLDER} ; sudo chown ${USER}:${USER} ${LOCAL_FOLDER}
fi

echo "#-- ${bbb}(8-4)${xxx} 백업을 보관하는 로컬 디렉토리 입니다."
echo "#-- ls -lR ${LOCAL_Y2M2}"
ls -lR ${LOCAL_Y2M2}

ymd_hm=$(date +"%y%m%d%a-%H%M")
current_backup=${DB_NAME}_${ymd_hm}_$(uname -n).sql.7z #- 압축파일 이름
cat <<__EOF__
#-
#- DB 백업
#-
#- (8-5)${xxx} wili.js 데이터베이스를 백업하기 위해서 아래에 ---비밀번호--- 를 입력하세요.
#-
__EOF__
echo "#-- ${bbb}(8-5)${xxx} 오늘 요일이름의 로컬 보관장소에 백업합니다."
echo "#-- sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -si ${LOCAL_Y2M2}/${current_backup} -p"
sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -si ${LOCAL_Y2M2}/${current_backup} -p
echo "#-- ${bbb}(8-6)${xxx} 보관용 로컬 폴더입니다."
echo "#-- ls -lR ${LOCAL_Y2M2}"
ls -lR ${LOCAL_Y2M2}
# echo "#-- ${bbb}(8-7)${xxx} 오늘 요일이름의 파일을 클라우드로 복사합니다."
# echo "#-- sudo /usr/bin/rclone copy ${LOCAL_Y2M2}/${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/"
# sudo /usr/bin/rclone copy ${LOCAL_Y2M2}/${DB_sql7z} ${CLOUD_NAME}:${CLOUD_Y2M2}/
# echo "#-- ${bbb}(8-8)${xxx} 클라우드 폴더입니다."
# echo "#-- /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}"
# /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
echo "#-- ${bbb}(8-9)${xxx} 위키 도커를 다시 시작합니다."
echo "#-- sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a"
sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
echo "#-- ${bbb}(8-10)${xxx} --------------------"
```
## 9. 백업파일을 DB 에 도로담기

1. 구글 클라우드로 백업했던 wiki.js db 파일을 로컬 폴더로 복사한다.
1. 복사한 db 파일 이름 을 다음과 같이 스크립트를 사용해서 wiki.js 에 올린다.
1. 리스토어 하기 전에, 현재의 데이터베이스를 저장할 것인지 물어서, 답에 따라 현재 db 를 만들어 놓고 나서 리스토어한다

`백업 backup`: 현재의 데이터베이스를 **wikipg-220907수-1802-proenpi4b.sql.7z** 와 같은 이름으로 압축해서 저장한다.
`리스토어 restore`: 압축해서 보관했던 백업 파일을 데이터베이스에 도로 부어 담는다.
`현재 상태의 마지막 백업`: 백업파일을 리스토어 하는 경우, 현재의 db 에 들어있던 데이터는 백업파일에 의해 지워진다. 그래서 일단 현재상태의 db 를 **" last-\${DB_CONTAINER}-\$(date +%y%m%d_%H%M%S)-\$(uname -n).sql.7z "** 등으로 백업하고서 리스토어 하기 위해서 마지막 백업을 실시한다.

```
lll=$(tput bold)$(tput setaf 0); rrr=$(tput bold)$(tput setaf 1); ggg=$(tput bold)$(tput setaf 2); yyy=$(tput bold)$(tput setaf 3); bbb=$(tput bold)$(tput setaf 4); mmm=$(tput bold)$(tput setaf 5); ccc=$(tput bold)$(tput setaf 6); www=$(tput bold)$(tput setaf 7); xxx=$(tput bold)$(tput sgr0); uuu=$(tput cuu 2)
for i in {0..9}; do echo "#"; done

#--> 이름 지정
DOCKER_DIR=/home/docker
DB_DIR=${DOCKER_DIR}/pgsql
#-- pgsql db
DB_USER="imwiki"
DB_PSWD="wikipswd"
#------ DB_PSWD="wikijsrocks"
DB_NAME="wikidb"
DB_CONTAINER="wikipg"
#-- wiki.js
WIKI_CONF_DIR=${DOCKER_DIR}/wiki_conf
WIKI_CONTAINER="wikijs"
WIKI_PORT_NO="9900"
#-- services
DB_SERVICE="db"
WIKI_SERVICE="wiki"
#-- local/remote folder
LOCAL_FOLDER="/home/backup/${DB_CONTAINER}" #- 보관용 로컬 저장소
CLOUD_NAME="tpn3mi" #- rclone 이름
CLOUD_FOLDER="${DB_CONTAINER}" #- 원격 저장소의 첫번째 폴더 이름
#<-- 이름 지정

#--> 로컬과 원격 보관장소
this_y4m2=$(date +%Y)-$(date +%m) #- 2022-08
LOCAL_Y2M2=${LOCAL_FOLDER}/${this_y4m2}
if [ ! -d ${LOCAL_Y2M2} ]; then
    echo "#-- ${bbb}(9-1)${xxx} ${LOCAL_Y2M2} 로컬 디렉토리를 만듭니다."
    mkdir -p ${LOCAL_Y2M2}
fi
CLOUD_Y2M2=${CLOUD_FOLDER}/${this_y4m2}
#<-- 로컬과 원격 보관장소

echo "#-- 복구하려는 백업 파일 이름 zzz = ${zzz}"

#-- ----> 리스토어 파일이 있으면 현재의 DB 를 백업하고 리스토어 한다.
if [ "x${zzz}" = "x" ] || [ ! -f "${zzz}" ]; then
    #-- ----> 리스토어 파일이 없으면 여기서 끝냄.
    cat <<__EOF__
#-- ${bbb}(9-2)${xxx} ls -lR ${LOCAL_FOLDER} #--- 백업 디렉토리 내용
$(ls -lR ${LOCAL_FOLDER})
#--
#-- ${bbb}(9-3)${xxx} 지정한 (리스토어 할) ${zzz} 파일이 존재하지 않습니다.
#--
#-- 리스토어 할 파일 이름이 " /home/backup/wikipg/2023-09 " 디렉토리에 있는 " last-${DB_CONTAINER}-230908금-1431-vFedora38.sql.7z " 인 경우:
#-- 
#-- zzz="/home/backup/wikipg/2023-09/last-${DB_CONTAINER}-230908금-1431-vFedora38.sql.7z"
#--
#-- (복구하려는 파일 이름을 담은 변수의 이름이 zzz 임.)
#--
#-- 이와 같이 Bash Terminal 에서 선언하고 나서, 이 스크립트를 실행해야 합니다.
#-- 
#-- ${bbb}(9-4)${xxx} ${zzz} 파일이 없으므로 작업을 중단합니다.
__EOF__
    #-- <---- 리스토어 파일이 없으면 여기서 끝냄.
else
    #-- ----> 리스토어 할 .7z 파일이 있다.
    sql_name=$(basename ${zzz}) # 백업파일 이름만 꺼냄
    sql_dir=${zzz%/$sql_name} # 백업파일 이름을 빼고 나머지 디렉토리만 담음
    cat <<__EOF__
#-- zzz = "${zzz}"
#-- sql_name = ${sql_name} # 백업파일 이름만 꺼냄
#-- sql_dir = ${sql_dir} # 백업파일 이름을 빼고 나머지 디렉토리만 담음
#--
#-- ${bbb}(9-5)${xxx} 현재의 DB 를 백업하지 않으려면, 소문자 'n' 을 눌러 주세요."
__EOF__
    read n_is_no_backup ; echo "${uuu}"
    echo "[ ${n_is_no_backup} ]"
    if [ "x$n_is_no_backup" = 'xn' ]; then
        #-- ----> 현재의 DB 를 백업하지 않는다 선택.
        cat <<__EOF__
# |
# |
# |
# |
# |
# | !!!! 주의 !!!! 현재 DB 를 다운로드 + 백업하지 않고, 업로드 합니다.
# |
# | 여기서 소문자 'y' 를 누르면 현재의 DB 백업을 하지 않습니다.
# |
# | 다른 글자거나 그냥 Enter 를 누르면 백업이 진행됩니다.
# |
----> 백업 안하는 'y' Enter:
__EOF__
        read y_is_No_Backup ; echo "${uuu}"
        echo "[ ${y_is_No_Backup} ]"
        #-- --> '백업 받기 전' 위키 컨테이너 정지
        cat <<__EOF__
#-- ${bbb}(9-6)${xxx} 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
        sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
        #-- <-- '백업 받기 전' 위키 컨테이너 정지
        if [ "x$y_is_No_Backup" != 'xy' ]; then
            #-- ----> 현재 DB 를 다운로드 + 백업 합니다.
            current_backup="${LOCAL_Y2M2}/last-${DB_CONTAINER}-$(date +%y%m%d_%H%M%S)-$(uname -n).sql.7z"
            cat <<__EOF__
#-- ${bbb}(9-7)${xxx} 지정한 백업파일을 데이터베이스에 붓기 전에,
#-- 현재 운영중인 DB 를 먼저 ${LOCAL_Y2M2} 에 백업합니다.
#--
#-- 백업받은 .7z 파일에 지정해 줄 ${mmm}새로운 비밀번호${xxx}를 입력하세요.
#-- sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -mx=9 -p -si ${current_backup}
__EOF__
            sudo docker exec ${DB_CONTAINER} pg_dumpall -U ${DB_USER} | 7za a -mx=9 -p -si ${current_backup}
            cat <<__EOF__
#-- ${bbb}(9-8)${xxx} 오늘 요일이름의 파일을 클라우드로 복사합니다.
#-- sudo /usr/bin/rclone copy ${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/
__EOF__
            sudo /usr/bin/rclone copy ${current_backup} ${CLOUD_NAME}:${CLOUD_Y2M2}/
            cat <<__EOF__
#-- ${bbb}(9-9)${xxx} 클라우드 폴더입니다.
#-- /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
__EOF__
            /usr/bin/rclone lsl ${CLOUD_NAME}:${CLOUD_Y2M2}
            #-- <---- 현재 DB 를 다운로드 + 백업 합니다.
        fi
        #-- <---- 현재의 DB 를 last_backup 으로 백업하지 않는다 선택.
    else
        #-- ----> 현재의 DB 를 last_backup 으로 백업한다 선택.
        #-- --> 위키 컨테이너 정지
        cat <<__EOF__
#-- ${bbb}(9-10)${xxx} 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
        sudo docker ps -a ; sudo docker stop ${WIKI_CONTAINER} ; sudo docker ps -a
        #-- <-- 위키 컨테이너 정지
        #-- <---- 현재의 DB 를 last_backup 으로 백업한다 선택.
    fi
    cat <<__EOF__
#-- ${bbb}(9-11)${xxx} 기존의 데이터베이스를 삭제합니다.
#-- sudo docker exec -it ${DB_CONTAINER} dropdb -U ${DB_USER} ${DB_NAME}
__EOF__
    sudo docker exec -it ${DB_CONTAINER} dropdb -U ${DB_USER} ${DB_NAME}
cat <<__EOF__
#-- ${bbb}(9-12)${xxx} 빈 데이터베이스를 새로 만듭니다.
#-- sudo docker exec -it ${DB_CONTAINER} createdb -U ${DB_USER} ${DB_NAME}
__EOF__
    sudo docker exec -it ${DB_CONTAINER} createdb -U ${DB_USER} ${DB_NAME}
    cat <<__EOF__
#-- ${bbb}(9-13)${xxx} 지정한 백업파일을 데이터베이스에 다시 붓습니다. (RESTORE)
#-- 백업할때 입력한 ${mmm}비밀번호${xxx}를 입력하세요.
#-- time 7za x -so ${zzz} | sudo docker exec -i ${DB_CONTAINER} psql -U ${DB_USER} ${DB_NAME}
__EOF__
    time 7za x -so ${zzz} | sudo docker exec -i ${DB_CONTAINER} psql -U ${DB_USER} ${DB_NAME}
    cat <<__EOF__
#-- ${bbb}(9-14)${xxx} 멈췄던 위키 컨테이너를 다시 시작합니다.
#-- sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
__EOF__
    sudo docker start ${WIKI_CONTAINER} ; sudo docker ps -a
    echo "#-- ${bbb}(9-15)${xxx} 백업 작업이 끝났습니다."
    #-- <---- 리스토어 할 .7z 파일이 있다.
fi
zzz=""
#-- <---- 리스토어 파일이 있으면 현재의 DB 를 백업하고 리스토어 한다.
```

결과
```
#
#
#
#-- (9-1) ${zzz} = /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z;
----> ls -l /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z
-rw-r--r--. 1 yosj yosj 23026  9월  8일  16:37 /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z

zzz = "/home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z" # (9-3)
sql_name = wikidb_230908금-1637_vFedora38.sql.7z # 백업파일 이름만 꺼냄
sql_dir = /home/backup/wikipg/2023-09 # 백업파일 이름을 빼고 나머지 디렉토리만 담음
----> Press Enter:

#-- (9-4) 현재의 DB 를 last_backup 으로 백업하지 않으려면, ' n ' 을 눌러 주세요.
[ n ]
# |
# |
# |
# |
# |
# |
!!!! 주의 !!!! 현재 DB 를 다운로드 + 백업하지 않고, 업로드 합니다.

----> press ' y ' Enter:
[ y ]
#-- (9-5) 백업을 시작하기전 위키 컨테이너를 멈춥니다.
#-- sudo docker ps -a ; sudo docker stop wikijs ; sudo docker ps -a
CONTAINER ID   IMAGE                COMMAND                   CREATED          STATUS          PORTS                                                 NAMES
9ced4fe78495   requarks/wiki:2      "docker-entrypoint.s…"   44 minutes ago   Up 4 minutes    3443/tcp, 0.0.0.0:9900->3000/tcp, :::9900->3000/tcp   wikijs
b665608edfe3   postgres:11-alpine   "docker-entrypoint.s…"   44 minutes ago   Up 44 minutes   5432/tcp                                              wikipg
wikijs
CONTAINER ID   IMAGE                COMMAND                   CREATED          STATUS                              PORTS      NAMES
9ced4fe78495   requarks/wiki:2      "docker-entrypoint.s…"   44 minutes ago   Exited (0) Less than a second ago              wikijs
b665608edfe3   postgres:11-alpine   "docker-entrypoint.s…"   44 minutes ago   Up 44 minutes                       5432/tcp   wikipg
#-- (9-7) 오늘 요일이름의 파일을 클라우드로 복사합니다.
#-- /usr/bin/rclone copy /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z tpn3mi:wikipg/2023-09/
2023/09/08 17:19:46 ERROR : Local file system at /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z: error reading source root directory: directory not found
2023/09/08 17:19:46 ERROR : Attempt 1/3 failed with 1 errors and: directory not found
2023/09/08 17:19:46 ERROR : Local file system at /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z: error reading source root directory: directory not found
2023/09/08 17:19:46 ERROR : Attempt 2/3 failed with 1 errors and: directory not found
2023/09/08 17:19:46 ERROR : Local file system at /home/backup/wikipg/2023-09/last-wikipg-230908_171441-vFedora38.sql.7z: error reading source root directory: directory not found
2023/09/08 17:19:46 ERROR : Attempt 3/3 failed with 1 errors and: directory not found
2023/09/08 17:19:46 Failed to copy: directory not found
#-- (9-8) 클라우드 폴더입니다.
#-- /usr/bin/rclone lsl tpn3mi:wikipg/2023-09
    23138 2023-09-08 16:38:00.000000000 wikidb_230908-1427_vFedora38.sql.7z
    23138 2023-09-08 14:28:08.000000000 wikidb_230908금-1427_vFedora38.sql.7z
    24322 2023-09-08 14:31:41.000000000 wikidb_230908금-1431_vFedora38.sql.7z
    23026 2023-09-08 16:38:01.000000000 wikidb_230908금-1637_vFedora38.sql.7z
    24482 2023-09-08 16:40:15.000000000 wikidb_230908금-1640_vFedora38.sql.7z
#-- (9-9) 기존의 데이터베이스를 삭제합니다.
#-- sudo docker exec -it wikipg dropdb -U imwiki wikidb
#-- (9-10) 빈 데이터베이스를 새로 만듭니다.
#-- sudo docker exec -it wikipg createdb -U imwiki wikidb
#-- (9-11) 지정한 백업파일을 데이터베이스에 다시 붓습니다. (RESTORE)
#-- 백업할때 입력한 비밀번호를 입력하세요.
#-- time 7za x -so /home/backup/wikipg/2023-09/wikidb_230908금-1637_vFedora38.sql.7z | sudo docker exec -i wikipg psql -U imwiki wikidb

SET
SET
SET
ERROR:  role "imwiki" already exists
ALTER ROLE
You are now connected to database "template1" as user "imwiki".
SET

...

ALTER TABLE
ALTER TABLE
ALTER TABLE

real	1m31.252s
user	0m0.064s
sys	0m0.045s
#-- (9-12) 멈췄던 위키 컨테이너를 다시 시작합니다.
#-- sudo docker start wikijs ; sudo docker ps -a
wikijs
CONTAINER ID   IMAGE                COMMAND                   CREATED          STATUS                  PORTS                                                 NAMES
9ced4fe78495   requarks/wiki:2      "docker-entrypoint.s…"   46 minutes ago   Up Less than a second   3443/tcp, 0.0.0.0:9900->3000/tcp, :::9900->3000/tcp   wikijs
b665608edfe3   postgres:11-alpine   "docker-entrypoint.s…"   46 minutes ago   Up 46 minutes           5432/tcp                                              wikipg
#-- (9-13) 백업 작업이 끝났습니다.
17:21:23금230908 yosj@vFedora38 ~
```

# 230906 수
0930 진도

1. 1029 여임대인전화,군에간아들500여일후제대후 지방근무로 전세끼고매매검토중, 연락요망.
1. 타 자료 복사
1. gimp사진수정 > 사진폴더 만들고 업로드 > 링크
1. wikijs 내부망에서 공유하기 - 공유기 세팅 / windows-virtualbox 포트포워딩
1. Dropbox 사용 - 3개 장치만 가능.
1. wiki.js 데이터베이스 백업
1. Container & K8S & Automation/Docker Docker 명령어 정리 승어리(Won) 2019. 1. 30. 14:23 https://captcha.tistory.com/49

1. FFmpeg 및 대안을 사용하여 WebM을 MP3로 변환하는 방법 작성자: Christine Smith • 2023-05-31 15:56:08 • 검증된 솔루션 https://videoconverter.wondershare.com/convert-mp3/ffmpeg-webm-to-mp3.html
1. FFmpeg 다운로드 https://www.ffmpeg.org/download.html
https://mirror.fcix.net/rpmfusion/free/fedora/releases/38/Everything/x86_64/os/repoview/ffmpeg.html 에서 `ffmpeg-*.rpm` 을 다운로드 한다.
```
sudo dnf install ./ffmpeg-6.0-6.fc38.x86_64.rpm
```
FILE="230905-탐사...소리-74M.webm" ; ffmpeg -i "${FILE}" -vn -ab 128k -ar 44100 -y "${FILE%.[Ww][Ee][Bb][Mm]}.mp3"


# 230905 화
1010 푸른숲

1. yes24 ebook PC 뷰어 다운로드
https://www.yes24.com/notice/eBookGuide/guide_pc.aspx
1. 팬데믹 프로그램 종료, 가족저축 중단, 인플레이션으로 비용증가.
1조달러 신용카드빚, 연체율 3.8%, 소비자대출 연체 5.4%, 자동차대출 연체 3.6%, 신용카드 이자율 21%
Buy Now Pay Later 옵션 의존 > 가구,TV 아니고 식료품 21%
한국 생활비, 주택, 교육비 문제 - thedailyupside.com
구글엑셀 - 금전출납부
구글keep - 즉시메모
wiki.js - 글쓰기
keepassXC + onedrive - 암호관리
1. Spring Boot 3 및 React를 사용한 풀 스택 개발 - Fourth Edition https://subscription.packtpub.com/book/web-development/9781805122463/1
Full Stack Development with Spring Boot 3 and React - If you’re an existing Java developer who wants to go full stack or pick up another frontend framework, this book is... By Juha Hinkula Oct 2023
1. 워드프레스 플러그인 개발 쿡북 WordPress Plugin Development Cookbook - Third Edition - WordPress is one of the most widely used, powerful, and open content management systems (CMSs). Whether you're a si... By Yannick Lefebvre Mar 2022 420 page https://subscription.packtpub.com/book/web-development/9781801810777/pref
1. WooCommerce 마스터하기 4 WooCommerce는 온라인 상점 구축을 위한 가장 유연한 플랫폼 중 하나입니다. 유연성으로 v를 제공할 수 있습니다. By Patrick Rauland Mar 2020 334 pages
1. WordPress 5 Cookbook 워드프레스 5 요리책 WordPress는 수년 동안 가장 인기있는 콘텐츠 관리 시스템 (CMS)이었으며 현재 30 % 이상을 지원하고 있습니다. By Rakhitha Nimesh Ratnayake Mar 2020 660 pages
1. keePassXC 다운로드 https://keepassxc.org/download/#
브라우저 확장 프로그램 다운로드 -- 컴퓨터에 KeePassXC가 설정되면 KeePassXC 브라우저 확장 프로그램을 다운로드하여 브라우저에서 온라인 비밀번호를 자동으로 입력합니다.
[ FireFox 용 ](https://addons.mozilla.org/en-US/firefox/addon/keepassxc-browser/) 다운로드
[ Chrome 용 ](https://chrome.google.com/webstore/detail/keepassxc-browser/oboonakemofpalcgghocfoadofidjkkk) 다운로드
[ Edge 용 ](https://microsoftedge.microsoft.com/addons/detail/keepassxcbrowser/pdffhmdngciaglkoonimfcmckehcpafo) 다운로드
1. vcruntime140_1.dll 오류 - 다운로드 해결방법(매우 간단) 김세인트 컴퓨터공학과 / 그외  2022. 8. 7. https://mk28.tistory.com/273#google_vignette

# 230904 월

1. mysql 에서 한글 사용하려면,
1. [MySQL] 데이터 타입(data_type) 정리 https://spiderwebcoding.tistory.com/5
1. MySQL에서 한글 인코딩 문제 해결하기 jimin_lee·2021년 3월 1일 https://velog.io/@jimin_lee/MySQL%EC%97%90%EC%84%9C-%ED%95%9C%EA%B8%80-%EC%9D%B8%EC%BD%94%EB%94%A9-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0
1. [MySQL] Load Data 시도 중 secure_file_priv 문제 직면 수노 SUNHO 2017. 10. 26. 09:30 https://sssunho.tistory.com/56
1. 올인원 비디오 변환기 https://videoconverter.wondershare.com/convert-mp3/ffmpeg-webm-to-mp3.html
1. 펌) 유독 한국에서만 흥행했던 영화들 ㄷㄷㄷㄷㄷ [37]18:24:41심푸순&나물밥상 https://www.ddanzi.com/index.php?mid=free&statusList=HOT%2CHOTBEST%2CHOTAC%2CHOTBESTAC&document_srl=781183024
1. [!긴급편성!] 홍범도 장군 흉상 철거? 이완용도 이러지는 않았다!!! 우리가 북한과 다른 이유? 독립운동사를 왜곡하는 것은 반헌법적인 것! #심용환 #현재사는심용환 #홍범도 현재사는 심용환 구독자 16.9만명 조회수 4.2만회  1일 전 https://www.youtube.com/watch?v=19qyfJfR7Wk
1. Ubuntu 및 기타 Linux 배포판에서 YouTube 비디오를 다운로드하는 3가지 쉬운 방법 이러한 애플리케이션을 사용하여 Ubuntu 및 기타 Linux 배포판에서 YouTube, Vimeo, Dailymotion 및 Facebook 비디오를 다운로드하세요. 아비셰크 프라카시 2023년 5월 7일 https://itsfoss.com/download-youtube-videos-ubuntu/
```
sudo dnf in yt-dlp
```
1. docker 설치 https://docs.docker.com/engine/install/fedora/

(1) 옛버전 삭제
```
sudo dnf remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
```
(2) 리파지토리 셋업
```
sudo dnf -y install dnf-plugins-core
sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
```
(3) 도커 엔진 설치
If prompted to accept the GPG key, verify that the fingerprint matches 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35, and if so, accept it.
```
sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```
(4) 도커 시작
```
sudo systemctl start docker
```
1. Fedora 38 등에서 Docker Compose 를 설치하고 사용하기 ByJosphat Mutai-August 17, 2023 https://computingforgeeks.com/install-and-use-docker-compose-on-fedora/#google_vignette
1단계: Docker 엔진 설치
2단계: Fedora에 Docker Compose 설치
2단계: 방법 1: 바이너리 파일에서 Docker Compose를 설치합니다.
2단계: 방법 2: OS 저장소에서 Fedora에 Docker Compose 설치(최신 패키지가 아님)

2단계: 방법 1: Fedora 업스트림 리포지토리에서 사용 가능한 Docker Compose 버전을 설치하려면 다음 명령을 실행하세요.
```
sudo dnf install docker-compose
rpm -qi docker-compose
```
3단계: Compose 명령줄 완성 구성
 Compose에는 bash 및 zsh 셸에 대한 명령 완성 기능이 제공됩니다  .

배시 사용자의 경우
완성 스크립트를 /etc/bash_completion.d/에 넣으세요.
```
sudo curl -L https://raw.githubusercontent.com/docker/compose/master/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose
source /etc/bash_completion.d/docker-compose
```

## Fedora Update

### 1. 비번스킵
```
sudo vi /etc/sudoers # G10kyyp2xwcw<USERNAME><ESC>:x!<ENTER>
```

#### 1.1 호스트 이름을 vFed37 로 바꾼다
```
sudo hostnamectl set-hostname vFed37
```

#### 1.2 Google 크롬 리포지토리 활성화
```
sudo dnf config-manager --set-enabled google-chrome
```

### 2. 추가로 프로그램 설치
```
sudo dnf install make automake autoconf gcc dkms \
    kernel-debug-devel kernel-devel wget vim-enhanced vim-common \
    mc git p7zip gnome-tweak-tool rclone \
    snapd keepassxc fedora-workstation-repositories \
    google-chrome-stable \
    livecd-tools liveusb-creator -y
```

#### 2.1 커널 버전 확인
```
rpm -qa | grep kernel | sort | grep kernel
```

#### 2.2 원격 셀 sshd 실행
```
sudo systemctl enable sshd
sudo systemctl start sshd
```

### 3. vbox 그룹 추가
```
grep vboxsf /etc/group | grep ${USER}
grep vboxsf /etc/group
```

#### 3.1 vboxsf 그룹 추가하고 다시 확인
```
sudo gpasswd -a ${USER} vboxsf
grep vboxsf /etc/group
```

#### 3.2 vboxsf 그룹에 사용자가 추가됐다면, 이 시스템을 다시 시작해야 한다.
```
sudo reboot
```

### 4. 게스트 확장 CD 이미지 삽입

vfedora 초기화 작업을 진행하기 전에,
화면 맨 윗줄에 표시된 (파일 , 머신 , 보기 , 입력 , 장치 , 도움말) 메뉴에서,

[장치] 클릭 >> [게스트 확장 CD 이미지 삽입] 을 클릭하고,
자동으로 시작하기로 한 프로그램 . . . 실행하시겠습니까? >> [실행] 을 클릭.

#### 4.1 윈도우에서 탐색기 창을 열고, "다운로드" 폴더에 "bada" 라는 폴더를 새로 만든다.

#### 4.2 자동시작 프로그램을 실행한다.
```
sudo /sbin/rcvboxadd quicksetup all ; sudo /sbin/rcvboxadd setup
```

#### 4.3 윈도우와 연결하는 폴더를 ${HOME}/wind_bada 라는 이름으로 연결한다.
```
ln -s /media/sf_Downloads/bada/ ${HOME}/wind_bada
```

#### 4.4 호스트(host) 인 윈도우 폴더가 게스트i(guest) 인 fedora 에 마운트 되었는지 확인한다.
```
ls -l ${HOME}
ls -l ~/wind_data
```

### 5. VundleVim 설치
```
sudo dnf install git gcc vim-enhanced vim-common p7zip

git clone https://github.com/susabolca/Vundle.vim ${HOME}/.vim/bundle/Vundle.vim
```

#### 5.1 proen 서버에 미리 만들어둔 파일을 ${HOME} 디렉토리로 복사한다.
```
rsync -avzr -e 'ssh -p 15822' proenpi@proen.duckdns.org:ar*/my*/li*/DOTbashrc ~/.bashrc
rsync -avzr -e 'ssh -p 15822' proenpi@proen.duckdns.org:ar*/my*/li*/DOTvimrc ~/.vimrc
```

#### 5.2 Bundle 을 설치한다
```
vim +BundleInstall +qall
```

### 6. 한글 폰트파일 설치
```
sudo rsync -avzr -e 'ssh -p 15822' proenpi@proen.duckdns.org:ar*/my*/li*/font*7z /usr/share/fonts/

cd /usr/share/fonts/ ; 7za x ./font*.7z
sudo chown root:root D2Coding KoPub jeju_ttf naver-nanum seoul
sudo chmod 755 D2Coding KoPub jeju_ttf naver-nanum seoul
sudo chmod 644 D2Coding/* KoPub/* jeju_ttf/* naver-nanum/* seoul/*
```

#### 6.1 snap 링크 설치 확인
```
sudo ln -s /var/lib/snapd/snap /snap
ls -l --color /snap
```

#### 6.2 sdkman 설치
```
curl -s \"https://get.sdkman.io\" | bash
```

# 230903 일

1. Excel을 MySQL로 가져오기: 4가지 쉬운 방법 by Dhanashree Published: & Updated:  Apr 4, 2023 https://nanonets.com/blog/import-excel-into-mysql/
1. How to Install MySQL on Fedora? author thedeepak https://www.geeksforgeeks.org/how-to-install-mysql-on-fedora/
1. Linux에서 Docker를 사용하여 MySQL을 설정하는 방법 Karthick 이 작성 : 2021년 12월 6일마지막 업데이트 날짜 2022년 12월 7일 https://ostechnix.com/setup-mysql-with-docker-in-linux/
1. Fedora 38/37/36/35/34/33에서 Mysql Workbench 설치 및 사용 에 의해클린스만 외테요-2023년 8월 23일 https://computingforgeeks.com/install-and-use-mysql-workbench-on-fedora/?expand_article=1

## Linux 에서 Docker 를 사용하여 MySQL 을 설정하는 방법
by Karthick Published: December 6, 2021 Last Updated on December 7, 2022 https://ostechnix.com/setup-mysql-with-docker-in-linux/

### 1. Install Docker
```
sudo docker --version
sudo docker-compose --version
```

### 2. Download MySQL Docker Image
```
sudo docker pull mysql:latest
sudo docker images mysql
```

### 3. Launch MySQL Container
```
sudo docker run --name mysql -p 7700:3306 -v mysql_volume:/var/lib/mysql/ -d -e "MYSQL_ROOT_PASSWORD=temp123" mysql
```
여러줄로 나누어 표시:
```
sudo docker run --name mysql \
    -p 7700:3306 \
    -v mysql_volume:/var/lib/mysql/ \
    -d \
    -e "MYSQL_RANDOM_ROOT_PASSWORD=1" \
    \ #-- 또는 -e "MYSQL_ROOT_PASSWORD=temp123"
    mysql
```
`--name` → 컨테이너에 이름을 지정합니다. 이 플래그를 지정하지 않으면 docker는 무작위로 생성된 이름을 할당합니다.

`-p` → 포트번호 매핑. MySQL은 3306 포트 에서 수신 대기하므로 호스트 시스템의 포트 (7700 → 3306) 를 도커 컨테이너에 매핑합니다 . 호스트 포트번호는 반드시 7700 이어야 하는 것은 아니며, 사용할 수 있는 포트번호면 무엇이든 가능합니다.
로컬 머신에서 다음 netstat 명령을 실행하여 컨테이너가 시작된 후 매핑된 포트가 수신 대기 중인지 여부를 확인하세요.
```
sudo netstat -tlnup | grep -i 7700
```
`-v` → 컨테이너에 볼륨을 연결합니다.
docker의 기본 동작은 컨테이너가 제거되면 데이터를 유지하지 않으므로 모든 데이터가 손실된다는 것입니다. 그래서 영구 저장소를 생성하기 위해 'mysql_volume' 이라는 볼륨을 localhost 에 생성했습니다.
MySQL은 컨테이너 내부에 위치한 `/var/lib/mysql/` 에 데이터를 저장하고, 이곳이 여기서는 컨테이너 외부인 localhost 디렉토리의 `/var/lib/docker/volumes/mysql_volume1/_data` 가 영구 저장되는 곳으로 매핑됩나다.

`-d` → 분리 모드에서 컨테이너를 시작하고 실행합니다. 플래그 를 생략하면 -d터미널에 컨테이너 시작 로그가 표시되며 컨테이너에 연결하려면 새 터미널 세션을 열어야 합니다.

`-e` → 환경 변수. 아래 매개변수 중 하나를 사용하여 mysql 루트 사용자 비밀번호를 설정 해야 합니다 .

- `MYSQL_ROOT_PASSWORD` → 이 환경 변수를 사용하여 자신만의 비밀번호를 설정하세요.
- `MYSQL_ALLOW_EMPTY_PASSWORD` → 공백 또는 Null 비밀번호가 설정됩니다. `MYSQL_ALLOW_EMPTY_PASSWORD=1` 을 설정해야 합니다.
- `MYSQL_RANDOM_ROOT_PASSWORD` → 컨테이너가 시작되면 임의의 비밀번호가 생성됩니다. `MYSQL_RANDOM_ROOT_PASSWORD=1` 임의의 비밀번호를 생성하도록 설정해야 합니다 .

### 4. MySQL 컨테이너 상태 확인

다음 명령을 사용하여 시작된 컨테이너 상태를 확인할 수 있습니다.
```
sudo docker ps -a
```

### 5. MySQL 데이터베이스에 연결

다음 명령을 실행하여 MySQL 컨테이너에 연결합니다.
```
sudo docker exec -it mysql bash
```

컨테이너를 시작할 때 `MYSQL_RANDOM_ROOT_PASSWORD=1` 을 사용했다면, 로그에서 자동으로 생성된 비밀번호를 얻을 수 있습니다.

```
sudo docker logs mysql | grep "GENERATED ROOT PASSWORD"
```

비밀번호를 입력해서 시작합니다.
```
mysql -u root -p
```

자동으로 생성된 루트 비밀번호는 길어서 기억할 수 없습니다. 다음 쿼리를 실행하여 루트 비밀번호를 **my_new_pswd** 로 재설정할 수 있습니다.
```
mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'my_new_pswd';
```

### 6. 샘플 데이터 로딩

mysql 을 설정하는 주요 목적은 일부 데이터를 로드하고 이에 대해 쿼리를 실행하는 것입니다. 데이터를 로드할 수 있는 몇 가지 방법이 있습니다. 다음에 쿼리가 포함된 "load_data.sql" 이라는 샘플 파일이 있습니다.
```
CREATE DATABASE IF NOT EXISTS football;

USE football;

CREATE TABLE IF NOT EXISTS players (
    player_name     VARCHAR(16)     NOT NULL,
    player_age      INT             NOT NULL,
    player_club     VARCHAR(16)     NOT NULL,
    player_country  VARCHAR(16)     NOT NULL
);

INSERT INTO players VALUES ("Messi",34,"PSG","Argentina");
INSERT INTO players VALUES ("Ronaldo",36,"MANU","Portugal");
INSERT INTO players VALUES ("Neymar",29,"PSG","Brazil");
INSERT INTO players VALUES ("Kane",28,"SPURS","England");
INSERT INTO players VALUES ("E Hazard",30,"MADRID","Belgium");
```

첫 번째 접근 방식은 "docker cp" 명령을 사용하여 로컬 시스템의 데이터를 도커 컨테이너로 복사하는 것입니다.
```
sudo docker cp load_data.sql mysql:/tmp
sudo docker exec -it mysql bash
ls -l /tmp/
```

이제 mysql 클라이언트에 연결하여 소스 명령을 실행하거나 파일을 mysql 클라이언트로 리디렉션할 수 있습니다.
```
mysql -u root -p
mysql> source /tmp/load_data.sql
```
또는
```
mysql -u root -p < /tmp/load_data.sql
```

데이터베이스에 연결하고 테이블을 쿼리합니다.
```
mysql -u root -p
show databases;
use football;
show tables;
select * from players;
```

두 번째 접근 방식은 docker exec 명령을 실행할 때 .sql 파일을 리디렉션하는 것입니다.
```
sudo docker exec -i mysql mysql -u root -p < load_data.sql
```

## 7. Docker-Compose 를 사용하여 MySQL 컨테이너 설정
by Karthick Published: December 6, 2021 Last Updated on December 7, 2022 https://ostechnix.com/setup-mysql-with-docker-in-linux/

이미지를 가져와서 docker run 명령을 실행하는 대신, docker-compose 를 사용하여 컨테이너를 빠르게 가동할 수 있습니다. Docker-compose 는 생성할 컨테이너가 두 개 이상인 경우에 가장 적합합니다.

1. docker-compose 의 마지막 버전을 확인한다. https://github.com/docker/compose/releases
1. 마지막 버전을 가져온다.
```
DOCKER_COMPOSE_LAST_VERSION="v2.21.0" #-- 2023-09-04
sudo curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_LAST_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```
3. 파일의 퍼미션을 지정해주고, 설치한 docker-compose 의 버전을 확인한다.
```
sudo chmod +x /usr/local/bin/docker-compose
sudo docker-compose version
```


### docker-compose.yml 또는 docker-compose.yaml 이라는 파일을 만듭니다.

다음 yaml 코드를 복사하여 붙여넣습니다. 이는 이전 섹션에서 수동으로 실행한 것과 동일합니다.
```
version: '3.8'
services:
  database:
    image: mysql:latest
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: temp1234
    ports:
      - "7700:3306"
    volumes:
      - /home/docker/mysql:/var/lib/mysql
    command: ['mysqld', '--character-set-server=utf8mb4', '--collation-server=utf8mb4_unicode_ci']
```
MySQL 5.7 docker-compose template feat:한글 깨짐 JinungKim 2022. 3. 24. 12:50 - https://jinyes-tistory.tistory.com/369

> - mysql_volume:/var/lib/mysql
> volumes:
>   mysql_compose_volume:

이제 MySQL 도커 컨테이너를 가동하는 다음 명령을 실행하십시오.
```
sudo docker-compose up
```

docker-compose 를 사용하여 시작된 컨테이너의 상태를 확인하려면 다음 명령을 실행하십시오.
```
sudo docker-compose ps -a
```

### Bash 스크립트를 만들고 한번에 실행할 수 있습니다.

```
14:47:07수230913 yosj@vFedora38 ~/git-projects/fedora-sh/13-xls2mysql-docker-compose
13-xls2mysql-docker-compose $ cat 00-docker-compose-mysql-설치.sh 
#!/bin/sh

source ${HOME}/bin/color_base #-- 221027목-1257 CMD_DIR CMD_NAME cmdRun cmdCont cmdYenter echoSeq 
MEMO="00 docker-compose 로 mysql 설치하기"
cat <<__EOF__
${cMagenta}>>>>>>>>>>${cGreen} $0 ${cMagenta}||| ${cCyan}${MEMO} ${cMagenta}>>>>>>>>>>${cReset}
__EOF__
#--zz00logs_folder="${HOME}/zz00logs" ; if [ ! -d "${zz00logs_folder}" ]; then cmdRun "mkdir ${zz00logs_folder}" "로그 폴더" ; fi
#--zz00log_name="${zz00logs_folder}/zz.$(date +"%y%m%d%a-%H%M%S")__RUNNING_${CMD_NAME}" ; touch ${zz00log_name}
# ----


#cmdRun "sudo docker-compose ps -a" "운영중인 MySQL DB 도커들"
##for out in $(sudo docker ps -a | awk '{print $NF}')
##do
##	if [ "x$out" != "xNAMES" ]; then
##		DB_IP=$(sudo docker inspect ${out} | grep '"IPAddress"' | tail -n 1 | awk -F : '{print $2}' | awk -F \" '{print $2}')
##		echo "${out}	${DB_IP}"
##	fi
##done

CONTAINER_NAME=myxlsct
PORT_NO=7700
DATABASE_NAME=hajdb
#-xx LOG_NAME=myxlsctlog
#-xx USER_NAME=myxlsctroot

echo "${cRed}[ ${cYellow}${CONTAINER_NAME} ${cGreen}${DATABASE_NAME} ${cBlue}${USER_NAME} ${Red}] -OK-${cReset}"
#-xx echo "${cRed}[ ${cYellow}${CONTAINER_NAME} ${cGreen}${DATABASE_NAME} ${cBlue}${USER_NAME} ${cCyan}${LOG_NAME} ${Red}] -OK-${cReset}"

#--

DOCKER_NETWORK_NAME=goodworld

return_value=$(sudo docker network ls | grep "${DOCKER_NETWORK_NAME}")
if [ "x${return_value}" = "x" ]; then
	cmdCont "sudo docker network create ${DOCKER_NETWORK_NAME}"
fi

#--

# DATABASE_FOLDER=${HOME}/docker-data/database/${CONTAINER_NAME}
DATABASE_FOLDER=/home/docker/${CONTAINER_NAME}

if [ ! -d ${DATABASE_FOLDER} ]; then
	echo "----> ${cGreen}sudo mkdir -p ${DATABASE_FOLDER}${cReset}"
	sudo mkdir -p ${DATABASE_FOLDER}
	cmdRun "sudo chcon -R system_u:object_r:container_file_t:s0 ${DATABASE_FOLDER}"
	cmdRun "sudo chown -R systemd-coredump:ssh_keys ${DATABASE_FOLDER}"
	cmdRun "ls -lZ ${DATABASE_FOLDER}" "디렉토리를 만들었습니다."
else
	cmdRun "ls -l ${DATABASE_FOLDER}"
	echo "${cRed}!!!!${cMagenta} ----> ${cCyan}${DATABASE_FOLDER}${cReset} 디렉토리가 있으므로, 진행을 중단합니다."
	exit -1
fi

IS_DATABASE=$(sudo docker ps -a | grep ${CONTAINER_NAME})
if [ "x${IS_DATABASE}" != "x" ]; then
	sudo docker ps -a | grep ${IS_DATABASE}
	CAT <<__EOF__
${cRed}!!!!${cMagenta} ----> ${cCyan}${CONTAINER_NAME}${cReset} 도커가 있으므로, 진행을 중단합니다.
__EOF__
	exit -1
fi

# ----> MySQL 용 도커 설치

# cmdCont "$(cat <<__EOF__
YML_FOLDER=/home/docker/docker_conf
if [ ! -d ${YML_FOLDER} ]; then
	echo "----> ${cGreen}sudo mkdir -p ${YML_FOLDER}${cReset}"
	sudo mkdir -p ${YML_FOLDER}
	echo "----> ${cGreen}sudo chown ${USER}:${USER} ${YML_FOLDER}${cReset}"
	sudo chown ${USER}:${USER} ${YML_FOLDER}
	cmdRun "ls -lZ ${YML_FOLDER}" "디렉토리를 만들었습니다."
else
	cmdRun "ls -l ${YML_FOLDER}"
	echo "${cRed}!!!!${cMagenta} ----> ${cCyan}${YML_FOLDER}${cReset} 디렉토리가 있으므로, 진행을 중단합니다."
	exit -1
fi

YML_FILE="${YML_FOLDER}/docker-compose.yml"
if [ -f "${YML_FILE}" ]; then
	cmdRun "ls -l ${YML_FILE}"
	cat <<__EOF__
${cRed}!!!!${cMagenta} ----> ${cCyan}${YML_FILE}${cReset} 파일이 있으므로, 진행을 중단합니다.
__EOF__
	exit -1
fi

cat > ${YML_FILE} <<__EOF__
version: '3.8'
services:
  database:
    image: mysql:latest
    container_name: ${CONTAINER_NAME}
    environment:
      MYSQL_RANDOM_ROOT_PASSWORD: 1
    ports:
      - "7700:3306"
    volumes:
      - /home/docker/${CONTAINER_NAME}:/var/lib/mysql
    command: ['mysqld', '--character-set-server=utf8mb4', '--collation-server=utf8mb4_unicode_ci']
__EOF__
#-- volumes: - /home/docker/${CONTAINER_NAME}:/var/lib/mysql
#-- mysql 데이터 위치 - 도커바깥 PC의 위치=내가 지정 : 도커가 쓰는 도커안쪽 위치

cmdRun "cat ${YML_FILE}"

cmdRun "cd ${YML_FOLDER} ; sudo docker-compose up &" "cd ${YML_FOLDER} ; sudo docker logs ${CONTAINER_NAME} 2>&1 | grep --color PASSWORD # <---- (0) 표시된 비밀번호를 복사하세요."


echo "${cCyan}#----> db 초기화 작업이 끝날때까지 최대 2 분간 기다립니다."
sleep 15
for i in 1 2 3 4 5 6 7 8
do
	return_value=$(sudo docker logs ${CONTAINER_NAME} 2>&1 | grep PASSWORD)
	if [ "x${return_value}" = "x" ]; then
		cmdRun "sleep 15s" "#-- 비밀번호 확인 ${i}"
	else
		break
	fi
done

#--

if [ "x${return_value}" = "x" ]; then
	cmdCont "sudo docker logs ${CONTAINER_NAME} 2>&1 | grep --color PASSWORD" "${cRed}# <---- 비밀번호를 계속 확인해야 합니다."
else
	cmdRun "sudo docker logs ${CONTAINER_NAME} 2>&1 | grep --color PASSWORD" "# <---- (0) 위에 표시된 비밀번호를 복사하세요."
fi

cat <<__EOF__
sudo docker exec -it ${CONTAINER_NAME} mysql -u root -p ${cMagenta}# <---- ${cYellow}(1) ${cMagenta}Enter password: 가 나오면, GENERATED ROOT PASSWORD 를 여기에 붙여넣기 합니다.${cReset}

ALTER USER 'root'@'localhost' IDENTIFIED BY '<>-<>-<>'; ${cGreen}-- -- -- -- ${cYellow}(2) ${cMangeta}<>-<>-<> 자리에 비번을 넣습니다. 복사할때 앞의 ${cGreen}초록색 -- -- -- -- ${cMagenta} 까지만 복사해야 합니다.${cReset}
             |
	     | 위와 같이 (1) ~ (2) 를 진행해야 설치가 끝납니다.
__EOF__
cmdRun "ls --color ${CMD_DIR}" ; ls --color ${logs_folder}


# alter user 'root'@'%' identified by '<>-<>-<>' ; grant all privileges on *.* to 'root'@'%' with grant option ; create database if not exists ${DATABASE_NAME} character set utf8 ; create user '${USER_NAME}'@'%' identified by '<>-<>-<>' ; grant all privileges on *.* to '${USER_NAME}'@'%' with grant option ; exit ; ${cGreen}-- -- -- -- ${cYellow}(2) ${cMangeta}<>-<>-<> 자리에 비번을 넣습니다. 복사할때 앞의 ${cGreen}초록색 -- -- -- -- ${cMagenta} 까지만 복사해야 합니다.${cReset}
# sudo docker exec -it ${CONTAINER_NAME} /bin/bash ; sudo docker restart ${CONTAINER_NAME} ; sudo docker ps -a ; ls --color ${CMD_DIR} ; ls --color ${logs_folder} ${cMagenta}# <---- ${cYellow}(3) ${cMagenta}docker 를 다시 시작해서 아래의 (4) 를 실행할 준비를 합니다.${cReset}
# echo "character-set-server=utf8" >> /etc/mysql/mysql.conf.d/mysqld.cnf ; tail -3 /etc/mysql/mysql.conf.d/mysqld.cnf ; exit ${cMagenta}# <---- ${cYellow}(4) ${cMagenta}docker 에서 utf8 을 쓰도록 지정합니다.${cReset}


# ----
#--rm -f ${zz00log_name} ; zz00log_name="${zz00logs_folder}/zz.$(date +"%y%m%d%a-%H%M%S")..${CMD_NAME}" ; touch ${zz00log_name}
#--ls --color     ${zz00log_name}
cat <<__EOF__
${cRed}<<<<<<<<<<${cBlue} $0 ${cRed}||| ${cMagenta}${MEMO} ${cRed}<<<<<<<<<<${cReset}
__EOF__
```

### 8. MySQL Workbench를 사용하여 MySQL 데이터베이스에 연결

지금까지 우리는 컨테이너 내부에서 mysql 클라이언트를 사용하여 데이터베이스에 연결하는 방법을 살펴보았습니다. mysql workbench, dbeaver, Heidi SQL 등과 같은 GUI 클라이언트를 사용하여 데이터베이스에 연결할 수도 있습니다.

어떤 GUI 클라이언트를 사용하고 있는지에 관계없이 주목해야 할 중요한 점은 컨테이너를 시작할 때 어떤 포트가 매핑되었는지입니다.

내 경우에는 localhost (`7700`) -> 컨테이너 (`3306`) 를 매핑했습니다. 따라서 데이터베이스에 연결해야 한다면 `localhost:7700` 또는 `127.0.01:7700` 에 연결해야 합니다.

### 8.1. Linux에 MySQL 워크벤치 설치

패키지 파일을 다운로드 하려면 [ 공식 사이트 ](https://dev.mysql.com/downloads/workbench/) 로 이동하세요. .deb 또는 .rpm 파일 을 다운로드하려면 운영 체제를 선택해야 합니다.
> Fedora 38 (x86, 64-bit), RPM Package  8.0.34  36.7M  [ Download ] 👈 선택
> (mysql-workbench-community-8.0.34-1.fc38.x86_64.rpm)  MD5: 6ce1e5a83d831434d9fba36b4927d969
> Fedora 38 (x86, 64-bit), RPM Package Debug Information  8.0.34  47.1M  
[ Download ]
> (mysql-workbench-community-debuginfo-8.0.34-1.fc38.x86_64.rpm)  MD5: a92ac950f0370846be6f5e698c75ede1

```
sudo dnf install ~/다운로드/mysql-workbench-community-8.0.34-1.fc38.x86_64.rpm
```
설치가 완료되면 메뉴나 대시보드에서 mysql Workbench를 시작할 수 있습니다.

### 8.2. MySQL 데이터베이스에 연결

Docker 컨테이너 내부에서 실행되는 데이터베이스에 연결합니다. 컨테이너 설정 방법에 따라 `localhost:3306` 또는 `localhost:<port-no>` 연결 을 시도해야 합니다.

데이터베이스에 연결하기 전에 "Test Connection" 를 눌러 MySQL 워크벤치가 데이터베이스 인스턴스에 성공적으로 연결할 수 있는지 확인할 수 있습니다.

## Excel을 MySQL로 가져오기: 4가지 쉬운 방법
by Dhanashree Published: & Updated:  Apr 4, 2023 https://nanonets.com/blog/import-excel-into-mysql/

### 방법 1: LOAD DATA INFILE 사용

가장 효율적인 방법 중 하나는 LOAD DATA 문을 사용하는 것입니다. 이 방법에서는 먼저 Excel 파일을 CSV 형식으로 변환한 다음 LOAD DATA 문을 사용하여 이를 MySQL 테이블로 가져와야 합니다.

#### (1단계): Excel 파일을 CSV 형식으로 변환
#### (2단계) MySQL Workbench를 열고 MySQL 서버에 연결
#### (3단계) LOAD DATA 문 입력
MySQL Workbench에 LOAD DATA 문을 입력하여 CSV 파일을 MySQL 테이블로 가져옵니다. LOAD DATA 문 구문은 다음과 같습니다.
```
LOAD DATA INFILE 'file_path/file_name.csv' -- csv 파일경로와 파일이름.
INTO TABLE table_name -- 담을 MySQL 테아블 이름.
FIELDS TERMINATED BY ',' -- 필드를 구분하는 기호.
ENCLOSED BY '"' -- 텍스트 구분 기호.
LINES TERMINATED BY '\n' -- 줄의 종결자.
IGNORE 1 ROWS; -- CSV 파일의 헤더 행 (1행) 을 건너뛰기.
```

#### (4단계): LOAD DATA 문을 실행합니다.


### 방법 2: MySQL Workbench 사용

MySQL Workbench는 MySQL 데이터베이스 관리에 널리 사용되는 도구이며 Excel을 포함한 다양한 소스에서 데이터를 가져오기 위한 사용하기 쉬운 인터페이스를 제공합니다. 

1. MySQL Workbench를 열고 MySQL 서버에 연결합니다.
1. 기본 메뉴에서 서버를 클릭한 다음 데이터 가져오기를 클릭하세요.
1. 데이터 가져오기 창에서 자체 포함 파일에서 가져오기를 선택하고 Excel 파일의 위치를 ​​찾습니다.
1. 대상 스키마에서 데이터를 가져올 데이터베이스를 선택합니다.
1. 기본 대상 개체 옵션에서 새 테이블 만들기를 선택하고 가져온 데이터를 보관할 새 테이블의 이름을 입력합니다.
1. 고급 옵션에서 Excel 파일에 열 머리글이 있는 경우 첫 번째 행을 열 이름으로 사용을 선택합니다.
1. 가져오기 시작을 클릭하여 가져오기 프로세스를 시작합니다.
1. 가져오기 프로세스가 완료될 때까지 기다립니다. Excel 파일의 크기와 가져온 데이터의 양에 따라 시간이 걸릴 수 있습니다.
1. 가져오기가 완료되면 데이터를 성공적으로 가져왔음을 확인하는 메시지가 표시됩니다.

### 방법 3: 프로그래밍 언어 사용: Apache 또는 Pandas

Apache와 Pandas는 Excel 데이터를 MySQL 데이터베이스로 가져오는 데 널리 사용되는 두 가지 도구입니다. Apache는 대규모 데이터 세트를 처리하는 확장 가능하고 효율적인 방법을 제공하는 오픈 소스 데이터 처리 도구입니다. 그리고 Pandas는 사용하기 쉬운 데이터 구조와 데이터 분석 도구를 제공하는 Python 라이브러리입니다.

#### (1) 아파치 사용

1. 다음 명령을 실행하여 필수 종속성을 설치합니다.
```
pip install apache-airflow[mysql]
```

2. 새 Python 파일을 열고 필요한 라이브러리를 가져옵니다.
```
import pandas as pd
from sqlalchemy import create_engine
```

3. read_excel() 함수를 사용하여 Excel 데이터를 pandas DataFrame에 로드합니다.
```
df = pd.read_excel('filename.xlsx')
```

4. create_engine() 함수를 사용하여 MySQL 데이터베이스에 대한 연결을 만듭니다.
```
engine = create_engine('mysql://username:password@host/database')
Use the to_sql() function to write the DataFrame to the MySQL database
df.to_sql(name='table_name', con=engine, if_exists='append', index=False)
```

#### (2) 팬더 사용:

1. 다음 명령을 실행하여 필수 종속성을 설치합니다.
```
pip install pandas mysql-connector-python
```

2. 새 Python 파일을 열고 필요한 라이브러리를 가져옵니다.
```
import pandas as pd
import mysql.connector
```

3. read_excel() 함수를 사용하여 Excel 데이터를 pandas DataFrame에 로드합니다.
```
df = pd.read_excel('filename.xlsx')
```

4. mysql.connector.connect() 함수를 사용하여 MySQL 데이터베이스에 대한 연결을 만듭니다.
```
connection = mysql.connector.connect(host='hostname',
user='username',
password='password',
database='database')
```

5. 커서 개체를 만들고 SQL 쿼리를 실행하여 MySQL 테이블에 데이터를 삽입합니다.
```
cursor = connection.cursor()
query = 'INSERT INTO table_name (column1, column2, column3) VALUES (%s, %s, %s)'
for row in df.itertuples():
cursor.execute(query, (row.column1, row.column2, row.column3))
connection.commit()
```

6. filename.xlsx, 사용자 이름, 비밀번호, 호스트, 데이터베이스, table_name, 컬럼1, 컬럼2, 컬럼3을 사용 사례에 적합한 값으로 바꿔야 합니다.

```
DOCKER_NAME="xlsmycon" ; DATABASE_NAME="medicare" ; TABLE_NAME="jaego" ; USER_NAME="hanuj"

sudo docker exec -it ${DOCKER_NAME} mysql -u root -p # <---- (1) Enter password: 가 나오면, GENERATED ROOT PASSWORD 를 여기에 붙여넣기 합니다.

alter user 'root'@'%' identified by '<>-<>-<>' ; -- '<>-<>-<>' 자리에 비번을 넣습니다.

grant all privileges on *.* to 'root'@'%' with grant option ;

create database if not exists ${DATABASE_NAME} character set utf8 ;

create user '${USER_NAME}'@'%' identified by '<>-<>-<>' ;
grant all privileges on *.* to '${USER_NAME}'@'%' with grant option ;

sudo docker exec -it ${DOCKER_NAME} /bin/bash ;
sudo docker restart ${DOCKER_NAME} ;
sudo docker ps -a ;
```

# 230902 토

1. 촛불집회전 시청광장 이재명지사 행진 (서울시의회 앞, 코리아나호텔+조선일보 옆)
![ 시청광장 집회참석 이재명지사 ](/ilji/2023-09/230902-시청광장-이재명대표.webp)
출처: 해민 핸폰

# 230901 금
1030 푸른숲

1. ss핸폰에서 푸른숲 와이파이 인식안됨.
1. 오픈 소스 원격 데스크톱이자 TeamViewer의 대안입니다. rustdesk.com https://github.com/rustdesk/rustdesk?ref=itsfoss.com
┏━┳┓
┃╌┃┃🇰🇷
┣━╋┫
┗━┻┛

### `날짜 역순` 으로 `한달치만` 기록하고, 달이 바뀌면 다음과 같이 처리한다. 
1. Page Action --> Move/Rename --> Pages 에서 옮기려는 `2023-09 일지` 를 클릭 --> 아랫쪽 `[en v]`옆의 Path 에 `/ ilji/2309` 입력하고 --> `[v Select]` 클릭해서  파일 이름을 바꾼다. 
1. 다시 불러오기 `Ctrl + R` 하면 --> 윗작업의 결과로 `"/ home"` 파일이 `"/ ilji/2309"` 파일로 바뀌었기 때문에 `"/ home"` 파일이 없으므로 --> 나온 화면에서 `[+ CREATE HOME PAGE]` 를 누른 다음,
Title:
`2023-10 일지`
Short:
`작성중`
Path:
`/ home`
으로 지정해서 `"/ home"` 파일을 새로 만든다. 
1. HP ENVY-7640 printer 인쇄시 (레이아웃 `세로방향` / 설정 더보기 > 용지 크기 (`A4`) / 시트당 페이지 수 (`1`) / 여백 맞춤 > 상하 `10m/m`, 좌우 `5m/m` / 양면 `[v]`양면에 인쇄 / `[-]` 위로 넘김)

✨
✨

### Zoom 테스트
Zoom 테스트 미팅 https://support.zoom.us/hc/ko-kr/articles/115002262083-Zoom-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AF%B8%ED%8C%85-%EC%B0%B8%EC%97%AC%ED%95%98%EA%B8%B0

남양주평생학습포털다산서당
https://dasanedu.nyj.go.kr/home/myLectureList.do

1. 💗❤️💚🐾📌😊😃😝🤣🤗🌞🔥🍊🍓●➡️➜🔎📈🔽✅⌚⭐❱❱💡🔋🔉💸
💰🎁1️⃣2️⃣3️⃣🔗👈👉🔼🎨👀🚀🎯💰🔑⚡☕💬🎂✨🧩🛍️🚩🐈🐾🐱🐕
🐒 🎗 ☢️️️️ 👹 🌙 
🇰🇷🌳🚲🔵🚙🔱 ✍

💗 ❤️ 💚 🐾 📌 😊 😃 😝 🤣 🤗 🌞 🔥 🍊 🍓 ● ➡️ ➜ 🔎 📈 🔽 ✅
⌚ ⭐ ❱ ❱ 💡 🔋 🔉 💸 💰 🎁 1️⃣ 2️⃣ 3️⃣ 🔗 👈 👉 🔼 🎨 👀 🚀 🎯
💰 🔑 ⚡ ☕ 💬 🎂 ✨ 🧩 🛍️ 🚩 🐈 🐾 🐱 🐕 🐒 🎗 ☢️️️️ 👹 🌙 🇰🇷
🌳 🚲 🔵 🚙 🔱

💗❤️💚🐾📌😊😃😝🤣🤗🌞🔥🍊🍓●➡️➜🔎📈🔽✅⌚⭐❱❱💡🔋🔉💸
💰🎁1️⃣2️⃣3️⃣🔗👈👉🔼🎨👀🚀🎯💰🔑⚡☕💬🎂✨🧩🛍️🚩🐈🐾🐱🐕
🐒🎗☢️️️️👹🌙🇰🇷🌳🚲🔵🚙🔱

🎵   🎶   🔔   📢   🖍️   

📌 유니코드 상자그리기 기호 wepplication.github.io/tools/charMap/#unicode-2500-257F
📌 이모지 https://wepplication.github.io/tools/charMap/#emoji
📌 특수문자 이모티콘 모음 https://wepplication.github.io/tools/charMap/#specialChar

✨
✨

1. (2018-08 178.p) Kotlin Quick Start Guide By Marko Devcic $25.99 Publication ISBN 9781789344189 https://subscription.packtpub.com/book/programming/9781789344189/1
1. (2022-03 184.p) Kotlin 다중 플랫폼 모바일로 애플리케이션 개발 간소화 로베르트 나기 https://subscription.packtpub.com/book/programming/9781801812580/3
1. (2018-05 310.p) Spring 5 및 Kotlin으로 애플리케이션 구축
작업 환경 준비 https://subscription.packtpub.com/book/web-development/9781788394802/1/ch01lvl1sec05/preparing-the-working-environment
1. (2019-01 392.p) Android 애플리케이션 개발을 위한 Spring 배우기
(4) Android용 스프링 모듈 https://subscription.packtpub.com/book/programming/9781789349252/4
1. (2022-12 270.p) Spring Boot 3.0 학습 - 제3판 그렉 L. 턴키 스트 $35.99 ISBN 9781803233307 https://subscription.packtpub.com/book/web-development/9781803233307/2/ch02lvl1sec03/technical-requirements
1. Build RESTful APIs Using Kotlin and Spring Boot [Video] By Dilip Sundarraj $49.99 Video https://subscription.packtpub.com/video/web-development/9781804616451/p10/video10_6/integration-test-for-the-get-endpoint-to-retrieve-all-the-courses
1. Jetpack 및 Kotlin을 사용하여 최신 Android 개발을 시작하세요. https://subscription.packtpub.com/book/mobile/9781801811071/pref
1. Jetpack Compose를 사용한 Android UI 개발 https://subscription.packtpub.com/book/business-and-other/9781801812160/1
git clone https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose.git
1. LibreOffice Calc Guide 7.2 https://books.libreoffice.org/en/CG72/CG72.html

