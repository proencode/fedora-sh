
| ≪ [ 104 Creating a RESTful Web Service with Spring Boot ](/books/packtpub/2024/1202-Spring_Boot_3_React/104) | 105 Securing Your Backend | [ 106 Testing Your Backend ](/books/packtpub/2024/1202-Spring_Boot_3_React/106) ≫ |
|:----:|:----:|:----:|

# 105 Securing Your Backend

This chapter explains how to secure your Spring Boot backend. Securing your backend is a crucial part of code development. It is essential for protecting sensitive data, complying with regulations, and preventing unauthorized access. The backend often handles the user authentication and authorization process. Securing these aspects properly ensures that only authorized users can access the application and perform specific actions. We will use the database application that we created in the previous chapter as a starting point.

In this chapter, we will cover the following topics:

Understanding Spring Security
Securing your backend with a JSON Web Token
Role-based security
Using OAuth2 with Spring Boot
Technical requirements
The Spring Boot application that we created in the previous chapters is required.

The following GitHub link will also be required: https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05.

Understanding Spring Security
Spring Security (https://spring.io/projects/spring-security) provides security services for Java-based web applications. The Spring Security project was started in 2003 and was previously named Acegi Security System for Spring.

By default, Spring Security enables the following features:

An AuthenticationManager bean with an in-memory single user. The username is user and the password is printed to the console output.
Ignored paths for common static resource locations, such as /css and /images. HTTP basic authentication for all other endpoints.
Security events published to Spring’s ApplicationEventPublisher interface.
Common low-level features turned on by default, including HTTP Strict Transport Security (HSTS), cross-site scripting (XSS), and cross-site request forgery (CSRF).
A default autogenerated login page.
You can include Spring Security in your application by adding the following highlighted dependencies to the build.gradle file. The first dependency is for the application and the second is for testing:

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-rest'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
}

Copy

Explain
If you haven’t enabled automatic refresh, remember to refresh the Gradle project from Eclipse after you have modified your build.gradle file.

When you start your application, you can see from the console that Spring Security has created an in-memory user with a username of user. The user’s password can be seen in the console output, as illustrated here:


Figure 5.1: Spring Security enabled

If there is no password in the console, try to restart your project by pressing the red Terminate button in the console and re-running it.

The Eclipse console has limited output, and the default buffer size is 80,000 characters, so the output might be truncated before the password statement can appear. You can change this setting from the Window | Preferences | Run/Debug | Console menu.

Now, if you make a GET request to your REST API root endpoint, you will see that it has been secured. Open your web browser and navigate to http://localhost:8080/api. You will be redirected to the Spring Security default login page, as illustrated in the following screenshot:


Figure 5.2: Secured REST API

To be able to make a successful GET request, we have to authenticate to our RESTful API. Type user into the Username field and copy the generated password from the console to the Password field. With authentication, we can see that the response contains our API resources, as illustrated in the following screenshot:


Figure 5.3: Basic authentication

To configure how Spring Security behaves, we have to add a new configuration class for Spring Security. The security configuration file can be used to define which URLs or URL patterns are accessible to which roles or users. You can also define the authentication mechanism, the login process, session management, and so on.

Create a new class called SecurityConfig in your application root package (com.packt.cardatabase). The following source code shows the structure of the security configuration class:

package com.packt.cardatabase;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.
  EnableWebSecurity;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
}

Copy

Explain
The @Configuration and @EnableWebSecurity annotations switch off the default web security configuration, and we can define our own configuration in this class. Inside the filterChain(HttpSecurity http) method that we will see in action later, we can define which endpoints in our application are secure and which are not. We don’t actually need this method yet because we can use the default settings where all the endpoints are secured.

We can also add in-memory users to our application by using Spring Security’s InMemoryUserDetailsManager, which implements UserDetailsService. Then we can implement user/password authentication that is stored in memory. We can also use PasswordEncoder to encode passwords using the bcrypt algorithm.

The following highlighted source code will create an in-memory user with a username of user, a password of password, and a role of USER:

// SecurityConfig.java
package com.packt.cardatabase;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.
  EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.builder().username("user").
            password(passwordEncoder().encode("password"))
            .roles("USER").build();
        return new InMemoryUserDetailsManager(user);
    }
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

Copy

Explain
Now, restart the application, and you will be able to test authentication using the in-memory user. The use of in-memory users is fine in the development phase, but a proper application should save users in the database.

To save users to the database, you have to create a user entity class and repository. Passwords shouldn’t be saved to the database in plaintext format. If a database containing user passwords is hacked, attackers will be able to get the passwords directly in plaintext. Spring Security provides multiple hashing algorithms, such as bcrypt, that you can use to hash passwords. The following steps show you how to implement this:

Create a new class called AppUser in the com.packt.cardatabase.domain package. Activate the domain package and right-click it. Select New | Class from the menu and name the new class User. After that, your project structure should look like this:

Figure 5.4: Project structure

Annotate the AppUser class with the @Entity annotation. Add the ID, username, password, and role class fields. Finally, add the constructors, getters, and setters. We will set all the fields to be not nullable. This means that database columns cannot hold null values. We will also specify that the username must be unique by using unique=true in the username’s @Column annotation. Refer to the following AppUser.java source code for the fields:
package com.packt.cardatabase.domain;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
@Entity
public class AppUser {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    @Column(nullable=false, updatable=false)
    private Long id;
    
    @Column(nullable=false, unique=true)
    private String username;
       
    @Column(nullable=false)
    private String password;
    
    @Column(nullable=false)
    private String role;
    
// Constructors, getters and setters    
}

Copy

Explain
Here is the AppUser.java constructors source code:

    public AppUser() {}
    public AppUser(String username, String password, String role) {
        super();
        this.username = username;
        this.password = password;
        this.role = role;
    }

Copy

Explain
Here is the AppUser.java source code with the getters and setters:

    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }

Copy

Explain
Create a new interface called AppUserRepository in the domain package. To do this, activate the domain package and right-click it. Select New | Interface from the menu and name it AppUserRepository.
The source code for the repository class is similar to what we saw in the previous chapter, but there is one query method, findByUsername, that we need for the steps that follow. This method is used to find a user from the database in the authentication process. The method returns Optional to prevent a null exception. Refer to the following AppUserRepository source code:

package com.packt.cardatabase.domain;
import java.util.Optional;
import org.springframework.data.repository.CrudRepository;
public interface AppUserRepository extends CrudRepository
   <AppUser, Long> {
    Optional<AppUser> findByUsername(String username);
  }

Copy

Explain
Next, we will create a class that implements the UserDetailsService interface that’s provided by Spring Security. Spring Security uses this for user authentication and authorization. Create a new service package in the root package. To do this, activate the root package and right-click it. Select New | Package from the menu and name the new package service, as illustrated in the following screenshot:

Figure 5.5: The service package

Create a new class called UserDetailsServiceImpl in the service package we just created. Now, your project structure should look like this (in Eclipse, refresh the Project Explorer by pressing F5):

Figure 5.6: Project structure

We have to inject the AppUserRepository class into the UserDetailsServiceImpl class because it is needed to fetch the user from the database when Spring Security handles authentication. The findByUsername method that we implemented earlier returns Optional, therefore we can use the isPresent() method to check if the user exists. If the user doesn’t exist, we throw a UsernameNotFoundException exception. The loadUserByUsername method returns the UserDetails object, which is required for authentication. We are using the Spring Security UserBuilder class to build the user for the authentication. Here is the source code for UserDetailsServiceImpl.java:
package com.packt.cardatabase.service;
import java.util.Optional;
import org.springframework.security.core.userdetails.User.
  UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.
  UserDetailsService;
import org.springframework.security.core.userdetails.
  UsernameNotFoundException;
import org.springframework.stereotype.Service;
import com.packt.cardatabase.domain.AppUser;
import com.packt.cardatabase.domain.AppUserRepository;
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
  private final AppUserRepository repository;
public UserDetailsServiceImpl(AppUserRepository repository) {
    this.repository = repository;
}
    @Override
    public UserDetails loadUserByUsername(String username) throws
    UsernameNotFoundException {
        Optional<AppUser> user = repository.findByUsername(username);
        UserBuilder builder = null;
        if (user.isPresent()) {
            AppUser currentUser = user.get();
            builder = org.springframework.security.core.userdetails.
                      User.withUsername(username);
            builder.password(currentUser.getPassword());
            builder.roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User not found.");
        }
        return builder.build();
    }
}

Copy

Explain
In our security configuration class, we have to specify that Spring Security should use users from the database instead of in-memory users. Delete the userDetailsService() method from the SecurityConfig class to disable in-memory users. Add a new configureGlobal method to enable users from the database.

We should never save the password as plaintext to the database. Therefore, we will define a password hashing algorithm in the configureGlobal method. In this example, we are using the bcrypt algorithm. This can be easily implemented with the Spring Security BCryptPasswordEncoder class, which encodes a hashed password during the authentication process. Here is the SecurityConfig.java source code:

package com.packt.cardatabase;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.
  authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.
  web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.
  BCryptPasswordEncoder;
import com.packt.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.security.crypto.password.PasswordEncoder;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    public SecurityConfig(UserDetailsServiceImpl userDetailsService) {
        this.userDetailsService = userDetailsService;
    }
  public void configureGlobal (AuthenticationManagerBuilder auth)
    throws Exception {
      auth.userDetailsService(userDetailsService)
      .passwordEncoder(new BCryptPasswordEncoder());
    }
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

Copy

Explain
Now, the password must be hashed using bcrypt before it’s saved to the database.

Finally, we can save a couple of test users to the database using the CommandLineRunner interface. Open the CardatabaseApplication.java file and inject AppUserRepository into the main class:
private final CarRepository repository;
private final OwnerRepository orepository;
private final AppUserRepository urepository;
public CardatabaseApplication(CarRepository repository, OwnerRepository orepository, AppUserRepository urepository) {
    this.repository = repository;
    this.orepository = orepository;
    this.urepository = urepository;
}

Copy

Explain
Let’s save two users to the database with bcrypt hashed passwords. You can find bcrypt calculators or generators on the internet. These generators allow you to input a plaintext password, and they will produce the corresponding bcrypt hash:
    @Override
    public void run(String... args) throws Exception {
        // Add owner objects and save these to db
        Owner owner1 = new Owner("John", "Johnson");
        Owner owner2 = new Owner("Mary", "Robinson");
        orepository.saveAll(Arrays.asList(owner1, owner2));
        repository.save(new Car(
                            "Ford", "Mustang", "Red", "ADF-1121",
                             2023, 59000, owner1));
        repository.save(new Car(
                            "Nissan", "Leaf", "White", "SSJ-3002",
                            2020, 29000, owner2));
        repository.save(new Car(
                            "Toyota", "Prius", "Silver", "KKO-0212",
                            2022, 39000, owner2));
        // Fetch all cars and log to console
        for (Car car : repository.findAll()) {
            logger.info(car.getBrand() + " " + car.getModel());
        }
        // Username: user, password: user
        urepository.save(new AppUser("user",
            "$2a$10$NVM0n8ElaRgg7zWO1CxUdei7vWoPg91Lz2aYavh9.
            f9q0e4bRadue","USER"));
        // Username: admin, password: admin
        urepository.save(new AppUser("admin",
            "$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.
            mP9vpMu0ssKi8GW", "ADMIN"));
    }

Copy

Explain
bcrypt is a strong hashing function that was designed by Niels Provos and David Mazières. Here is an example of a bcrypt hash that is generated from the admin string:

$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW

$2a represents the algorithm version, and $10 represents the strength of the algorithm. The default strength of Spring Security’s BcryptPasswordEncoder class is 10. bcrypt generates a random salt in hashing, so the hashed result is always different.

After running your application, you will see that there is now an app_user table in the database and that two user records are saved with hashed passwords, as illustrated in the following screenshot:

Figure 5.7: Users

Now, you should restart the application and you will get a 401 Unauthorized error if you try to send a GET request to the http://localhost:8080/api path without authentication. You must authenticate to be able to send a successful request. The difference, when compared with the previous example, is that we are using the users from the database to authenticate.
Now, you can log in by sending a GET request to the /api endpoint using the browser, or we can use Postman and basic authentication, as shown in the following screenshot:


Figure 5.8: GET request authentication

You can see that we currently get users by calling the api/appUsers endpoint in our RESTful web service, which is something we want to avoid. As mentioned in Chapter 4, Spring Data REST generates a RESTful web service from all public repositories by default. We can use the exported flag of the @RepositoryRestResource annotation and set it to false, which means the following repository is not exposed as a REST resource:
package com.packt.cardatabase.domain;
import java.util.Optional;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.rest.core.annotation.
  RepositoryRestResource;
@RepositoryRestResource(exported = false)
public interface AppUserRepository extends CrudRepository
   <AppUser, Long> {
    Optional<AppUser> findByUsername(String username);
  }

Copy

Explain
Now, if you restart the application and send a GET request to the /api endpoint, you will see that the /appUsers endpoint is not visible anymore.
Next, we will start to implement authentication using a JSON Web Token.

Securing your backend with a JSON Web Token
In the previous section, we covered how to use basic authentication with a RESTful web service. Basic authentication doesn’t provide a way to handle tokens or manage sessions. When a user logs in, the credentials are sent with each request, which can cause session management challenges and potential security risks. This method is not usable when we develop our own frontend with React, so we are going to use JSON Web Token (JWT) authentication instead (https://jwt.io/). This will also give you an idea of how you can configure Spring Security in more detail.

The other option for securing your RESTful web service is OAuth 2. OAuth2 (https://oauth.net/2/) is the industry standard for authorization and it can be used quite easily in Spring Boot applications. There is a section later on in the chapter that will give you a basic idea about how to use it in your applications.

JWTs are commonly used in RESTful APIs for authentication and authorization purposes. They are a compact way to implement authentication in modern web applications. A JWT is really small in size and can therefore be sent in the URL, in the POST parameter, or inside the header. It also contains all the necessary information about the user, such as their username and role.

A JWT contains three different parts, separated by dots: xxxxx.yyyyy.zzzzz. These parts are broken up as follows:

The first part (xxxxx) is the header, which defines the type of token and the hashing algorithm.
The second part (yyyyy) is the payload, which, typically, in the case of authentication, contains user information.
The third part (zzzzz) is the signature, which is used to verify that the token hasn’t been changed along the way.
Here is an example of a JWT:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Copy

Explain
The following diagram shows a simplified representation of the authentication process using a JWT:


Figure 5.9: JWT authentication process

After successful authentication, the requests sent by the client should always contain the JWT that was received in the authentication.

We will use jjwt (https://github.com/jwtk/jjwt), which is the JWT library for Java and Android for creating and parsing JWTs. Therefore, we have to add the following dependencies to the build.gradle file:

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-rest'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5', 'io.jsonwebtoken:jjwt-
      jackson:0.11.5'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
}

Copy

Explain
Remember to refresh the Gradle project from Eclipse after you have updated the dependencies.

The following steps demonstrate how to enable JWT authentication in our backend.

Securing the login
We will start with the login functionality:

First, we will create a class that generates and verifies a signed JWT. Create a new class called JwtService in the com.packt.cardatabase.service package. At the beginning of the class, we will define a few constants: EXPIRATIONTIME defines the expiration time of the token in milliseconds, PREFIX defines the prefix of the token, and the "Bearer" schema is typically used. A JWT is sent in the Authorization header and the content of the header looks like the following when using the Bearer schema:
Authorization: Bearer <token>

Copy

Explain
The JwtService source code looks like the following:

package com.packt.cardatabase.service;
import org.springframework.stereotype.Component;
@Component
public class JwtService {
  static final long EXPIRATIONTIME = 86400000;   // 1 day in ms. Should be shorter in production.
  static final String PREFIX = "Bearer";
}

Copy

Explain
We will create a secret key using the jjwt library’s secretKeyFor method. This is only for demonstration purposes. In a production environment, you should read your secret key from the application configuration. The getToken method then generates and returns the token. The getAuthUser method gets the token from the response Authorization header. Then, we will use the parserBuilder method provided by the jjwt library to create a JwtParserBuilder instance. The setSigningKey method is used to specify a secret key for token verification. The parseClaimsJws method removes the Bearer prefix from the Authorization header. Finally, we will use the getSubject method to get the username. The whole JwtService source code follows:
package com.packt.cardatabase.service;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import java.security.Key;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import jakarta.servlet.http.HttpServletRequest;
import java.util.Date;
@Component
public class JwtService {
  static final long EXPIRATIONTIME = 86400000;   // 1 day in ms. Should be shorter in production.
  static final String PREFIX = "Bearer";
  // Generate secret key. Only for demonstration purposes.
  // In production, you should read it from the application   // configuration.
  static final Key key = Keys.secretKeyFor (SignatureAlgorithm.    HS256);
  // Generate signed JWT token
  public String getToken(String username) {
    String token = Jwts.builder()
    .setSubject(username)
    .setExpiration(new Date(System.currentTimeMillis() +                            EXPIRATIONTIME))
    .signWith(key)
    .compact();  
    return token;
  }
  // Get a token from request Authorization header,
  // verify the token, and get username
  public String getAuthUser(HttpServletRequest request) {
    String token = request.getHeader
        (HttpHeaders.AUTHORIZATION);
    if (token != null) {
      String user = Jwts.parserBuilder()
      .setSigningKey(key)
      .build()
      .parseClaimsJws(token.replace(PREFIX, ""))
      .getBody()
      .getSubject();
      if (user != null)
        return user;
    }
    return null;
  }
}

Copy

Explain
Next, we will add a new class to store credentials for authentication. Here we can use a Java record, which was introduced in Java 14. A record is a good choice if you need a class that only holds data; you can avoid a lot of boilerplate code. Create a new record (New | Record) called AccountCredentials in the com.packt.cardatabase.domain package:

Figure 5.10: Create a new record

The record has two fields: username and password. Here is the source code for the record. As you can see, we don’t have to write getters and setters when using it:

package com.packt.cardatabase.domain;
public record AccountCredentials(String username, String password) {}

Copy

Explain
Now, we will implement the controller class for login. Login is done by calling the /login endpoint using the POST method and sending the username and password inside the request body. Create a class called LoginController inside the com.packt.cardatabase.web package. We have to inject a JwtService instance into the controller class because that is used to generate a signed JWT in the case of a successful login. The code is illustrated in the following snippet:
package com.packt.cardatabase.web;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import com.packt.cardatabase.domain.AccountCredentials;
import com.packt.cardatabase.service.JwtService;
@RestController
public class LoginController {
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;
    public LoginController(JwtService jwtService,
      AuthenticationManager authenticationManager) {
        this.jwtService = jwtService;
        this.authenticationManager = authenticationManager;
    }
    @PostMapping("/login")
    public ResponseEntity<?> getToken(@RequestBody
      AccountCredentials credentials) {
    // Generate token and send it in the response Authorization
    // header
    }
}

Copy

Explain
Next, we will implement the getToken method that handles the login functionality. We get a JSON object from the request body that contains the username and password. AuthenticationManager is used to perform authentication and it uses credentials that we get from the request. Then, we use the JwtService class’ getToken method to generate a JWT. Finally, we build an HTTP response that contains the generated JWT in the Authorization header:
// LoginController.java
@PostMapping("/login")
public ResponseEntity<?> getToken(@RequestBody AccountCredentials
   credentials) {
    UsernamePasswordAuthenticationToken creds = new
      UsernamePasswordAuthenticationToken(credentials.username(),                                          credentials.password());
    Authentication auth = authenticationManager.authenticate(creds);
    // Generate token
    String jwts = jwtService.getToken(auth.getName());
    // Build response with the generated token
    return ResponseEntity.ok().header(HttpHeaders.AUTHORIZATION,
                   "Bearer" + jwts).header(HttpHeaders.
                   ACCESS_CONTROL_EXPOSE_HEADERS,
                   "Authorization").build();
}

Copy

Explain
We have also injected AuthenticationManager into the LoginController class, therefore we have to add the following highlighted code to the SecurityConfig class:
package com.packt.cardatabase;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.  authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.  authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.  authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import com.packt.cardatabase.service.UserDetailsServiceImpl;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    public SecurityConfig(UserDetailsServiceImpl userDetailsService){
        this.userDetailsService = userDetailsService;
    }
    public void configureGlobal(AuthenticationManagerBuilder auth)
      throws Exception {
        auth.userDetailsService(userDetailsService)
          .passwordEncoder(new BCryptPasswordEncoder());
    }
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager uthenticationManager(
      AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
}

Copy

Explain
In this step, we have to configure Spring Security functionality. Spring Security’s SecurityFilterChain bean defines which paths are secured and which are not. Add the following filterChain method to the SecurityConfig class. In the method, we define that the POST method request to the /login endpoint is allowed without authentication and that requests to all other endpoints require authentication. We will also define that Spring Security will never create a session, and therefore we can disable cross-site request forgery (csrf). JWTs are designed to be stateless, which reduces the risk of session-related vulnerabilities. We will use Lambdas in the HTTP security configuration:
In some other programming languages, Lambdas are called anonymous functions. The usage of Lambdas makes code more readable and reduces boilerplate code.

// SecurityConfig.java
// Add the following import
import org.springframework.security.web.SecurityFilterChain;
// Add filterChain method
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws
  Exception {
    http.csrf((csrf) -> csrf.disable())
        .sessionManagement((sessionManagement) -> sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) ->            authorizeHttpRequests.requestMatchers(HttpMethod.POST,            "/login").permitAll().anyRequest().authenticated());
    return http.build();
}

Copy

Explain
Finally, we are ready to test our login functionality. Open Postman and make a POST request to the http://localhost:8080/login URL. Define a valid user inside the request body, for example, {"username":"user", "password":"user"} and select JSON from the drop-down list. Postman will then set the Content-Type header to application/json automatically. You should check from the Headers tab that the Content-Type header is set correctly. Now, you should see an Authorization header in the response that contains the signed JWT, like the one shown in the following screenshot:

Figure 5.11: Login request

You can also test the login by using the wrong password and seeing that the response doesn’t contain the Authorization header.

Securing the other requests
We have now finalized the login step, and we will move on to handling authentication for the rest of the incoming requests. In the authentication process, we are using filters that allow us to perform some operations before a request goes to the controller or before a response is sent to a client.

The following steps demonstrate the rest of the authentication process:

We will use a filter class to authenticate all other incoming requests. Create a new class called AuthenticationFilter in the root package. The AuthenticationFilter class extends Spring Security’s OncePerRequestFilter interface, which provides a doFilterInternal method where we implement our authentication. We have to inject a JwtService instance into the filter class because it is needed to verify a token from the request. The SecurityContextHolder is where Spring Security stores the details of the authenticated user. The code is illustrated in the following snippet:
package com.packt.cardatabase;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import com.packt.cardatabase.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
@Component
public class AuthenticationFilter extends OncePerRequestFilter {
    private final JwtService jwtService;
    public AuthenticationFilter(JwtService jwtService) {
        this.jwtService = jwtService;
   }
    @Override
    protected void doFilterInternal(HttpServletRequest request,               HttpServletResponse response, FilterChain filterChain)
            throws ServletException, java.io.IOException {
        // Get token from the Authorization header
        String jws = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (jws != null) {
            // Verify token and get user
            String user = jwtService.getAuthUser(request);
            // Authenticate
            Authentication authentication =
            new UsernamePasswordAuthenticationToken(user, null,
                java.util.Collections.emptyList());
            SecurityContextHolder.getContext()
                .setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }
}

Copy

Explain
Next, we have to add our filter class to the Spring Security configuration. Open the SecurityConfig class and inject the AuthenticationFilter class that we just implemented, as shown in the highlighted code:
private final UserDetailsServiceImpl userDetailsService;
private final AuthenticationFilter authenticationFilter;
public SecurityConfig(UserDetailsServiceImpl userDetailsService,AuthenticationFilter authenticationFilter) {
    this.userDetailsService = userDetailsService;
    this.authenticationFilter = authenticationFilter;
}

Copy

Explain
Then, modify the filterChain method in the SecurityConfig class and add the following lines of code:
//Add the following import
import org.springframework.security.web.authentication.  UsernamePasswordAuthenticationFilter;
// Modify the filterChain method
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws   Exception {
    http.csrf((csrf) -> csrf.disable())
        .sessionManagement((sessionManagement) -> sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) ->            authorizeHttpRequests.requestMatchers(HttpMethod.POST,            "/login").permitAll().anyRequest().authenticated())
        .addFilterBefore(authenticationFilter,            UsernamePasswordAuthenticationFilter.class);
    return http.build();
}

Copy

Explain
Now, we are ready to test the whole workflow. After we run the application, we can first log in by calling the /login endpoint with the POST method and, in the case of a successful login, we will receive a JWT in the Authorization header. Remember to add a valid user inside the body and set the Content-Type header to application/json if it is not done automatically by Postman. The following screenshot illustrates the process:

Figure 5.12: Login request

Following a successful login, we can call the other RESTful service endpoints by sending the JWT that was received from the login in the Authorization header. Copy the token from the login response (without the Bearer prefix) and add the Authorization header with the token in the VALUE column. Refer to the example in the following screenshot where a GET request to the /cars endpoint is done:

Figure 5.13: Authenticated GET request

Each time the application is restarted, you must authenticate again because a new JWT is generated.

The JWT is not valid forever because an expiration date was set for it. In our case, we set a long expiration time for demonstration purposes. In production, the time should preferably be minutes, depending on the use case.

Handling exceptions
We should also handle exceptions in the authentication. At the moment, if you try to log in using the wrong password, you get a 403 Forbidden status without any further clarification. Spring Security provides an AuthenticationEntryPoint interface that can be used to handle exceptions. Let’s see how it works:

Create a new class named AuthEntryPoint in the root package that implements AuthenticationEntryPoint. We will implement the commence method, which gets an exception as a parameter. In the case of an exception, we set the response status to 401 Unauthorized and write an exception message to the response body. The code is illustrated in the following snippet:
package com.packt.cardatabase;
import java.io.IOException;
import java.io.PrintWriter;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.
  AuthenticationException;
import org.springframework.security.web.
  AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
@Component
public class AuthEntryPoint implements AuthenticationEntryPoint {
  @Override
  public void commence(
    HttpServletRequest request, HttpServletResponse response,
    AuthenticationException authException) throws IOException,
    ServletException {
        response.setStatus (HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType (MediaType.APPLICATION_JSON_VALUE);
        PrintWriter writer = response.getWriter();
        writer.println("Error: " + authException.getMessage());
  }
}

Copy

Explain
Then, we have to configure Spring Security for the exception handling. Inject our AuthEntryPoint class into the SecurityConfig class, as shown in the following highlighted code:
// SecurityConfig.java
private final UserDetailsServiceImpl userDetailsService;
private final AuthenticationFilter authenticationFilter;
private final AuthEntryPoint exceptionHandler;
public SecurityConfig(UserDetailsServiceImpl userDetailsService,   AuthenticationFilter authenticationFilter, AuthEntryPoint   exceptionHandler) {
    this.userDetailsService = userDetailsService;
    this.authenticationFilter = authenticationFilter;
    this.exceptionHandler = exceptionHandler;
}

Copy

Explain
Then, modify the filterChain method as follows:
// SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws
  Exception {
    http.csrf((csrf) -> csrf.disable())
        .sessionManagement((sessionManagement) ->
            sessionManagement.sessionCreationPolicy(
            SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) ->             authorizeHttpRequests.requestMatchers(HttpMethod.POST,            "/login").permitAll().anyRequest().authenticated())
        .addFilterBefore(authenticationFilter,            UsernamePasswordAuthenticationFilter.class)
        .exceptionHandling((exceptionHandling) -> exceptionHandling.            authenticationEntryPoint(exceptionHandler));
    return http.build();
}

Copy

Explain
Now, if you send a login POST request with the wrong credentials, you will get a 401 Unauthorized status in the response and an error message in the body, as shown in the following screenshot:

Figure 5.14: Bad credentials
Adding a CORS filter
We will also add a cross-origin resource sharing (CORS) filter to our security configuration class. CORS introduces certain headers that help the client and server decide if cross-origin requests should be allowed or denied. The CORS filter is needed for the frontend, which is sending requests from the other origin. The CORS filter intercepts requests, and if these are identified as cross-origin, it adds proper headers to the request. For that, we will use Spring Security’s CorsConfigurationSource interface.

In this example, we will allow all origins’ HTTP methods and headers. You can define a list of permissible origins, methods, and headers here if you require a more finely graded definition. Let’s begin:

Add the following imports and methods to your SecurityConfig class to enable the CORS filter:
// SecurityConfig.java
// Add the following imports
import java.util.Arrays;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
// Add Global CORS filter inside the class
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    UrlBasedCorsConfigurationSource source =
       new UrlBasedCorsConfigurationSource();
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(Arrays.asList("*"));
    config.setAllowedMethods(Arrays.asList("*"));
    config.setAllowedHeaders(Arrays.asList("*"));
    config.setAllowCredentials(false);
    config.applyPermitDefaultValues();
    source.registerCorsConfiguration("/**", config);
    return source;
}

Copy

Explain
If you want to explicitly define the origins, you can set this in the following way:

// localhost:3000 is allowed
config.setAllowedOrigins(Arrays.asList ("http://localhost:3000"));

Copy

Explain
We also have to add the cors() function to the filterChain method, as shown in the following code snippet:
// SecurityConfig.java
// Add the following static import
import static org.springframework.security.config.Customizer.withDefaults;
// Modify filterChain method
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws
  Exception {
    http.csrf((csrf) -> csrf.disable())
        .cors(withDefaults())
        .sessionManagement((sessionManagement) -> sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -> 
            authorizeHttpRequests.requestMatchers(HttpMethod.POST,            "/login").permitAll().anyRequest().authenticated())
        .addFilterBefore(authenticationFilter,            UsernamePasswordAuthenticationFilter.class)
        .exceptionHandling((exceptionHandling) -> exceptionHandling.            authenticationEntryPoint(exceptionHandler));
    return http.build();
}

Copy

Explain
Now, we have secured our backend. In the next section, we will introduce the basics of role-based security, which you can use to get more fine-grained access control in your Spring Boot application.

Role-based security
In Spring Security, roles can be used to define coarse-grained role-based security, and users can be assigned to one or multiple roles. Roles often have a hierarchical structure, for example, ADMIN, MANAGER, USER. Spring Security also provides authorities, which can be used for more fine-grained access control. We have defined simple roles for our users, ADMIN and USER, and we don’t use role-based security in our sample backend application. This section introduces the different ways to implement role-based security in your Spring Boot applications.

You can define role-based access control at the request level in your security configuration class. In the following example code, we define which endpoints require specific roles for access. The /admin/** endpoint requires the ADMIN role for access and the /user/** endpoint requires the USER role for access. We use the Spring Security hasRole() method, which returns true if the user has the specified role:

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws
   Exception {
    http.csrf((csrf) -> csrf.disable()).cors(withDefaults())
        .sessionManagement((sessionManagement) -> sessionManagement.            sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests((authorizeHttpRequests) -> 
            authorizeHttpRequests.requestMatchers("/admin/**").hasRole             ("ADMIN").requestMatchers("/user/**").hasRole("USER")
            .anyRequest().authenticated())
    return http.build();
}

Copy

Explain
You can read more about request authorization in the Spring Boot documentation: https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html.

Spring Security provides the @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter, and @Secured annotations, which are used to apply method-level security. Method-level security is not enabled by default in spring-boot-starter-security. You have to enable it in your Spring configuration class, for example, in top-level configuration, by using the @EnableMethodSecurity annotation:

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
@SpringBootApplication
@EnableMethodSecurity
public class CardatabaseApplication implements CommandLineRunner {
}

Copy

Explain
Then, you will be able to use the method-level security annotations in your methods. In the following example, users with the USER role can execute the updateCar() method and users with the ADMIN role can execute the deleteOwner() method. The @PreAuthorize annotation checks the rule before the method is executed. If the user does not have a specified role, Spring Security prevents method execution, and an AccessDeniedException is thrown:

@Service
public class CarService {
    @PreAuthorize("hasRole('USER')")
    public void updateCar(Car car) {
        // This method can be invoked by user with USER role.
    }
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteOwner(Car car) {
        // This method can be invoked by user with ADMIN role.
    }
}

Copy

Explain
The @PreAuthorize annotation replaces the @Secured annotation, and its use is recommended instead.

The @PostAuthorize annotation can be used to check authorization after the method is executed. You can use this, for example, to check that the user has permission to access the object that the method returns, or you can filter the data returned based on the user’s authorization.

The @PreFilter and @PostFilter annotations can be used to filter lists of objects, but they are not typically used for role-based access control. The rules used with these annotations are more fine-grained.

You can read more about method security in the Spring Security documentation: https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html.

In the next section, we will introduce the basics of OAuth with Spring Boot.

Using OAuth2 with Spring Boot
It is really challenging to implement fully secure authentication and authorization in your application. In a production environment, it is recommended that you do it using an OAuth2 provider. This actually simplifies the authentication process, and providers typically have excellent security practices.

These are not detailed instructions for implementing OAuth 2.0 authorization, but they will give you an idea of the process.

OAuth (Open Authorization) is a standard for secure access to protected resources on the internet. The OAuth standard version 2.0 is commonly used nowadays. There are several OAuth 2.0 providers that implement OAuth authorization for third-party applications. Some common providers are listed here:

Auth0: https://auth0.com/
Okta: https://www.okta.com/
Keycloak: https://www.keycloak.org/
You can implement social logins using OAuth2, after which users can log in with their existing credentials from social media platforms such as Facebook. OAuth also defines mechanisms for revoking access tokens and handling token expiration.

If you want to use OAuth in your Spring Boot applications, the first step is to select an OAuth provider. All providers in the list above can be used with your Spring Boot applications.

In the OAuth2 process, the term resource owner refers typically to an end user and the authorization server is part of the OAuth provider’s service. The client is an application that wants to get access to protected resources. The resource server commonly refers to an API that the client wants to use.

The simplified version of the OAuth2 authentication process with a REST API contains the following steps:

Authentication: The third-party application authenticates by requesting access to protected resources.
Authorization: The resource owner authorizes access to their resources, commonly through user login.
The authorization server authorizes the resource owner and redirects the user back to the client with an authorization code.
The client requests an access token from the authorization server using the authorization code. The access token format is not specified in the standard, and JWTs are quite commonly used.
The authorization server validates the access token. If the token is valid, the client application receives an access token.
The client can start to use the access token to access protected resources, for example, calling REST API endpoints.
After you have selected a provider and know how its service works, you have to configure your Spring Boot application. Spring Boot provides the spring-boot-starter-oauth2-client dependency for OAuth2 authentication and authorization. It is used to simplify OAuth 2.0 integration in your Spring Boot application. Quite a few OAuth providers have documentation for different technologies, such as Spring Boot.

The implementation will differ depending on the provider. Here are some useful links:

Auth0 has a good tutorial for how to add login to your Spring Boot application: https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive.
Baeldung provides a quick guide to using Keycloak with Spring Boot applications: https://www.baeldung.com/spring-boot-keycloak.
Spring also has a tutorial on how to implement social login using GitHub: https://spring.io/guides/tutorials/spring-boot-oauth2.
We recommend reading these to get a better idea of using OAuth 2.0 in your own applications.

Now, we have finished securing our backend using the JWT, and we will use this version when we start to develop our frontend.

Summary
In this chapter, we focused on making our Spring Boot backend more secure. We started by adding extra protection using Spring Security. Then, we implemented JWT authentication. JWTs are commonly used to secure RESTful APIs and it is a lightweight authentication method suitable for our needs. We also covered the basics of the OAuth 2.0 standard and how to start using it in your Spring Boot application.

In the next chapter, we will learn the basics of testing in Spring Boot applications.

Questions
What is Spring Security?
How can you secure your backend with Spring Boot?
What is a JWT?
How can you secure your backend with a JWT?
What is OAuth 2.0?
Further reading
Packt has other resources available for you to learn about Spring Security. For instance:

Spring Security Core: Beginner to Guru, by John Thompson (https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000)
Learn more on Discord
To join the Discord community for this book – where you can share feedback, ask the author questions, and learn about new releases – follow the QR code below:

https://packt.link/FullStackSpringBootReact4e



| ≪ [ 104 Creating a RESTful Web Service with Spring Boot ](/books/packtpub/2024/1202-Spring_Boot_3_React/104) | 105 Securing Your Backend | [ 106 Testing Your Backend ](/books/packtpub/2024/1202-Spring_Boot_3_React/106) ≫ |
|:----:|:----:|:----:|

> Page Properties:
> (1) Title: 105 Securing Your Backend
> (2) Short Description: Spring Boot 3 React
> (3) Path: books/packtpub/2024/1202-Spring_Boot_3_React/105
> Book Jemok: Full Stack Development with Spring Boot 3 and React 4Ed
> AuthorDate: Juha Hinkula / Oct 2023 / 454 pages 4Ed
> Link: https://subscription.packtpub.com/book/web-development/9781805122463/pref
> create: 2024-12-02 월 14:31:21
> .md Name: 105_securing_your_backend.md

