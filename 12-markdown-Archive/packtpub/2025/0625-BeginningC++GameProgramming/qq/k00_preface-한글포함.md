
| 🏁 0625 Beginning C++ Game Programming | 00 Preface | [ 01 Welcome to Beginning C++ Game Programming, 3Ed ](/packtpub/2025/0625_beginning_c++_game_programming/01_welcome_to_beginning_c++_game_programming,_3ed) ≫ |
|:----:|:----:|:----:|

# 00 Preface

Beginning C++ Game Programming - Third Edition
By : John Horton

# Overview of this book
Always dreamed of creating your own games? With the third edition of Beginning C++ Game Programming, you can turn that dream into reality! This beginner-friendly guide is updated and improved to include the latest features of VS 2022, SFML, and modern C++20 programming techniques. You'll get a fun introduction to game programming by building four fully playable games of increasing complexity. You'll build clones of popular games such as Timberman, Pong, a Zombie survival shooter, and an endless runner. The book starts by covering the basics of programming. You'll study key C++ topics, such as object-oriented programming (OOP) and C++ pointers and get acquainted with the Standard Template Library (STL). The book helps you learn about collision detection techniques and game physics by building a Pong game. As you build games, you'll also learn exciting game programming concepts such as vertex arrays, directional sound (spatialization), OpenGL programmable shaders, spawning objects, and much more. You’ll dive deep into game mechanics and implement input handling, levelling up a character, and simple enemy AI. Finally, you'll explore game design patterns to enhance your C++ game programming skills. By the end of the book, you'll have gained the knowledge you need to build your own games with exciting features from scratch.
🧩

C++ 게임 프로그래밍 시작 - 세번째 에디션
작성자: 존 호튼

# 이 책의 개요
항상 나만의 게임을 만드는 꿈을 꾸셨나요? Beginning C++ 게임 프로그래밍의 세 번째 에디션을 통해 그 꿈을 현실로 바꿀 수 있습니다! 이 초보자 친화적인 가이드는 VS 2022, SFML, 최신 C++20 프로그래밍 기술의 최신 기능을 포함하도록 업데이트 및 개선되었습니다. 복잡성이 증가하는 4개의 완전 플레이 가능한 게임을 빌드하면 게임 프로그래밍에 대한 재미있는 소개를 얻을 수 있습니다. 팀버맨, 퐁, 좀비 서바이벌 슈팅 게임, 엔드리스 러너와 같은 인기 게임의 클론을 만들 수 있습니다. 이 책은 프로그래밍의 기본을 다루는 것부터 시작합니다. 객체 지향 프로그래밍(OOP), C++ 포인터와 같은 C++의 주요 주제를 공부하고 표준 템플릿 라이브러리(STL)에 대해 알아보세요. 이 책은 퐁 게임을 빌드하여 충돌 감지 기술과 게임 물리학에 대해 배울 수 있도록 도와줍니다. 게임을 빌드하면서 버텍스 배열, 방향성 사운드(공간화), OpenGL 프로그래머블 셰이더, 산란 물체 등 흥미로운 게임 프로그래밍 개념도 배울 수 있습니다. 게임 메커니즘에 깊이 파고들어 입력 처리, 캐릭터 레벨업, 간단한 적 AI 등을 구현할 수 있습니다. 마지막으로 게임 디자인 패턴을 탐구하여 C++ 게임 프로그래밍 기술을 향상시킬 수 있습니다. 책이 끝나면 처음부터 흥미로운 기능으로 나만의 게임을 만드는 데 필요한 지식을 얻게 됩니다.
(papago.naver.com)
🧩

# Preface
Always dreamed of creating your own games? With the third edition of Beginning C++ Game Programming, you can turn that dream into reality! This beginner-friendly guide is updated and improved to include the latest features of VS 2022, SFML, and modern C++20 programming techniques. You will get a fun introduction to game programming by building four fully playable games of increasing complexity. You’ll build clones of popular games such as Timberman, Pong, a Zombie survival shooter, and an endless runner.

The book starts by covering the basics of programming. You’ll study key C++ topics, such as object-oriented programming (OOP) and C++ pointers, and get acquainted with the Standard Template Library (STL). The book helps you learn about collision detection techniques and game physics by building a Pong game. As you build games, you’ll also learn exciting game programming concepts such as vertex arrays, directional sound (spatialization), OpenGL programmable shaders, spawning objects, and much more. You’ll dive deep into game mechanics and implement input handling, levelling up a character, and simple enemy AI. Finally, you’ll explore game design patterns to enhance your C++ game programming skills.

By the end of the book, you’ll have gained the knowledge you need to build your own games with exciting features from scratch.
🧩

# 서문
항상 나만의 게임을 만드는 꿈을 꾸셨나요? Beginning C++ 게임 프로그래밍의 세 번째 에디션을 통해 그 꿈을 현실로 바꿀 수 있습니다! 이 초보자 친화적인 가이드는 VS 2022, SFML, 최신 C++20 프로그래밍 기술의 최신 기능을 포함하도록 업데이트 및 개선되었습니다. 복잡성이 증가하는 4개의 완전 플레이 가능한 게임을 제작하여 게임 프로그래밍에 대한 재미있는 소개를 얻을 수 있습니다. 팀버맨, 퐁, 좀비 서바이벌 슈팅 게임, 엔드리스 러너 등 인기 게임의 클론을 제작할 수 있습니다.

이 책은 프로그래밍의 기본을 다루는 것부터 시작합니다. 객체 지향 프로그래밍(OOP)과 C++ 포인터와 같은 주요 C++ 주제를 공부하고 표준 템플릿 라이브러리(STL)에 대해 알아보세요. 이 책은 퐁 게임을 구축하여 충돌 감지 기술과 게임 물리학에 대해 배울 수 있도록 도와줍니다. 게임을 구축하면서 버텍스 배열, 방향성 사운드(공간화), OpenGL 프로그래머블 셰이더, 산란 객체 등 흥미로운 게임 프로그래밍 개념도 배우게 됩니다. 게임 메커니즘에 깊이 빠져 입력 처리, 캐릭터 레벨업, 간단한 적 AI 등을 구현할 수 있습니다. 마지막으로 게임 디자인 패턴을 탐구하여 C++ 게임 프로그래밍 기술을 향상시킬 수 있습니다.

책이 끝날 무렵, 당신은 처음부터 흥미로운 기능을 갖춘 나만의 게임을 만드는 데 필요한 지식을 얻게 될 것입니다.
🧩

# Who this book is for
This book is perfect for you if you have no C++ programming knowledge, you need a beginner-level refresher course, or you want to learn how to build games or just use games as an engaging way to learn C++.

Whether you aspire to publish a game (perhaps on Steam) or just want to impress friends with your creations, you’ll find this book useful.
🧩

# 이 책이 누구를 위한 것인지
이 책은 C++ 프로그래밍 지식이 없거나 초보자 수준의 리프레셔 과정이 필요하거나 게임을 만드는 방법을 배우거나 C++를 배우는 흥미로운 방법으로 게임을 사용하고 싶을 때 완벽합니다.

게임을 (아마도 Steam에서) 출판하고 싶든, 아니면 창작물로 친구들에게 깊은 인상을 남기고 싶든, 이 책은 유용할 것입니다.
🧩

# What this book covers
Chapter 1, Welcome to Beginning C++ Game Programming, Third Edition: This chapter outlines the journey to writing exciting games for PC using C++ and the OpenGL powered SFML. This third edition has an overwhelming focus on improving and expanding upon what you will learn in game programming. All the C++ basics from variables in the beginning, through loops, object-oriented programming, the Standard Template Library, SFML features, and newer C++ possibilities, have been added to and expanded upon. By the end of this book, you will not only have four playable games but also have a deep and solid grounding in C++.

Chapter 2, Variables, Operators, and Decisions: Animating Sprites: In this chapter, we will do quite a bit more drawing on the screen. We will animate some clouds that travel at a random height and a random speed across the background and a bee that does the same in the foreground. To achieve this, we will need to learn some more of the basics of C++. We will be learning how C++ stores data with variables as well as how to manipulate those variables with the C++ operators and how to make decisions that branch our code on different paths based on the value of variables. Once we have learned all this, we will be able to reuse our knowledge about the SFML Sprite and Texture classes to implement our cloud and bee animations.

Chapter 3, C++ Strings, SFML Time, Player Input, and HUD: In this chapter, we will spend around half the time learning how to manipulate text and display it on the screen and the other half looking at timing and how a visual time bar can inform the player and create a sense of urgency in the game.

Chapter 4, Loops, Arrays, Switch, Enumerations, and Functions – Implementing Game Mechanics: This chapter probably has more C++ information than any other chapter in the book. It is packed with fundamental concepts that will move our understanding on enormously. It will also begin to shed light on some of the murky areas we have been skipping over a little bit, like functions, the game loop, and loops in general.

Chapter 5, Collisions, Sound, and End Conditions: Making the Game Playable: This is the final phase of the first project. By the end of this chapter, you will have your first completed game. Once you have Timber!!! up and running, be sure to read the last section of this chapter as it will suggest ways to make the game better. Here is what we will cover in this chapter: adding the rest of the sprites, handling the player input, animating the flying log, handling death, adding sound effects, adding features, and improving Timber!!!.
🧩

# 이 책이 다루는 내용
제1장, C++ 게임 프로그래밍 입문, 제3판: 이 장에서는 C++와 OpenGL 기반 SFML을 사용하여 PC용 흥미로운 게임을 작성하는 여정을 개괄적으로 다룹니다. 이 세 번째 판은 게임 프로그래밍에서 배울 내용을 개선하고 확장하는 데 압도적인 초점을 맞추고 있습니다. 초기 변수부터 루프, 객체 지향 프로그래밍, 표준 템플릿 라이브러리, SFML 기능 및 최신 C++ 가능성에 이르기까지 모든 C++ 기본 사항이 추가되고 확장되었습니다. 이 책을 완성하면 4개의 플레이 가능한 게임뿐만 아니라 C++에 대한 깊고 탄탄한 기반도 갖추게 됩니다.

2장, 변수, 연산자 및 결정: 스프라이트 애니메이션: 이 장에서는 화면에 훨씬 더 많은 그림을 그릴 것입니다. 배경을 가로지르는 임의의 높이와 임의의 속도로 이동하는 구름과 전경에서 동일한 속도를 내는 벌을 애니메이션으로 만들 것입니다. 이를 위해서는 C++의 기본 사항에 대해 더 배워야 합니다. C++가 변수가 있는 데이터를 저장하는 방법과 C++ 연산자를 사용하여 이러한 변수를 조작하는 방법, 변수 값에 따라 다른 경로에서 코드를 분기하는 결정을 내리는 방법을 배울 것입니다. 이 모든 것을 배운 후에는 SFML 스프라이트 및 텍스처 클래스에 대한 지식을 재사용하여 클라우드 및 꿀벌 애니메이션을 구현할 수 있을 것입니다.

3장, C++ 문자열, SFML 시간, 플레이어 입력, 그리고 HUD: 이 장에서는 텍스트를 조작하고 화면에 표시하는 방법을 배우는 데 약 절반의 시간을 할애하고, 나머지 절반은 타이밍과 시각적 시간 막대가 플레이어에게 정보를 제공하고 게임에서 긴박감을 조성하는 방법을 살펴보겠습니다.

4장, 루프, 배열, 스위치, 열거 및 기능 - 게임 메커니즘 구현: 이 장에는 책의 다른 어떤 장보다 C++ 정보가 더 많이 담겨 있을 것입니다. 이 장은 우리의 이해를 크게 움직일 기본 개념으로 가득 차 있습니다. 또한 함수, 게임 루프, 루프 등 우리가 조금씩 건너뛰고 있는 몇 가지 모호한 영역에 대해서도 조명하기 시작할 것입니다.

5장, 충돌, 소리, 그리고 종료 조건: 게임 플레이 가능 만들기: 이것이 첫 번째 프로젝트의 마지막 단계입니다. 이 장이 끝날 때쯤이면 첫 번째 완성 게임이 완성됩니다. Timber!!!를 실행하고 나면, 이 장의 마지막 부분을 꼭 읽어보세요. 게임을 더 좋게 만드는 방법을 제시할 것입니다. 이 장에서 다룰 내용은 스프라이트의 나머지 추가, 플레이어 입력 처리, 비행 로그 애니메이션, 죽음 처리, 음향 효과 추가, 기능 추가 및 개선입니다!!!입니다.
🧩

Chapter 6, Object-Oriented Programming – Starting the Pong Game: In this chapter, there’s a little bit of theory, but the theory will give us the knowledge that we need to start using object-oriented programming (OOP). OOP helps us organize our code into human-recognizable structures and handle complexity. We will not waste any time in putting that theory to good use as we will use it to code the next project, a Pong game. We will get to look behind the scenes at how we can create new C++ types that we can use as objects. We will achieve this by coding our first class. To get started, we will look at a simplified Pong game scenario so that we can learn about some class basics, and then we will start again and code a Pong game for real using the principles we have learned.

Chapter 7, AABB Collision Detection and Physics – Finishing the Pong Game: In this chapter, we will code our second class. We will see that although the ball is obviously quite different from the bat, we will use the exact same techniques to encapsulate the appearance and functionality of a ball inside a Ball class, just like we did with the bat and the Bat class. We will then add the finishing touches to the Pong game by coding some collision detection and scorekeeping. This might sound complicated but as we are coming to expect, SFML will make things much easier than they otherwise would be.

Chapter 8, SFML Views – Starting the Zombie Shooter Game: In this project, we will be making even more use of OOP, and to a powerful effect. We will also be exploring the SFML View class. This versatile class will allow us to easily divide our game up into layers for different aspects of the game. In the Zombie Shooter project, we will have a layer for the HUD and a layer for the main game. This is necessary because the game world expands each time the player clears a wave of zombies. Eventually, the game world will be bigger than the screen and the player will need to scroll. The use of the View class will prevent the text of the HUD from scrolling with the background.

Chapter 9, C++ References, Sprite Sheets, and Vertex Arrays: In Chapter 4, Loops, Arrays, Switch, Enumerations, and Functions – Implementing Game Mechanics, we talked about scope. This is the concept that variables declared in a function or inner block of code only have scope (that is, can be seen or used) in that function or block. Using only the C++ knowledge we have currently, this can cause a problem. What do we do if we need to work on a few complex objects that are needed in the main function? This could imply all the code must be in the main function.

In this chapter, we will explore C++ references, which allow us to work on variables and objects that are otherwise out of scope. In addition to this, these references will help us avoid having to pass large objects between functions, which is a slow process. It is slow because each time we do this, a copy of the variable or object must be made.

Armed with this new knowledge of references, we will look at the SFML VertexArray class, which allows us to build up a large image that can be quickly and efficiently drawn to the screen using multiple parts in a single image file. By the end of this chapter, we will have a scalable, random, scrolling background that’s been made using references and a VertexArray object.

Chapter 10, Pointers, the Standard Template Library, and Texture Management: In this chapter, we will learn a lot as well as get plenty done in terms of the game in this chapter. We will first learn about the fundamental C++ topic of pointers. Pointers are variables that hold a memory address. Typically, a pointer will hold the memory address of another variable. This sounds a bit like a reference, but we will see how they are much more powerful and use a pointer to handle an ever-expanding horde of zombies.

We will also learn about the Standard Template Library (STL), which is a collection of classes that allow us to quickly and easily implement common data management techniques.
🧩

6장, 객체 지향 프로그래밍 – 퐁 게임 시작: 이 장에서는 약간의 이론이 있지만, 이 이론을 통해 객체 지향 프로그래밍(OOP)을 시작하는 데 필요한 지식을 얻을 수 있습니다. OOP는 코드를 사람이 인식할 수 있는 구조로 구성하고 복잡성을 처리하는 데 도움이 됩니다.

7장, AABB 충돌 감지 및 물리학 – 퐁 게임 마무리: 이 장에서는 두 번째 클래스를 코딩할 것입니다. 공은 분명히 배트와 상당히 다르지만, 배트 클래스와 마찬가지로 공의 외형과 기능을 볼 클래스 내부에 캡슐화하는 데 동일한 기술을 사용할 것입니다. 그런 다음 충돌 감지 및 스코어 키핑을 코딩하여 퐁 게임에 마무리 작업을 추가할 것입니다. 복잡하게 들릴 수도 있지만 예상대로 SFML은 그렇지 않은 경우보다 훨씬 더 쉽게 만들 것입니다.

8장, SFML 보기 – 좀비 슈팅 게임 시작하기: 이번 프로젝트에서는 OOP를 더욱 활용하여 강력한 효과를 발휘할 것입니다. 또한 SFML 보기 클래스도 살펴볼 예정입니다. 이 다용도 클래스를 통해 게임의 다양한 측면을 위한 레이어로 쉽게 나눌 수 있습니다. 좀비 슈팅 프로젝트에서는 HUD를 위한 레이어와 메인 게임을 위한 레이어가 있습니다. 플레이어가 좀비의 물결을 클리어할 때마다 게임 세계가 확장되기 때문에 이는 필수입니다. 결국 게임 세계는 화면보다 커지고 플레이어는 스크롤해야 합니다. View 클래스를 사용하면 HUD의 텍스트가 배경과 함께 스크롤되는 것을 방지할 수 있습니다.

9장 C++ 참조, 스프라이트 시트, 버텍스 어레이: 4장의 루프, 어레이, 스위치, 열거 및 기능 – 게임 역학 구현에서 범위에 대해 이야기했습니다. 이는 함수 또는 코드의 내부 블록에 선언된 변수는 해당 함수 또는 블록에 범위(즉, 보거나 사용할 수 있음)만 있다는 개념입니다. 현재 우리가 가지고 있는 C++ 지식만 사용하면 문제가 발생할 수 있습니다. 주 함수에 필요한 몇 가지 복잡한 객체를 작업해야 하는 경우 어떻게 해야 하나요? 이는 모든 코드가 주 함수에 있어야 함을 의미할 수 있습니다.

이 장에서는 변수와 범위를 벗어난 객체에 대해 작업할 수 있는 C++ 참조를 탐구할 것입니다. 이 외에도 이러한 참조는 함수 간에 큰 객체를 전달할 필요가 없도록 도와주며, 이는 느린 프로세스입니다. 이렇게 할 때마다 변수나 객체의 복사본을 만들어야 하기 때문에 속도가 느립니다.

이 새로운 레퍼런스 지식을 바탕으로 SFML VertexArray 클래스를 살펴보겠습니다. 이 클래스는 단일 이미지 파일의 여러 부분을 사용하여 화면에 빠르고 효율적으로 그릴 수 있는 대형 이미지를 구축할 수 있게 해줍니다. 이 장이 끝날 때쯤이면 레퍼런스와 VertexArray 객체를 사용하여 확장 가능하고 무작위적인 스크롤 배경을 만들 수 있을 것입니다.

10장, 포인터, 표준 템플릿 라이브러리, 텍스처 관리: 이 장에서는 이 장의 게임 측면에서 많은 것을 배울 뿐만 아니라 많은 것을 배울 것입니다. 먼저 포인터의 기본적인 C++ 주제에 대해 알아보겠습니다. 포인터는 메모리 주소를 보유한 변수입니다. 일반적으로 포인터는 다른 변수의 메모리 주소를 보유합니다. 이는 약간 참고 문헌처럼 들리지만 포인터가 얼마나 더 강력한지 살펴보고 포인터를 사용하여 계속 확장되는 좀비 무리를 처리하는지 살펴보겠습니다.

또한 일반적인 데이터 관리 기법을 빠르고 쉽게 구현할 수 있는 클래스 모음인 표준 템플릿 라이브러리(STL)에 대해서도 배울 예정입니다.
🧩

Chapter 11, Coding the TextureHolder Class and Building a Horde of Zombies: Now that we have understood the basics of the STL, we will be able to use that new knowledge to manage all the textures from the game because if we have 1,000 zombies, we don’t really want to load a copy of a zombie graphic into the GPU for each and every one.

We will also dig a little deeper into OOP and use a static function, which is a function of a class that can be called without an instance of the class. At the same time, we will see how we can design a class to ensure that only one instance can ever exist. This is ideal when we need to guarantee that different parts of our code will use the same data.

Chapter 12, Collision Detection, Pickups, and Bullets: So far, we have implemented the main visual aspects of our game. We have a controllable character running around in an arena full of zombies that chase them. The problem is that they don’t interact with each other. A zombie can wander right through the player without leaving a scratch. We need to detect collisions between the zombies and the player.

If the zombies are going to be able to injure and eventually kill the player, it is only fair that we give the player some bullets for their gun. We will then need to make sure that the bullets can hit and kill the zombies.

At the same time, if we are writing collision detection code for bullets, zombies, and the player, it would be a good time to add a class for health and ammo pickups as well.

Here is what we will do and the order in which we will cover things in this chapter: shooting bullets, adding a crosshair and hiding the mouse pointer, spawning pickups, and detecting collisions

Chapter 13, Layering Views and Implementing the HUD: In this chapter, we will get to see the real value of SFML Views. We will add a selection of SFML Text objects and manipulate them as we did before in the Timber!!! project and the Pong project. What’s new is that we will draw the HUD using a second View instance. This way, the HUD will stay neatly positioned over the top of the main game action, regardless of what the background, player, zombies, and other game objects are doing.

Chapter 14, Sound Effects, File I/O, and Finishing the Game: We are nearly done with this project. This short chapter will demonstrate how we can easily manipulate files stored on the hard drive using the C++ standard library, and we will also add sound effects. Of course, we know how to add sound effects, but we will discuss exactly where the calls to the play function will go in the code. We will also tie up a few loose ends to make the game complete. In this chapter, we will cover the following topics: saving and loading the hi-score using file input and file output, adding sound effects, allowing the player to level up, and spawning a new wave.

Chapter 15, Run!: Welcome to the final project. Run, Run is an endless runner where the objective of the player is to stay ahead of the disappearing platforms that are catching them up from behind. In this project, we will learn loads of new game programming techniques and even more C++ topics to implement those techniques. Perhaps the best improvement this game will have over the previous games is that it will be way more object oriented than any of the others. There will be many, many more classes than any of the preceding projects but most of the code files for these classes will be short and uncomplicated. Furthermore, we will build a game where the functionality and appearance of all the in-game objects is pushed out to classes, leaving the main game loop unchanged regardless of what the GameObjects do. This is powerful because it means you can make a hugely varied game just by designing new standalone components (classes) that describe the behavior and appearance of the required game entity. This means you can use the same code structure for a completely different game of your own design. But there is way more to come than just this. Read on for details.
🧩

챕터 11, 텍스처 홀더 클래스 코딩 및 좀비 무리 만들기: 이제 STL의 기본 지식을 이해했으니, 좀비 1,000명이 있다면 좀비 그래픽 사본을 GPU에 일일이 로드하고 싶지 않기 때문에 새로운 지식을 사용하여 게임의 모든 텍스처를 관리할 수 있을 것입니다.

또한 OOP에 대해 조금 더 자세히 알아보고 클래스 인스턴스 없이 호출할 수 있는 클래스의 함수인 정적 함수를 사용할 것입니다. 동시에 하나의 인스턴스만 존재할 수 있도록 클래스를 설계하는 방법을 살펴보겠습니다. 코드의 다른 부분에서 동일한 데이터를 사용하도록 보장해야 할 때 이상적입니다.

12장, 충돌 감지, 픽업, 총알: 지금까지 게임의 주요 시각적 측면을 구현했습니다. 좀비가 가득한 경기장에서 좀비를 쫓는 통제 가능한 캐릭터가 뛰어다니고 있습니다. 문제는 좀비가 서로 상호작용하지 않는다는 것입니다. 좀비는 흠집을 남기지 않고 플레이어를 바로 돌아다닐 수 있습니다. 좀비와 플레이어 간의 충돌을 감지해야 합니다.

좀비가 부상을 입고 결국 플레이어를 죽일 수 있다면 플레이어에게 총에 맞는 총알을 제공하는 것이 정당합니다. 그런 다음 총알이 좀비를 맞고 죽일 수 있는지 확인해야 합니다.

동시에 총알, 좀비, 플레이어의 충돌 감지 코드를 작성하는 경우 건강 및 탄약 픽업 클래스도 추가하는 것이 좋습니다.

이 장에서 다룰 작업과 순서는 다음과 같습니다: 총알 발사, 십자수 추가 및 마우스 포인터 숨기기, 픽업 산란, 충돌 감지

13장, 보기의 계층화 및 HUD 구현: 이 장에서는 SFML 보기의 실제 가치를 살펴보겠습니다. 이전에 Timber!!! 프로젝트와 Pong 프로젝트에서 그랬던 것처럼 SFML 텍스트 객체를 추가하고 조작할 것입니다. 새로운 점은 두 번째 보기 인스턴스를 사용하여 HUD를 그린다는 것입니다. 이렇게 하면 배경, 플레이어, 좀비 및 기타 게임 객체가 무엇을 하는지에 관계없이 HUD가 메인 게임 액션 위에 깔끔하게 배치됩니다.

14장, 음향 효과, 파일 입출력, 게임 완료: 이 프로젝트는 거의 끝났습니다. 이 짧은 장에서는 C++ 표준 라이브러리를 사용하여 하드 드라이브에 저장된 파일을 쉽게 조작하는 방법을 설명하고 음향 효과도 추가할 것입니다. 물론 음향 효과를 추가하는 방법은 알고 있지만, 플레이 기능 호출이 코드에서 정확히 어디로 갈지 논의할 것입니다. 또한 게임을 완성하기 위해 몇 가지 느슨한 끝을 묶을 것입니다. 이 장에서는 파일 입력과 파일 출력을 사용하여 고득점 저장 및 로드, 음향 효과 추가, 플레이어 레벨 업, 새로운 웨이브 생성 등 다음 주제를 다룰 것입니다.

챕터 15, Run!: 마지막 프로젝트에 오신 것을 환영합니다. Run, Run은 플레이어의 목표가 사라지는 플랫폼 뒤에서 따라잡고 있는 플랫폼들보다 앞서 나가는 것을 목표로 하는 끝없는 러너입니다. 이번 프로젝트에서는 이러한 기술을 구현하기 위해 새로운 게임 프로그래밍 기술과 더 많은 C++ 주제를 배우게 될 것입니다. 이 게임이 이전 게임들에 비해 가장 크게 개선될 수 있는 점은 다른 어떤 게임보다 훨씬 더 많은 객체 지향적인 게임이 될 것이라는 점입니다. 이전 프로젝트보다 훨씬 더 많은 클래스가 있을 것이지만, 이러한 클래스의 코드 파일 대부분은 짧고 복잡하지 않을 것입니다. 또한, 게임 내 모든 객체의 기능과 외형이 클래스로 밀려나면서 게임 객체가 무엇을 하든 메인 게임 루프는 변하지 않는 게임을 구축할 것입니다. 이는 필요한 게임 엔티티의 동작과 모양을 설명하는 새로운 독립형 구성 요소(클래스)를 설계하는 것만으로도 매우 다양한 게임을 만들 수 있다는 것을 의미하기 때문에 강력합니다. 즉, 동일한 코드 구조를 사용하여 완전히 다른 디자인의 게임을 만들 수 있습니다. 하지만 이 외에도 더 많은 것이 있습니다. 자세한 내용은 계속 읽어보세요.
🧩

Chapter 16, Sound, Game Logic, Inter-Object Communication, and the Player: In this chapter, we will quickly implement our game’s sound. We have done this before, so it won’t be hard. In fact, in just half a dozen lines of code, we will also add music to our sound features. Later in the project, but not in this chapter, we will add directional (spatialized) sound.

In this chapter, we will wrap all our sound-related code into a single class called SoundEngine. Once we have some noise, we will then move on to get started on the player. We will achieve the entire player character functionality just by adding two classes: one that extends Update and one that extends Graphics. This creation of new game objects by extending these two classes will be how we do almost everything else for the entire game. We will also see the simple way that objects communicate with each other using pointers.

Chapter 17, Graphics, Camera, Action: In this chapter, we will talk in depth about the way the graphics will work in this project. As we will be coding the cameras that do the drawing in this chapter, now seems like a good time to talk about the graphics too. If you looked in the graphics folder, there is just one graphic. Furthermore we are not calling window.draw at any point in our code so far. We will discuss why draw calls should be kept to a minimum as well as implement our Camera classes that will handle this for us. Finally, in this chapter, we will be able to run the game and see the cameras in action, including the main view, the radar view, and the timer text.

Chapter 18, Coding the Platforms, Player Animations, and Controls: In this chapter, we will code the platforms and the player animation and controls. In my opinion, we have done the hard work already and most of what follows has a much higher reward-to-effort ratio. Hopefully this chapter will be interesting as we will see how the platforms will ground the player and enable them to run, as well as seeing how we loop through the frames of animation to create a smooth running effect for the player. We will do the following: coding the platforms, adding functionality to the player, coding the Animator class, coding the animations, and adding a smooth running animation to the player.

Chapter 19, Building the Menu and Making It Rain: In this chapter, we will implement two significant features. One is a menu screen to keep the player informed of their options for starting, pausing, restarting, and quitting the game. The other job will be to create a simple raining effect. You could argue the raining effect isn’t necessary, even that it doesn’t fit the game, but it is easy, fun, and a good trick to learn. What you should expect by now, and yet is still perhaps the most interesting aspect of this chapter, is how we will achieve both these objectives by coding classes derived from Graphics and Update, composing them in GameObject instances, and they will just work alongside all our other game entities.

Chapter 20, Fireballs and Spatialization: In this chapter, we will be adding all the sound effects and the HUD. We have done this in two of the previous projects, but we will do things a bit differently this time. We will explore the concept of sound spatialization and how SFML makes this complicated concept nice and easy. In addition, we will build a HUD class to encapsulate our code that draws information to the screen.

Chapter 21, Parallax Backgrounds and Shaders: This is the last chapter and our last opportunity to work on our game. It will be fully playable with all the features by the end. Here is what we will do to wrap up the Run game. We will learn a bit more about OpenGL, shaders, and the Graphics Library Shading Language (GLSL), finish the CameraGraphics class by implementing a scrolling background and shader, a code a shader by using someone else’s code, and finally run the completed game
🧩

16장, 사운드, 게임 로직, 객체 간 통신, 플레이어: 이 장에서는 게임의 사운드를 빠르게 구현합니다. 이전에도 이 작업을 수행한 적이 있으므로 어렵지 않을 것입니다. 실제로 단 6줄의 코드로 사운드 기능에 음악도 추가할 예정입니다. 프로젝트 후반부에는 방향성(공간화된) 사운드를 추가할 예정이지만 이 장에서는 그렇지 않습니다.

이 장에서는 모든 사운드 관련 코드를 SoundEngine이라는 단일 클래스로 포장합니다. 노이즈가 발생하면 플레이어를 시작합니다. 업데이트를 확장하는 클래스와 그래픽을 확장하는 클래스 두 가지만 추가하면 전체 플레이어 캐릭터 기능을 달성할 수 있습니다. 이 두 클래스를 확장하여 새로운 게임 객체를 만드는 것이 전체 게임의 거의 모든 다른 작업을 수행하는 방식입니다. 또한 포인터를 사용하여 객체가 서로 통신하는 간단한 방법도 살펴보겠습니다.

17장, 그래픽, 카메라, 액션: 이 장에서는 이 프로젝트에서 그래픽이 작동하는 방식에 대해 자세히 설명하겠습니다. 이 장에서 그림을 그리는 카메라를 코딩할 예정이므로 그래픽에 대해서도 이야기하기에 좋은 시기인 것 같습니다. 그래픽 폴더를 보면 그래픽이 하나뿐입니다. 또한 지금까지는 코드의 어느 시점에서든 window.draw라고 부르지 않습니다. 그림 호출을 최소한으로 유지해야 하는 이유와 이를 처리할 수 있는 카메라 클래스를 구현해야 하는 이유에 대해 설명하겠습니다. 마지막으로 이 장에서는 게임을 실행하고 메인 뷰, 레이더 뷰, 타이머 텍스트 등 카메라가 실제로 작동하는 모습을 볼 수 있습니다.

18장, 플랫폼 코딩, 플레이어 애니메이션 및 컨트롤: 이 장에서는 플랫폼과 플레이어 애니메이션 및 컨트롤을 코딩할 것입니다. 제 생각에는 이미 많은 노력을 기울였고, 다음 대부분의 작업은 훨씬 더 높은 보상 대 노력 비율을 가지고 있습니다. 이 장이 흥미롭기를 바랍니다. 플랫폼이 플레이어를 어떻게 접지하고 실행할 수 있는지, 그리고 애니메이션 프레임을 어떻게 루프하여 플레이어에게 원활한 실행 효과를 만들어낼 수 있는지 살펴볼 것입니다. 우리는 다음과 같이 할 것입니다: 플랫폼 코딩, 플레이어에 기능 추가, 애니메이터 클래스 코딩, 애니메이션 코딩, 그리고 플레이어에게 원활한 실행 애니메이션 추가.

19장, 메뉴 구축 및 비 만들기: 이 장에서는 두 가지 중요한 기능을 구현합니다. 하나는 플레이어가 게임 시작, 일시 중지, 재시작 및 종료 옵션을 계속 알려주는 메뉴 화면입니다. 다른 하나는 간단한 비 효과를 만드는 것입니다. 비 효과는 게임에 맞지 않더라도 쉽고 재미있으며 배우기 좋은 트릭이라고 주장할 수 있습니다. 지금쯤 기대해야 할 것이지만 여전히 이 장의 가장 흥미로운 측면은 그래픽과 업데이트에서 파생된 클래스를 코딩하여 GameObject 인스턴스에 구성하여 이 두 가지 목표를 모두 달성하는 방법이며, 다른 모든 게임 엔티티와 함께 작동할 것입니다.

20장, 파이어볼과 공간화: 이 장에서는 모든 음향 효과와 HUD를 추가할 것입니다. 이전 두 프로젝트에서 이 작업을 수행한 적이 있지만 이번에는 조금 다르게 작업할 것입니다. 사운드 공간화의 개념과 SFML이 이 복잡한 개념을 어떻게 멋지고 쉽게 만드는지 살펴봅니다. 또한 화면에 정보를 끌어오는 코드를 캡슐화하는 HUD 클래스를 구축할 것입니다.

챕터 21, 시차 배경 및 셰이더: 이것이 우리 게임을 작업할 수 있는 마지막 챕터이자 마지막 기회입니다. 마지막까지 모든 기능으로 완전히 플레이할 수 있습니다. 런 게임을 마무리하기 위해 다음과 같이 하겠습니다. OpenGL, 셰이더, 그래픽 라이브러리 셰이딩 언어(GLSL)에 대해 조금 더 배우고, 스크롤 배경과 셰이더를 구현하여 CamerGraphics 수업을 마치고, 다른 사람의 코드를 사용하여 셰이더를 코딩한 후, 마지막으로 완성된 게임을 실행할 것입니다
🧩

# To get the most out of this book
There are no knowledge prerequisites for this book. You do not need to know how to program as the book takes you from zero knowledge to four playable games. It will help a little if you have played a few video games and you are determined to learn.

## Download the example code files
The code bundle for the book is hosted on GitHub at https://github.com/PacktPublishing/Beginning-C-Game-Programming-Third-Edition. We also have other code bundles from our rich catalog of books and videos available at https://github.com/PacktPublishing/. Check them out!

## Download the color images
We also provide a PDF file that has color images of the screenshots/diagrams used in this book. You can download it here: https://packt.link/gbp/9781835081747.

## Conventions used
There are a number of text conventions used throughout this book.

CodeInText: Indicates code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles. For example: “My main project directory is D:\VS Projects\Timber.”

A block of code is set as follows:

```
int playerScore = 0;
char playerInitial = 'J';
float valuePi = 3.141f;
bool isAlive = true;
```

When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:

```
// Make a tree sprite
Texture textureTree;
textureTree.loadFromFile("graphics/tree.png");
Sprite spriteTree;
spriteTree.setTexture(textureTree);
spriteTree.setPosition(810, 0);
while (window.isOpen())
{
```

Any command-line input or output is written as follows:

```
# cp /usr/src/asterisk-addons/configs/cdr_mysql.conf.sample
     /etc/asterisk/cdr_mysql.conf
```

Bold: Indicates a new term, an important word, or words that you see on the screen. For instance, words in menus or dialog boxes appear in the text like this. For example: “Select System info from the Administration panel.”

Warnings or important notes appear like this.

Tips and tricks appear like this.
🧩

# 이 책을 최대한 활용하려면
이 책에는 지식 전제 조건이 없습니다. 이 책은 지식이 전혀 없는 게임에서 4개의 플레이 가능한 게임으로 안내하기 때문에 프로그래밍 방법을 알 필요가 없습니다. 비디오 게임을 몇 번 해보셨다면 조금 도움이 될 것입니다.

## 예제 코드 파일 다운로드
이 책의 코드 번들은 GitHub(https://github.com/PacktPublishing/Beginning-C-Game-Programming-Third-Edition 에서 호스팅됩니다. 저희의 풍부한 책과 비디오 카탈로그에 있는 다른 코드 번들들도 https://github.com/PacktPublishing/ 에서 만나보실 수 있습니다. 확인해 보세요!

## 컬러 이미지 다운로드
이 책에 사용된 스크린샷/도면의 컬러 이미지가 포함된 PDF 파일도 제공합니다. 여기에서 다운로드할 수 있습니다: https://packt.link/gp/9781835081747.

## 사용되는 규칙
이 책 전반에 걸쳐 여러 가지 텍스트 규칙이 사용됩니다.

CodeInText: 텍스트, 데이터베이스 테이블 이름, 폴더 이름, 파일 이름, 파일 확장자, 경로 이름, 더미 URL, 사용자 입력 및 트위터 핸들의 코드 단어를 나타냅니다. 예를 들어, "제 주요 프로젝트 디렉토리는 D:\\VS Projects\\Timber입니다."

코드 블록은 다음과 같이 설정됩니다:
```
int playerScore = 0;
char playerInitial = 'J';
float valuePi = 3.141f;
bool isAlive = true;
```

코드 블록의 특정 부분에 주의를 기울이고 싶을 때는 관련 줄이나 항목을 굵게 설정합니다:

```
// Make a tree sprite
Texture textureTree;
textureTree.loadFromFile("graphics/tree.png");
Sprite spriteTree;
spriteTree.setTexture(textureTree);
spriteTree.setPosition(810, 0);
while (window.isOpen())
{
```

Any command-line input or output is written as follows:

```
# cp /usr/src/asterisk-addons/configs/cdr_mysql.conf.sample
/etc/asterisk/cdr_mysql.conf
```

굵게 표시: 화면에 표시되는 새 용어, 중요한 단어 또는 단어를 나타냅니다. 예를 들어 메뉴나 대화 상자의 단어는 다음과 같이 텍스트에 나타납니다. 예를 들어: "관리 패널에서 시스템 정보 선택"

경고나 중요한 메모는 다음과 같이 나타납니다.

팁과 요령은 이렇게 나타납니다.
🧩

# Get in touch
Feedback from our readers is always welcome.

General feedback: Email feedback@packtpub.com and mention the book’s title in the subject of your message. If you have questions about any aspect of this book, please email us at questions@packtpub.com.

Errata: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you reported this to us. Please visit http://www.packtpub.com/submit-errata, click Submit Errata, and fill in the form.

Piracy: If you come across any illegal copies of our works in any form on the internet, we would be grateful if you would provide us with the location address or website name. Please contact us at copyright@packtpub.com with a link to the material.

If you are interested in becoming an author: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please visit http://authors.packtpub.com.

Share your thoughts
Once you’ve read Beginning C++ Game Programming, Third Edition, we’d love to hear your thoughts! Please click here to go straight to the Amazon review page for this book and share your feedback.

Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content.

Download a free PDF copy of this book
Thanks for purchasing this book!

Do you like to read on the go but are unable to carry your print books everywhere?

Is your eBook purchase not compatible with the device of your choice?

Don’t worry, now with every Packt book you get a DRM-free PDF version of that book at no cost.

Read anywhere, any place, on any device. Search, copy, and paste code from your favorite technical books directly into your application.

The perks don’t stop there, you can get exclusive access to discounts, newsletters, and great free content in your inbox daily.

Follow these simple steps to get the benefits:

Scan the QR code or visit the link below:

https://packt.link/free-ebook/9781835081747

Submit your proof of purchase.
That’s it! We’ll send your free PDF and other benefits to your email directly.
🧩

# 연락하기
독자 여러분의 피드백은 언제나 환영합니다.

일반적인 피드백: feedback@packtpub.com 로 이메일을 보내주시고 메시지 제목에 책 제목을 언급해 주세요. 이 책의 어떤 측면에 대해 궁금한 점이 있으시면 questions@packtpub.com 으로 이메일을 보내주세요.

에라타: 저희는 콘텐츠의 정확성을 보장하기 위해 모든 주의를 기울였지만, 실수는 발생합니다. 이 책에서 실수를 발견하셨다면 저희에게 보고해 주시면 감사하겠습니다. http://www.packtpub.com/submit-errata, 에서 에라타 제출을 클릭하고 양식을 작성해 주세요.

불법 복제: 인터넷에서 어떤 형태로든 저희 작품의 불법 복제품을 발견하셨다면, 위치 주소나 웹사이트 이름을 알려주시면 감사하겠습니다. 자료 링크와 함께 copyright@packtpub.com 로 연락해 주세요.

작가가 되고 싶다면: 전문 지식이 있고 책을 쓰거나 기고하는 데 관심이 있는 주제가 있다면, http://authors.packtpub.com 을 방문해 주세요.

당신의 생각을 공유하세요
Beginning C++ Game Programming, Third Edition을 읽으셨다면 여러분의 의견을 듣고 싶습니다! 여기를 클릭하여 이 책의 Amazon 리뷰 페이지로 바로 이동하여 피드백을 공유하세요.

귀하의 리뷰는 저희와 기술 커뮤니티에 중요하며, 훌륭한 품질의 콘텐츠를 제공하는 데 도움이 될 것입니다.

이 책의 무료 PDF 사본 다운로드
이 책을 구매해 주셔서 감사합니다!

이동 중에도 책을 읽는 것을 좋아하지만 인쇄본을 어디에나 가지고 다닐 수는 없나요?

당신의 전자책 구매가 당신이 선택한 기기와 호환되지 않나요?

걱정하지 마세요. 이제 모든 Packt 책에서 무료로 DRM이 없는 PDF 버전의 책을 받을 수 있습니다.

어디서나, 어디서나, 어떤 기기에서든 읽을 수 있습니다. 좋아하는 기술 서적에서 코드를 검색, 복사 및 붙여넣기하여 애플리케이션에 직접 연결하세요.

특전은 여기서 멈추지 않으며, 매일 받은 편지함에서 할인, 뉴스레터 및 훌륭한 무료 콘텐츠를 독점적으로 이용할 수 있습니다.

다음 간단한 단계를 따라 혜택을 받으세요:

QR 코드를 스캔하거나 아래 링크를 방문하세요:

https://packt.link/무료 전자책/9781835081747

구매 증명서를 제출하세요.
그게 다예요! 무료 PDF 및 기타 혜택을 이메일로 직접 보내드리겠습니다.
🧩

| 🏁 0625 Beginning C++ Game Programming | 00 Preface | [ 01 Welcome to Beginning C++ Game Programming, 3Ed ](/packtpub/2025/0625_beginning_c++_game_programming/01_welcome_to_beginning_c++_game_programming,_3ed) ≫ |
|:----:|:----:|:----:|

> (1) Path: packtpub/2025/0625_beginning_c++_game_programming/00_preface __
> (2) Markdown
> (3) Title: 00 Preface
> (4) Short Description: John Horton May 2024 648 pages 3rd Edition
> (5) tags: C++, game
> Book Name: 0625 Beginning C++ Game Programming
> Link: https://subscription.packtpub.com/book/game-development/9781835081747/pref
> create: 2025-06-29 일 13:52:11
> Images: /packtpub/2025/0625_beginning_c++_game_programming_img/ __
> .md Name: 00_preface.md __


---------- cut line ----------

ff-func-key-setting.vi

| q     | w     | e     | r     | t     | y     | u     | i     | o     | p     |
:------:|------:|------:|------:|------:|------:|------:|------:|------:|------:|
|### title | \`\`\` \`\`\` Expl| \`xxx\`|\`xxx\`|\`xxx\`|\`xxx\`|\`xxx\`|\`xxx \`|\`xxx \`| 없 음 |
| a     | s     | d     | f     | g     | h     | j     | k     | l     |
| 없 음 | 없 음 | \*\*xxx\*\*| \*\*xxx\*\*| \*\*xxx\*\*| \*\*xxx\*\*| \*\*xxx\*\*| \*\*xxx\*\*| \*\*xxx\*\*|

마크다운 입력시 vi 커맨드 표시 ; (^[)=Ctrl+[ ; (^M)=Ctrl+M
인용구 작성시 ; 본문앞에는 꺽쇠 > 붙이고, 스타일 첨가시 끝줄에 종류별 구분을 표시한다.
https://docs.requarks.io/en/editors/markdown > Blockquotes > Stylings >
blue= {.is-info} ; green= {.is-success} ; yellow= {.is-warning} ; red= {.is-danger}

---------- cut line ----------
