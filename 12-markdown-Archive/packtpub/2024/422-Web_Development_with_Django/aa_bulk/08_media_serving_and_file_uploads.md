
| ≪ [ 07 Advanced Form Validation and Model Forms ](/packtpub/2024/422-web_development_with_django_2ed/07_advanced_form_validation_and_model_forms) | 08 Media Serving and File Uploads | [ 09 Sessions and Authentication ](/packtpub/2024/422-web_development_with_django_2ed/09_sessions_and_authentication) ≫ |
|:----:|:----:|:----:|

# 08 Media Serving and File Uploads

Packt Logo

Book image


Media Serving and File Uploads
Media files refer to extra files that can be added after deployment to enrich your Django application. Usually, they are extra images that you would use in your site, but any type of file (including video, audio, PDF, text, documents, or even HTML) can be served as media.

You can think of them as somewhere between dynamic data and static assets. They aren’t dynamic data that Django generates on the fly, such as when rendering a template. They also aren’t the static files that are included by the site developer when the site is deployed. Instead, they are extra files that can be uploaded by users or generated by your application for later retrieval.

Some common examples of media files (that you’ll see in Activity 8.01 – image and PDF upload of books, later in this chapter) are book covers and preview PDFs that can be attached to a Book object. You can also use media files to allow users to upload images for a blog post or avatars for a social media site. If you wanted to use Django to build your own video-sharing platform, you would store the uploaded videos as media. Your website will not function well if all these files are static files, as users won’t be able to upload their own book covers, videos, and so on and will be stuck with the ones you deployed.

In this chapter, we will be covering the following topics:

Settings for media uploads and serving
File uploads using HTML forms
File uploads with Django forms
Image uploads with Django forms
Serving uploaded (and other) files using Django
ModelForms and file uploads
Activity 8.01 – image and PDF upload for books
Activity 8.02 – displaying cover and sample link
Technical requirements
The code for the exercises and activities in this chapter can be found in this book’s GitHub repository at https://github.com/PacktPublishing/Web-Development-with-Django-Second-Edition/tree/main/Chapter08.

Settings for media uploads and serving
In Chapter 5, Serving Static Files, we looked at how Django can be used to serve static files. Serving media files is quite similar. Two settings must be configured in settings.py: MEDIA_ROOT and MEDIA_URL. These are analogous to STATIC_ROOT and STATIC_URL for serving static files.

MEDIA_ROOT: This is the path on the disk where the media (such as uploaded files) will be stored. As with static files, your web server should be configured to serve directly from this directory to take the load off Django.
MEDIA_URL: This is similar to STATIC_URL, but as you might guess, it’s the URL that should be used to serve media. It must end in /. Generally, you will use something such as /media/.
Note

For security reasons, the path for MEDIA_ROOT must not be the same as the path for STATIC_ROOT, and MEDIA_URL must not be the same as STATIC_URL. If they were the same, a user might replace your static files (such as JavaScript or CSS files) with malicious code and exploit your users.

MEDIA_URL is designed to be used in templates so that you don't hardcode URLs, and can change them easily. For example, you might want to set it to a specific host or content delivery network (CDN) when you deploy to production. We will discuss the use of MEDIA_URL in templates in an upcoming section.

Serving media files in development
As with static files, when serving media in production, your web server should be configured to serve directly from the MEDIA_ROOT directory to prevent Django from being tied up in servicing the request. The Django dev server can serve media files in development. However, unlike static files, the URL mapping and view are not set up automatically for media files.

Django provides the static URL mapping that can be added to your existing URL maps to serve media files. It is added to your urls.py file like this:

from django.conf import settings
from django.conf.urls.static import static
urlpatterns = [
    # your existing URL maps
]
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL,
    document_root=settings.MEDIA_ROOT)

Copy

Explain
This will serve the MEDIA_ROOT setting defined in settings.py to the MEDIA_URL setting that is also defined there. The reason we check for settings.DEBUG before appending the map, so we don’t add this map in production.

For example, if your MEDIA_ROOT was set to /var/www/bookr/media, and your MEDIA_URL was set to /media/, then the /var/www/bookr/media/image.jpg file would be available at http://127.0.0.1:8000/media/image.jpg.

The static URL map does not work when the Django DEBUG setting is False, so it can’t be used in production. However, as has been mentioned, in production, your web server should be serving these requests so Django will not need to handle them.

In the first exercise, you will create a new add MEDIA_ROOT and MEDIA_URL to your settings.py. You will then add the static media serving URL map and add a test file to ensure media serving is configured correctly.

Exercise 8.01 – configuring media storage and serving
In this exercise, you will set up a new Django project as an example project to use throughout this chapter. Then, you’ll configure it to be able to serve media files. You’ll do this by creating a media directory and adding the MEDIA_ROOT and MEDIA_URL settings. Then you’ll set up the URL mapping for MEDIA_URL.

To check that everything is configured and being served correctly, you will put a test file inside the media directory:

As with the previous example Django projects you’ve set up, you can reuse the existing bookr virtual environment. In a terminal, activate the bookr virtual environment. Then, start a new project named media_project using django-admin.py:
Note

To learn how to create and activate a virtual environment, refer to the Preface section of this book.

django-admin startproject media_project

Copy

Explain
Change (or cd into) into the media_project directory that was created, then use the startapp management command to start an app called media_example:

python3 manage.py startapp media_example

Copy

Explain
Open the media_project directory in PyCharm. Set up a run configuration for the runserver command in the same manner as for the other Django projects you’ve opened:
Figure 8.1–﻿ Runserver configuration
Figure 8.1– Runserver configuration

Figure 8.1 shows the Runserver configuration of the project in PyCharm.

Create a new directory named media inside the media_project project directory. Then, create a new file in this directory named test.txt. The directory structure of this will look like Figure 8.2:
Figure 8.2: The media directory and the test.txt layout
Figure 8.2: The media directory and the test.txt layout

The test.txt file will also open automatically. Enter Hello, world! into it, then you can save and close the file.
Open settings.py inside the media_project package directory. At the end of the file, add a setting for MEDIA_ROOT using the path to the media directory you just created. Join the name of the directory (media) onto BASE_DIR:
MEDIA_ROOT = BASE_DIR / "media"

Copy

Explain
Directly below the line added in step 5, add another setting for MEDIA_URL; this should just be "/media/":
MEDIA_URL = "/media/"

Copy

Explain
With these changes made, settings.py should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.01/media_project/media_project/settings.py.

Open the media_project package’s urls.py file. After the urlpatterns definition, add the following code to add the media serving URL if running in the DEBUG mode. First, you will need to import the Django settings and static serving view by adding the highlighted import lines above the urlpatterns definition:
from django.contrib import admin
from django.urls import path
from django.conf import settings
from django.conf.urls.static import static
urlpatterns = [
    path("admin/", admin.site.urls),
]

Copy

Explain
Then, add the following code right after your urlpatterns definition (refer to the code block in the previous step) to conditionally add a mapping from the MEDIA_URL setting to the static view, which will serve from MEDIA_ROOT:
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL,
    document_root=settings.MEDIA_ROOT)

Copy

Explain
You can now save this file. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.01/media_project/media_project/urls.py.

Start the Django dev server, if it is not already running, then visit http://127.0.0.1:8000/media/test.txt. If you did everything correctly, you should see the Hello, world! text in your browser:
Figure 8.3: Serving a media file
Figure 8.3: Serving a media file

If your browser looks like Figure 8.3, it means that the media files are being served from the MEDIA_ROOT directory.

The test.txt file we created was just for testing, but we will use it in Exercise 8.02 – template settings, and using MEDIA_URL in templates, so don’t delete it yet.

In this exercise, we configured Django to serve media files. We served a test file just to make sure everything worked as expected, and it did. We’ll now look at how we can automatically generate media URLs in templates.

Context processors and using MEDIA_URL in templates
To use MEDIA_URL in a template, we could pass it in through the rendering context dictionary in our view. For example, as shown in the following code block:

from django.conf import settings
def my_view(request):
    return render(request, "template.html", {"MEDIA_URL":
    settings.MEDIA_URL, "username": "jbloggs"})

Copy

Explain
This will work, but the problem is that MEDIA_URL is a common variable that we might want to use in many places, so we’d have to pass it through in practically every view.

Instead, we can use a context processor, which is a way of adding one or more variables automatically to the context dictionary on every render call.

A context processor is a function that accepts one argument, the current request. It returns a dictionary of context information that will be merged with the dictionary that was passed to the render call.

We can look at the source code of the media context processor, which illustrates how they work:

def media(request):
    """
    Add media-related context variables to the context.
    """
    return {"MEDIA_URL": settings.MEDIA_URL}

Copy

Explain
With the media context processor activated, MEDIA_URL will be added to your context dictionaries. We could change our render call, seen previously, to this:

return render(request, "template.html", {"username": "jbloggs"})

Copy

Explain
The same data would be sent to the template, as the context processor would add MEDIA_URL.

The full module path to the media context processor is django.template.context_processors.media. Some examples of other context processors that Django provides are the following:

django.template.context_processors.debug: This returns the {"DEBUG": settings.DEBUG} dictionary.
django.template.context_processors.request: This returns the {"request": request} dictionary; that is, it just adds the current HTTP request to the context.
To enable a context processor, its module path must be added to the context_processors option of your TEMPLATES setting. For example, to enable the media context processor, add django.template.context_processors.media. We will cover how to do this in detail in Exercise 8.02 – Template settings and using MEDIA_URL in templates.

Once the media context processor is enabled, the MEDIA_URL variable can be accessed inside a template just like a normal variable:

{{ MEDIA_URL }}

Copy

Explain
You could use it, for example, to source an image:

<img src="{{ MEDIA_URL }}uploads/image.jpg">

Copy

Explain
Note that, unlike with static files, there is no template tag for loading media files (i.e., there is no equivalent to the {% static %} template tag).

Custom context processors can also be written. For example, referring back to the Bookr application that we built, we might want to show a list of the five latest reviews in a sidebar that’s on every page. A context processor like this would perform the following code:

from reviews.models import Review
def latest_reviews(request):
    return {"latest_reviews": Review.objects.order_by("-
    date_created")[:5]}.

Copy

Explain
This would be saved in a file named context_processors.py in the Bookr project directory, then referred to in the context_processors setting by its module path, context_processors.latest_reviews. Or we could save it inside the reviews app and refer to it as reviews.context_processors.latest_reviews. It is up to you to decide whether a context processor should be considered project-wide or app specific. However, bear in mind that regardless of where it is stored, once activated, it applies to all the render calls for all apps.

A context processor can return a dictionary with multiple items or even zero items. It would do this if it had conditions to only add items if certain criteria were met. For example, show the latest reviews only if the user is logged in.

Let us explore this in detail in the next exercise.

Exercise 8.02 – template settings and using MEDIA_URL in templates
In this exercise, you will continue with media_project and configure Django to automatically add the MEDIA_URL setting to every template. You do this by adding django.template.context_processors.media to the TEMPLATES context_processors setting. You’ll then add a template that uses this new variable and an example view to render it. You will make changes to the view and template throughout the exercises in this chapte:

In PyCharm, open settings.py. First, you’ll need to add media_example to the INSTALLED_APPS setting since it wasn’t done when the project was set up:
INSTALLED_APPS = [
    # other apps truncated for brevity
    "media_example",
]

Copy

Explain
About halfway down the file, you’ll find the TEMPLATES setting, which is a dictionary. Inside it is the OPTIONS item (another dictionary). Inside OPTIONS is the context_processors setting.
Add the following to the end of this list:

"django.template.context_processors.media"

Copy

Explain
The full list should look like this:

TEMPLATES = [
    {
        "BACKEND":
            "django.template.backends.django
            .DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors
                    .debug",
                "django.template.context_processors
                    .request",
               "django.contrib.auth.context_processors
                   .auth",
                "django.contrib.messages
                    .context_processors.messages",
                "django.template.context_processors
                    .media",
            ],
        },
    },
]

Copy

Explain
The complete file should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.02/media_project/media_project/settings.py.

Open the media_example app’s views.py file and create a new view called media_example. For now, it can just render a template named media-example.html (you will create this in step 5). The entire code of the view function is like this:
def media_example(request):
    return render(request, "media-example.html")

Copy

Explain
Save views.py. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.02/media_project/media_example/views.py.

You need a URL mapping to the media_example view. Open the media_project package’s urls.py file.
First, import media_example.views with the other imports in the file:

import media_example.views

Copy

Explain
Then add path into urlpatterns to map media-example/ to the media_example view:

path('media-example/',
media_example.views.media_example)

Copy

Explain
Your full urlpatterns should look like this code block:

from django.conf.urls.static import static
import media_example.views
urlpatterns = [
    path("admin/", admin.site.urls),
    path("media-example/",
    media_example.views.media_example)
]
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL,
    document_root=settings.MEDIA_ROOT)

Copy

Explain
You can save and close the file.

Create a templates directory inside the media_example app directory. Then, create a new HTML file inside the media_project project templates directory. Select HTML 5 file and name the file media-example.html:
Figure 8.4: Creating media-example.html
Figure 8.4: Creating media-example.html

The media-example.html file should open automatically. You are just going to add a link inside the file to the test.txt file you created in Exercise 8.01 – configuring media storage and serving. Inside the <body> element, add the highlighted code:
<body>
    <a href="{{ MEDIA_URL }}test.txt">Test Text
    File</a>
</body>

Copy

Explain
Note that there is no / between MEDIA_URL and the file name – this is because we already added a trailing slash when we defined it in settings.py. You can save the file. The complete file will look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.02/media_project/media_example/templates/media-example.html.

Start the Django dev server if it’s not already running, then visit http://127.0.0.1:8000/media-example/. You should see a simple page like in Figure 8.5:
Figure 8.5: Basic media link page
Figure 8.5: Basic media link page

If you click the link, you will be taken to the test.txt display and see the Hello, world! text you created in Exercise 8.01 – configuring media storage and serving (Figure 8.5). This means you have configured the Django context_processors settings correctly.

We have finished with test.txt, so you can delete the file now. We will use the media_example view and template in the other exercises, so retain them. In the next section, we will talk about how to upload files using a web browser and how Django accesses them in a view.

File uploads using HTML forms
In Chapter 6, Forms, we learned about HTML forms. We discussed how to use the method attribute of <form> for the GET or POST requests. And so far, we have only submitted text data using a form, but it is also possible to submit one or more files using a form.

When submitting files, we must ensure that there are at least two attributes on the form: method and enctype. You may still also need other attributes, such as action. A form that supports file uploads might look like this:

<form method="post" enctype="multipart/form-data">

Copy

Explain
File uploads are only available for POST requests. They are not possible with GET requests, as it would be impossible to send all the data for a file through a URL. The enctype attribute must be set to let the browser know it should send the form data as multiple parts, one part for the text data of the form and separate parts for each of the files that have been attached to the form. This encoding is seamless to the user, they don’t know how the browser is encoding the form, nor do they need to do anything different.

To attach files to a form, you need to create an input of the file type. You can manually write the HTML code like this:

<input type="file" name="file-upload-name">

Copy

Explain
When the input is rendered in the browser, it looks like this when empty:

Figure 8.6: Empty file input
Figure 8.6: Empty file input

The title of the button might be different depending on your browser.

Clicking the Browse… button will display a file open dialog box:

Figure 8.7: File browser on macOS
Figure 8.7: File browser on macOS

After selecting a file, the name of the file is shown in the field:

Figure 8.8: File input with cover.jpg selected
Figure 8.8: File input with cover.jpg selected

Figure 8.8 shows a file input with a file named cover.jpg having been selected.

We briefly looked at how file upload fields look in the browser, let’s start looking at the Django side of the file upload process.

Working with uploaded files in a view
In addition to text data, if a form also contains file uploads, Django will populate the request.FILES attribute with uploaded files. The request.FILES attribute is a dictionary-like object that is keyed on the name attribute given to the file input.

In the form example in the previous section, the file input had the name file-upload-name. So the file would be accessible in the view using request.FILES["file-upload-name"].

The objects that request.FILES contains are file-like objects (specifically a django.core.files.uploadedfile.UploadedFile instance), so to use them, you must read their data. For example, to get the content of an uploaded file in your view, you can write the following:

content = request.FILES["file-upload-name"].read()

Copy

Explain
A more common action is to write the file contents to disk. When files are uploaded, they are stored in a temporary location (in memory if they are under 2.5 MB, otherwise in a temporary file on disk). To store the file data in a known location, the contents must be read and then written to disk at that location. UploadedFile has a chunks method that will read the file data one chunk at a time to prevent too much memory from being used by reading the entirety of the file at once.

So, instead of simply using the read and write functions, use the chunks method to only read small chunks of the file into memory at a time:

with open("/path/to/output.jpg", "wb+") as output_file:
    uploaded_file = request.FILES["file-upload-name"]
    for chunk in uploaded_file.chunks():
        output_file.write(chunk)

Copy

Explain
Note that in some of the upcoming examples, we will refer to this code as the save_file_upload function. Assume the function is defined like this:

def save_file_upload(upload, save_path):
    with open(save_path, "wb+") as output_file:
        for chunk in upload.chunks():
            output_file.write(chunk)

Copy

Explain
The previous example code could then be refactored to call the function:

uploaded_file = request.FILES["file-upload-name"]
save_file_upload(uploaded_file, "/path/to/output.jpg")

Copy

Explain
Each UploadedFile object (the uploaded_file variable in the previous example code snippets) also contains extra metadata about the uploaded file, such as the file’s name, size, and content type. The attributes you’ll find most useful are the following:

size: As the name suggests, this is the size of the uploaded file in bytes.
name: This refers to the name of the uploaded file, for example, image.jpg, file.txt, document.pdf, and so on. This value is sent by the browser.
content_type: The content type (MIME type) of the uploaded file. For example, image/jpeg, text/plain, application/pdf, and so on. Like name, this value is sent by the browser.
charset: This refers to the charset or text encoding of the uploaded file for text files. This will be something like UTF-8 or ASCII. Once again, this value is also determined and sent by the browser.
Here is a quick example of accessing these attributes (such as inside a view):

upload = request.FILES["file-upload-name"]
size = upload.size
name = upload.name
content_type = upload.content_type
charset = upload.charset

Copy

Explain
Security and trust of browsers’ sent values
As we just described, UploadedFile values for name, content_type, and charset are determined by the browser. This is important to consider because a malicious user could send fake values in place of real ones to disguise the actual files being uploaded. Django does not automatically try to determine the content type or charset of the uploaded file, so it relies on the client to be accurate when it sends this information.

If we manually handle the saving of tile uploads without suitable checks, then a scenario like this could happen:

A user of the site uploads a malicious malware.exe executable but sends the image/jpeg content type.
Our code checks the content type and considers it to be safe, so it saves malware.exe to the MEDIA_ROOT file.
Another user of the site downloads what they think is a book cover image but is the malware.exe executable. They open the file, and their computer is infected with malware.
This scenario has been simplified, the malicious file would probably have a name that wasn’t so obvious (maybe something like cover.jpg.exe), but the general process has been illustrated.

How you choose to handle the security of your uploads will depend on the specific use case, but for most cases, these tips will help:

When you save the file to disk, generate a name instead of using the one provided by the uploader. You should replace the file extension with what you expect. For example, if a file is named cover.exe, but the content type is image/jpeg, save the file as cover.jpg. You could also generate a completely random filename for extra security.
Check that the filename extension matches the content type. This method is not foolproof, as there are so many MIME types that if you are handling uncommon files you might not get a match. The built-in Python mimetypes module can help you here. Its guess_type function takes a filename and returns a mimetype tuple (content type) and encoding. Here’s a short snippet showing its use in a Python console:
>>> import mimetypes
>>> mimetypes.guess_type('file.jpg')
('image/jpeg', None)
>>> mimetypes.guess_type('text.html')
('text/html', None)
>>> mimetypes.guess_type('unknownfile.abc')
(None, None)
>>> mimetypes.guess_type('archive.tar.gz')
('application/x-tar', 'gzip')

Copy

Explain
Either element of the tuple might be None if the type or encoding can’t be guessed. Once imported into your file by doing import mimetypes, you can use it like this in your view function:

upload = request.FILES["file-upload-name"]
mimetype, encoding = mimetypes.guess_type(upload.name)
if mimetype != upload.content_type:
    raise TypeError("Mimetype doesn't match file
    extension.")

Copy

Explain
This method will work for common file types such as images but as mentioned, many uncommon types may return None for mimetype.

If you are expecting image uploads, use the Pillow library to try to open the uploaded file as an image. If it is not a valid image, then Pillow will be unable to open it. This is what Django does when using ImageField to upload images. We will show how to use this technique to open and manipulate an image in Exercise 8.05 – image uploads using Django forms.
You can also consider the python-magic Python package, which examines the actual content of files to try to determine their type. It is installed using PIP, and its GitHub project is found here: https://github.com/ahupp/python-magic. Once installed and imported into your file with import magic, you can use it like this in your view function:
upload = request.FILES["field_name"]
mimetype = magic.from_buffer(upload.read(2048),
mime=True)

Copy

Explain
You can then verify that mimetype is in a list of allowed types.

This is not a definitive list of all the ways of protecting against malicious file uploads. The best approach will depend on what type of application you are building. You might build a site for hosting arbitrary files, in which case you wouldn’t need any kind of content checking at all.

Let us now see how we can build an HTML form and view that allows files to be uploaded. We will then store them inside the media directory and retrieve the downloaded files in our browser.

Exercise 8.03 – file upload and download
In this exercise, you will add a form with a file field to the media-example.html template. This will allow you to upload a file to the media_example view using your browser. You’ll also update the media_example view to save the file to the MEDIA_ROOT directory so that it’s available for download. You will then test that this all works by downloading the file again:

In PyCharm, open the media-example.html template located inside the templates folder. Inside the <body> element, remove the <a> link that was added in step 6 of Exercise 8.02 – template settings and using MEDIA_URL in templates. Replace it with a <form> element (highlighted in the following code snippet). Make sure the opening tag has method="post" and enctype="multipart/form-data":
</head>
<body>
    <form method="post" enctype="multipart/form-data">
    </form>
</body>

Copy

Explain
Insert the {% csrf_token %} template tag inside the <form> body.
After {% csrf_token %}, add an <input> element, with type="file" and name="file_upload":
<input type="file" name="file_upload">

Copy

Explain
Finally, before the closing </form> tag, add a <button> element with type="submit" and the Submit text content:
<button type="submit">Submit</button>

Copy

Explain
Your HTML body should now look like this:

<body>
    <form method="post" enctype="multipart/form-data">
        {% csrf_token %}
        <input type="file" name="file_upload">
        <button type="submit">Submit</button>
    </form>
</body>

Copy

Explain
Now, save and close the file. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.03/media_project/media_example/templates/media-example.html.

Open the media_example app’s views.py file. Inside the media_example view, add code to save the uploaded file to the MEDIA_ROOT directory. For this, you need access to MEDIA_ROOT from settings, so import the Django settings at the top of the file:
from django.conf import settings

Copy

Explain
The uploaded file should only be saved if the request method is POST. Inside the media_example view, add an if statement to validate that request.method is POST:
def media_example(request):
    if request.method == "POST":
        …

Copy

Explain
Inside the if statement added in the previous step, generate the output path by joining the uploaded filename to the MEDIA_ROOT directory. Then, open this path in the wb mode and iterate over the uploaded file using the chunks method. Finally, write each chunk to the saved file:
def media_example(request):
    if request.method == 'POST':
        save_path = settings.MEDIA_ROOT /
        request.FILES["file_upload"].name
        with open(save_path, "wb") as output_file:
            for chunk in
            request.FILES["file_upload"].chunks():
                output_file.write(chunk)
    return render(request, "media-example.html")

Copy

Explain
Note that the uploaded file and its metadata are being accessed from the request.FILES dictionary using the key that matches the name given to the file input (in our case, this is file_upload). You can save and close views.py. It should now look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.03/media_project/media_example/views.py.

Start the Django dev server if it’s not already running, then navigate to http://127.0.0.1:8000/media-example/. You should see the file upload field and the Submit button, as can be seen here:
Figure 8.9: The file upload form
Figure 8.9: The file upload form

Click Browse… (or the equivalent on your browser) and select a file to upload. The name of the file will appear in the file input. Then, click Submit.

The page will reload, and the form will be empty again. This is normal – in the background, the file should have been saved.

Try to download the file you uploaded using MEDIA_URL. In this example, a file named cover.jpg was uploaded. It will be downloadable at http://127.0.0.1:8000/media/cover.jpg. Your URL will depend on the name of the file you uploaded:
Figure 8.10: Uploaded file visible inside MEDIA_URL
Figure 8.10: Uploaded file visible inside MEDIA_URL

If you upload an image file, HTML file, or another type of file your browser can display, you will be able to view it inside the browser. Otherwise, your browser will just download it to disk again. In both cases, it means the upload was successful.

You can also confirm the upload was successful by looking inside the media directory in the media_project project directory:

Figure 8.11: cover.jpg inside the media directory
Figure 8.11: cover.jpg inside the media directory

Figure 8.11 shows the cover.jpg file inside the media directory in PyCharm.

In this exercise, you added an HTML form with enctype set to multipart/form-data so that it allowed file uploads. It contained a file input to select a file to upload. You then added a saving functionality to the media_example view to save the uploaded file to disk.

In the next section, we will look at how to simplify form generation and add validation using Django forms for file upload handling.

File uploads with Django forms
In Chapter 6, Forms, we saw how Django makes it easy to define forms and automatically render them to HTML. In the previous example, we defined our form manually and wrote the HTML. We can replace this with a Django form and implement the file input with a FileField constructor.

Here’s how FileField is defined on a form:

from django import forms
class ExampleForm(forms.Form):
    file_upload = forms.FileField()

Copy

Explain
The FileField constructor can take the following keyword arguments:

Required: This should be True for required fields and False if the field is optional
max_length: This refers to the maximum length of the filename of the file being uploaded
allow_empty_file: A field with this argument is considered to be valid even if the uploaded file is empty (has a size of 0)
Apart from these three keyword arguments, the constructor can also accept the standard Field arguments, such as widget. The default widget class for FileField is ClearableFileInput; this is a file input that can display a checkbox that can be checked to send a null value and clear the saved file on a Model field.

Using a form with a FileField constructor in a view is similar to other forms, but when the form has been submitted (i.e., request.METHOD is POST), then request.FILES should be passed into the form constructor as well. This is because Django needs to access request.FILES to find information about uploaded files when validating the form.

The basic flow in a view function is, therefore, similar to this:

def view(request):
    if request.method == "POST":
        # instantiate the form with POST data and files
        form = ExampleForm(request.POST, request.FILES)
        if form.is_valid():
            # process the form and save files
            return redirect("success-url")
    else:
        # instantiate an empty form as we've seen before
        form = ExampleForm()
    # render a template, the same as for other forms
    return render(request, "template.html", {"form": form})

Copy

Explain
When working with uploaded files and forms, you can interact with the uploaded files by accessing them through request.FILES, or through form.cleaned_data; the values will return to the same object. In the preceding example, we could process the uploaded file like this:

if form.is_valid():
    save_file_upload("/path/to/save.jpg",
        request.FILES["file_upload"])
    return redirect("/success-url/")

Copy

Explain
Or, since they contain the same object, you can use form.cleaned_data:

if form.is_valid():
    save_file_upload("/path/to/save.jpg",
        form.cleaned_data["file_upload"])
    return redirect("/success-url/")

Copy

Explain
The data that is saved will be the same.

Note

In Chapter 6, Forms, you experimented with forms and submitted them with invalid values. When the page refreshed to show the form errors, the data that you had previously entered was populated when the page reloaded. This does not occur with file fields; instead, the user will have to navigate and select the file again if the form is invalid.

In the next exercise, we will put what we have seen with FileFields into practice by building an example form and then modifying our view to save the file only if the form is valid.

Exercise 8.04 – file uploads with a Django form
In the previous exercise, you created a form in HTML and used it to upload a file to a Django view. If you tried submitting the form without selecting a file, you would get a Django exception screen. You did not do any validation on the form, so this method is quite fragile.

In this exercise, you will create a Django form with FileField, which will allow you to use form validation functions to make the view more robust as well as reduce the amount of code:

In PyCharm, inside the media_example app, create a new file named forms.py. It will open automatically. At the start of the file, import the Django forms library:
from django import forms

Copy

Explain
Then, create a forms.Form subclass, and name it UploadForm. Add to it a FileField field named file_upload. Your class should have this code:

class UploadForm(forms.Form):
    file_upload = forms.FileField()

Copy

Explain
You can save and close this file. The complete file should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.04/media_project/media_example/forms.py.

Open the form_example app’s views.py file. At the start of the file, right below the existing import statements, you will need to import your new class like this:
from .forms import UploadForm

Copy

Explain
If you are in the POST branch of the view, UploadForm needs to be instantiated with both request.POST and request.FILES. If you don’t pass in request.FILES, then the form instance will not be able to access the uploaded files. Under the if request.method == "POST" check, instantiate UploadForm with these two arguments:
form = UploadForm(request.POST, request.FILES)

Copy

Explain
The existing lines that define save_path and store the file contents can be retained, but they should be indented by one block and put inside a form validity check, so they are only executed if the form is valid. Add the if form.is_valid(): line, and then indent the other lines, so the code looks like this:
if form.is_valid():
    save_path = os.path.join(settings.MEDIA_ROOT,
    request.FILES["file_upload"].name)
    with open(save_path, "wb") as output_file:
        for chunk in
        request.FILES["file_upload"].chunks():
            output_file.write(chunk)

Copy

Explain
Since you are using a form now, you can access the file upload through the form. Replace usages of request.FILES["file_upload"] with form.cleaned_data["file_upload"]:
if form.is_valid():
    save_path = settings.MEDIA_ROOT /
    form.cleaned_data["file_upload"].name
    with open(save_path, "wb") as output_file:
        for chunk in
        form.cleaned_data["file_upload"].chunks():
            output_file.write(chunk)

Copy

Explain
Finally, add an else branch to handle non-POST requests, which simply instantiates a form without any arguments:
if request.method == "POST":
    …
else:
    form = UploadForm()

Copy

Explain
Add a context dictionary argument to the render call and set the form variable in the form key:
return render(request, "media-example.html", {"form":
form})

Copy

Explain
You can now save and close this file. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.04/media_project/media_example/views.py.

Finally, open the media-example.html template and remove your manually defined <input> file. Replace it with form, rendered using the as_p method (highlighted):
<body>
    <form method="post" enctype="multipart/form-data">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Submit</button>
    </form>
</body>

Copy

Explain
You should not change any other parts of the file. You can save and close this file. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.04/media_project/media_example/templates/media-example.html.

Start the Django dev server if it’s not already running, then navigate to http://127.0.0.1:8000/media-example/. You should see the file upload field and the Submit button as follows:
Figure 8.12: The file upload Django form rendered in the browser
Figure 8.12: The file upload Django form rendered in the browser

Since we’re using a Django form, we get its built-in validation automatically. If you try to submit the form without selecting a file, your browser should prevent it and show an error, as can be seen here:
Figure 8.13: Form submission prevented by the browser
Figure 8.13: Form submission prevented by the browser

Finally, repeat the upload test that you performed in Exercise 8.03 – file upload and download, by selecting a file and submitting the form. You should then be able to retrieve the file using MEDIA_URL. In this case, a file named cover.jpg is being uploaded again (see the following screenshot):
Figure 8.14: Uploading a file named cover.jpg
Figure 8.14: Uploading a file named cover.jpg

You can then retrieve the file at http://127.0.0.1:8000/media/cover.jpg, and you can see it in the browser as follows:

Figure 8.15: The file uploaded using the Django form is also visible in the browser
Figure 8.15: The file uploaded using the Django form is also visible in the browser

In this exercise, we replaced a manually built form with a Django form containing FileField. We instantiated the form in the view by passing in both request.POST and request.FILES. We then used the standard is_valid method to check the validity of the form and only saved the file upload if the form was valid. We tested the file uploading and saw we were able to retrieve uploaded files using MEDIA_URL.

In the next section, we will look at ImageField, which is like FileField, but specifically for images.

Image uploads with Django forms
If you want to work with images in Python, the most common library that you’ll use is called Pillow, and this is the library Django uses to validate images. Originally there was a library called Python Imaging Library (PIL). It was not kept up to date and, eventually, a fork of the library was created and is still maintained, Pillow. To maintain backward compatibility, the package is still called PIL when installed. For example, the Image object is imported from PIL:

from PIL import Image

Copy

Explain
The terms Python Imaging Library, PIL, and Pillow are often used interchangeably. You can assume that if someone refers to PIL, they mean the latest Pillow library.

Pillow provides various methods of retrieving data about images or manipulating them. You can find out the width and height of images, scale, crop, and apply transformations to them. There are too many operations available to cover in this chapter, so we will just introduce a simple example (scaling an image), which you will use in the next exercise.

Since images are one of the most common types of files that a user may want to upload, Django also includes ImageField. This behaves similarly to FileField but also automatically validates that the data is an image file. This helps mitigate against security issues where we expect an image, but the user uploads a malicious file.

An UploadedFile from an ImageField has all the same attributes and methods as that of FileField (size, content_type, name, chunks(), etc.) but adds an extra attribute: image. This is an instance of the PIL Image object that is used to verify that the file being uploaded is a valid image.

After checking that the form is valid, the underlying PIL Image object is closed. This is done to free up memory and prevent the Python process from holding too many files open, which could cause performance issues. What this means for the developer is that you can access some of the metadata about the image (such as width, height, and format), but you can’t access the actual image data without re-opening the image.

To illustrate, we’ll have a form with ImageField, named picture:

class ExampleForm(forms.Form):
    picture = forms.ImageField()

Copy

Explain
Inside the view function, the picture field can be accessed in the form’s cleaned_data:

if form.is_valid():
    picture_field = form.cleaned_data["picture"]

Copy

Explain
Then, the picture field’s Image object can be retrieved:

image = picture_field.image

Copy

Explain
Now that we have a reference to the image in the view, we can get some metadata:

w = image.width  # an integer, e.g. 600
h = image.height  # also an integer, e.g. 420
f = image.format  # the format of the image as a string, e.g. "PNG"

Copy

Explain
Django will also automatically update the content_type attribute of UploadedFile to the correct type for the picture field. This overwrites the value that the browser has sent when uploading the file.

Attempting to use a method that accesses the actual image data (rather than just the metadata) will cause an exception to be raised. This is because Django has already closed the underlying image file.

For example, the following code snippet will raise AttributeError:

image.getdata()

Copy

Explain
Instead, we need to re-open the image. The image data can be opened with the ImageField reference after importing the Image class:

from PIL import Image
image = Image.open(picture_field)

Copy

Explain
Now that the image has been opened, you can perform operations on it. In the next section, we will look at a simple example – resizing the uploaded image.

Resizing an image with Pillow
Pillow supports many operations that you might want to perform on an image before saving it. We can’t explain them all in this book, so we will just use a common operation: resizing an image to a specific size before saving it. This will help us save storage space and improve download speed. For example, a user may upload large cover images in Bookr that are bigger than are needed for our purposes. When saving the file (writing it back to disk), we must specify the format to use. We could determine the type of image being uploaded with a number of methods (such as checking content_type of the uploaded file or format from the Image object), but in our example, we’ll always just save it as a JPEG file.

The PIL Image class has a thumbnail method that will resize an image to a maximum size while retaining the aspect ratio. For example, we could set a maximum size of 50 pixels (px) by 50 px. A 200 px by 100 px image would be resized to 50 px by 25 px: the aspect ratio is retained by setting the maximum dimension to 50 px. Each dimension is scaled by a factor of 0.25:

from PIL import Image
size = 50, 50  # a tuple of width, height to resize to
image = Image.open(image_field)  # open the image as before
image.thumbnail(size)  # perform the resize

Copy

Explain
At this point, the resize has been done in memory only. The change is not saved to disk until the save method is called, like so:

image.save("path/to/file.jpg")

Copy

Explain
The output format is automatically determined from the file extension used, in this case, JPEG. The save method can also take a format argument to override it, for example:

image.save("path/to/file.png", "JPEG")

Copy

Explain
Despite having the .png extension, the format is specified as JPEG, and so the output will be in JPEG format. As you might imagine, this can be very confusing, so you might decide to stick with specifying the extension only.

In the next exercise, we will change UploadForm we have been working with to use ImageField instead of FileField, then implement resizing of an uploaded image before saving it to the media directory.

Exercise 8.05 – image uploads using Django forms
In this exercise, you will update the UploadForm class you created in Exercise 8.04 – file uploads with a Django form, to use ImageField instead of FileField (this will involve simply changing the field’s class). You will then see that the form renders the same in the browser. Next, you will try uploading some non-image files and see how Django validates the form to disallow them. Finally, you will update your view to use PIL to resize the image before saving it, and then test it in action:

Open the media_example app’s forms.py file. In the UploadForm class, change file_upload, so that it’s an instance of ImageField instead of FileField. After updating, UploadForm should look like this:
class UploadForm(forms.Form):
    file_upload = forms.ImageField()

Copy

Explain
Save and close the file. Your forms.py file should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.05/media_project/media_example/forms.py.

Start the Django dev server if it’s not already running, then navigate to http://127.0.0.1:8000/media-example/. You should see the form rendered, and it will look identical to when we used FileField (see the following screenshot):
Figure 8.16: ImageField looks the same as FileField
Figure 8.16: ImageField looks the same as FileField

You will notice the difference when you try to upload a non-image file. Click the Browse… button and try to select a non-image file. Depending on your browser or operating system, you might not be able to select anything other than an image file, as in Figure 8.17:
Figure 8.17: Only image files are selectable
Figure 8.17: Only image files are selectable

Your browser may allow you to select an image but show an error in the form after selection. Or your browser may allow you to select a file and submit the form, and Django will raise ValidationError. Regardless, you can be sure that in your view, the form’s is_valid view will only return True if an image has been uploaded.

Note

You don’t need to test uploading a file at this point, as the result would be the same as in Exercise 8.04 – file uploads with a Django form.

The first thing you will need to do is make sure the Pillow library is installed. In a terminal (making sure your virtual environment has been activated), run the following command:
pip3 install pillow

Copy

Explain
(In Windows, this is pip install pillow). You’ll get output like Figure 8.18:

Figure 8.18: pip3 installing pillow
Figure 8.18: pip3 installing pillow

If Pillow is already installed, you’ll see the Requirement already satisfied output message.

Now, we can update the media_example view to resize the image before saving it. Switch back to PyCharm and open the media_example app’s views.py file, then import PIL’s Image class by adding this import line near the top of the file:
from PIL import Image

Copy

Explain
Go to the media_example view. Under the line that generates save_path, take out the three lines that open the output file, iterate over the uploaded file, and write out its chunks. Replace this with the code that opens the uploaded file with PIL, resizes it, then saves it:
image = Image.open(form.cleaned_data["file_upload"])
image.thumbnail((50, 50))
image.save(save_path)

Copy

Explain
The first line creates an Image instance by opening the uploaded file, the next performs the thumbnail conversion (to a maximum size of 50 px by 50 px), and the third line saves the file to the same save path that we have been generating in previous exercises. You can save the file. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.05/media_project/media_example/views.py.

The Django dev server should still be running from step 2, but you should start it if it is not. Then, navigate to http://127.0.0.1:8000/media-example/. You’ll see the familiar UploadForm. Select an image and submit the form. If the upload and resize was successful, the form will refresh and be empty again.
View the uploaded image using MEDIA_URL. For example, a file named cover.jpg will be downloadable from http://127.0.0.1:8000/media/cover.jpg. You should see the image has been resized to have a maximum dimension of just 50 px:
Figure 8.19: The resized cover
Figure 8.19: The resized cover

While a thumbnail this size might not be that useful, it at least lets us be sure that the image resize has worked correctly.

In this exercise, we changed FileField on UploadForm to ImageField. We saw that the browser wouldn’t let us upload anything other than images. We then added code to the media_example view to resize the uploaded image using PIL.

We have encouraged the use of a separate web server to serve static and media files for performance reasons. However, in some cases, you might want to use Django to serve files, for example, to provide authentication before allowing access. In the next section, we will discuss how to use Django to serve media files.

Serving uploaded (and other) files using Django
Throughout this chapter and Chapter 5, Serving Static Files, we have discouraged serving files using Django. This is because it would needlessly tie up a Python process just serving a file – something that the webserver is capable of handling. Unfortunately, web servers do not usually provide dynamic access control, that is, allowing only authenticated users to download a file. Depending on your web server used in production, you might be able to have it authenticate against Django and then serve the file itself; however, the specific configuration of specific web servers is outside the scope of this book.

One approach you can take is to specify a subdirectory of your MEDIA_ROOT directory and have your web server prevent access to just this specific folder. Any protected media should be stored inside it. If you do this, only Django will be able to read the files inside. For example, your web server could serve everything in the MEDIA_ROOT directory except for a MEDIA_ROOT/protected directory.

Another approach would be to configure a Django view to serve a specific file from disk. The view will determine the path of the file on disk to send, then send it using the FileResponse class. The FileResponse class takes an open file handle as an argument and tries to determine the correct content type from the file’s content. Django will close the file handle after the request completes.

The view function will accept the request and a relative path to the file to be downloaded as parameters. This relative path is the path inside the MEDIA_ROOT/protected folder.

In our case, we will just check whether the user is anonymous (not logged in). We’ll do this by checking the request.user.is_anonymous property. If they aren’t logged in, then we will raise a django.core.exceptions.PermissionDenied exception, which returns an HTTP 403 Forbidden response to the browser. This will stop the execution of the view and not return any file:

import os.path
from django.conf import settings
from django.http import FileResponse
from django.core.exceptions import PermissionDenied
def download_view(request, relative_path):
    if request.user.is_anonymous:
        raise PermissionDenied
    full_path = os.path.join(settings.MEDIA_ROOT,
        "protected", relative_path)
    file_handle = open(full_path, "rb")
    return FileResponse(file_handle)  # Django sends the
                                        file then closes
                                        the handle

Copy

Explain
The URL mapping to this view could be like this, using the path path converter inside your urls.py file:

urlpatterns = [
    …
    path("downloads/<path:relative_path>",
    views.download_view)
]

Copy

Explain
There are many ways that you could choose to implement a view that sends files. The important thing is that you use the FileResponse class, which is designed to stream the file to the client in chunks instead of loading it all into memory. This will reduce the load on the server and lessen the impact on resource usage if you must resort to sending files with Django.

Now that we know how to upload and process images, let’s look at how to store them on models.

Storing files on model instances
So far, we have manually managed the uploading and saving of files. You can also associate a file with a model instance by assigning the path to which it was saved to CharField. However, as with much of Django, this capability (and more) is already provided with the models.FileField class. A FileField instance does not actually store the file data; instead, they store the path where the file is stored (like CharField would), but it also provides helper methods. These methods assist with loading files (so you don’t have to open them manually) and generating disk paths for you based on the ID of the instance (or other attributes).

FileField can accept two specific optional arguments in its constructor (as well as the base Field arguments, such as required, unique, help_text, etc.):

max_length: Like max_length in the form’s ImageField, this is the maximum length of the filename that is allowed.
upload_to: The upload_to argument has three different behaviors depending on what type of variable is passed to it. Its simplest use is with a string or a pathlib.Path object. The path is simply appended to MEDIA_ROOT.
In this example, upload_to is just defined as a string:

class ExampleModel(models.Model):
    file_field = models.FileField(upload_to="files/")

Copy

Explain
Files saved to FileField will be stored in the MEDIA_ROOT/files directory.

You can achieve the same result using a pathlib.Path instance, too:

import pathlib
class ExampleModel(models.Model):
    file_field =
    models.FileField(upload_to=pathlib.Path("files/"))

Copy

Explain
The next way of using upload_to is with a string that contains the strftime formatting directives (for example, %Y to substitute the current year, %m for the current month, and %d for the current day of the month). The full list of these directives is extensive and can be found at https://docs.python.org/3/library/time.html#time.strftime. Django will automatically interpolate these values when saving the file.

For example, if you defined the model and FileField like this:

class ExampleModel(models.Model):
    file_field =
    models.FileField(upload_to="files/%Y/%m/%d/")

Copy

Explain
For the first file uploaded on a specific day, Django would create the directory structure for that day. For example, for the first file uploaded on January 1st, 2020, Django would create the MEDIA_ROOT/2020/01/01 directory and then store the uploaded file there. The next file (and all subsequent ones) uploaded on the same day would also be stored in that directory. Similarly, on January 2nd, 2020, Django will create the MEDIA_ROOT/2020/01/02 directory, and files will be stored there.

If you have many thousands of files being uploaded every day, you could even have the files split up further by including the hour and minute in the upload_to argument (upload_to="files/%Y/%m/%d/%H/%M/"). This may not be necessary if you only have a small volume of uploads, though.

By utilizing this method of the upload_to argument, you can have Django automatically segregate uploads and prevent too many files from being stored within a single directory (which can be hard to manage).

The final method of using upload_to is by passing a function that will be called to generate the storage path. Note that this is different from the other uses of upload_to, as it should generate the full path, including the file name, rather than just the directory. The function takes two arguments: instance and filename. The instance argument is the model instance that FileField is attached to, and filename is the name of the uploaded file.

Here is an example function that takes the first two characters of a filename to generate the save directory. This means that each uploaded file will be grouped into parent directories, which can help organize files and prevent there from being too many in one directory:

def user_grouped_file_path(instance, filename):
    return "{}/{}/{}/{}".format(instance.username,
    filename[0].lower(), filename[1].lower(), filename)

Copy

Explain
If this function is called with the Test.jpg filename, it will return <username>/t/e/test.jpg. If called with example.txt, it will return <username>e/x/example.txt, and so on. username is retrieved from the instance that is being saved. To illustrate, here is a model with FileField that uses this function. It also has a username, which is CharField:

class ExampleModel(models.Model):
    file_field =
    models.FileField(upload_to=user_grouped_file_path)
    username = models.CharField(unique=True)

Copy

Explain
You can use any attribute of the instance in the upload_to function, but be aware that if this instance is in the process of being created, then the file save function will be called before it is saved to the database. Therefore, some of the automatically generated attributes on the instance (such as id/pk) will not yet be populated and shouldn’t be used to generate a path.

Whatever path is returned from the upload_to function is appended to MEDIA_ROOT, so the uploaded files would be saved at MEDIA_ROOT/<username>/t/e/test.jpg and MEDIA_ROOT/<username>/e/x/example.txt, respectively.

Note that user_grouped_file_path is just an illustrative function that has intentionally been kept short, so it will not work correctly with single-character file names or if the username has invalid characters. For example, if the username has a / character in it, then this would act as a directory separator in the generated path.

Now, we’ve done a deep dive into setting up FileField on a model, but how do we actually save an uploaded file to it? It’s as easy as assigning the uploaded file to the attribute of the model, as you would with any type of value. Here’s a quick example with a view and the simple ExampleModel we were using as an example earlier in this section:

class ExampleModel(models.Model):
    file_field = models.FileField(upload_to="files/")
def view(request):
    if request.method == "POST":
        m = ExampleModel()  # Create a new ExampleModel
                              instance
        m.file_field = request.FILES["uploaded_file"]
        m.save()
    return render(request, "template.html")

Copy

Explain
In this example, we create a new ExampleModel and assign the uploaded file (called uploaded_file on the form) to its file_field attribute. When we saved the model instance, Django automatically wrote the file with its name to the upload_to directory path. If the uploaded file had the name image.jpg, the save path would be MEDIA_ROOT/upload_to/image.jpg.

We could just have easily updated the file field on an existing model or used a form (validating it before saving). Here is another simple example demonstrating this:

class ExampleForm(forms.Form):
    uploaded_file = forms.FileField()
def view(request, model_pk):
    form = ExampleForm(request.POST, request.FILES)
    if form.is_valid():
        # Get an existing model instance
        m = ExampleModel.object.get(pk=model_pk)
        # store the uploaded file on the instance
        m.file_field = form.cleaned_data["uploaded_file"]
        m.save()
    return render(request, "template.html")

Copy

Explain
You can see that updating FileField on an existing model instance is the same process as setting it on a new instance and if you choose to use a Django form or just access request.FILES directly, the process is just as simple.

Now we’ll look at how to store images on models using ImageField.

Storing images on model instances
While FileField can store any type of file, including images, there also exists ImageField. As you would expect, this is only for storing images. The relationship between the models’ forms.FileField and forms.ImageField is similar to that between models.FileField and models.ImageField, meaning ImageField extends FileField and adds extra methods for working with images.

The ImageField constructor takes the same arguments as FileField and adds two extra optional arguments:

height_field: This is the name of the field on the model that will be updated with the height of the image every time the model instance is saved
width_field: This is the width counterpart to height_field: the field that stores the width of the image that is updated every time the model instance is saved
Both of these arguments are optional, but the fields they name must exist if used. That is, it is valid to have height_field or width_field unset, but if they are set to the name of a field that does not exist, then an error will occur. The purpose of this is to assist with searching the database for files of a particular dimension.

Here is an example model using ImageField, which updates the image dimension fields:

class ExampleModel(models.Model):
    image = models.ImageField(upload_to="images/%Y/%m/%d/",
                              height_field="image_height",
                              width_field="image_width"
                             )
    image_height = models.IntegerField()
    image_width = models.IntegerField()

Copy

Explain
Notice that ImageField is using the upload_to parameter with date formatting directives that are updated on save. The behavior of upload_to is identical to that of FileField.

Upon saving an ExampleModel instance, its image_height field would be updated with the height of the image and image_width with the width of the image.

We won’t show examples for setting the ImageField values in a view, as the process is the same as for a plain FileField.

Working with FieldFile
When you access the FileField or ImageField attributes of a model instance, you will not get a native Python file object. Instead, you will be working with a FieldFile object. The FieldFile class is a wrapper around file that adds extra methods. Yes, it can be confusing to have classes called FileField and FieldFile.

The reason that Django uses FieldFile instead of just a file object is twofold. First, it adds extra methods to open, read, delete, and generate the URL of the file. Second, it provides an abstraction to allow alternative storage engines to be used.

Custom storage engines
We looked at custom storage engines in Chapter 5, Serving Static Files, regarding storing static files. We won’t examine custom storage engines in detail about media files since the code outlined in Chapter 5, Serving Static Files, for static files also applies to media files. The important thing to note is that which storage engine you’re using can be changed without updating your other code. This means that you can have your media files stored on your local drive during development and then save them to a CDN when your application is deployed to production.

The default storage_engine class can be set with DEFAULT_FILE_STORAGE in settings.py. The storage engine can also be specified on a per-field basis (for FileField or ImageField) with the storage argument, for example:

storage_engine = CustomStorageEngine()
class ExampleModel(models.Model):
    image_field = ImageField(storage=storage_engine)

Copy

Explain
This demonstrates what actually happens when you upload or retrieve a file. Django delegates to the storage engine to write or read it respectively. This happens even while saving to disk; however, this is fundamental and is invisible to the user.

Reading a stored FieldFile
Now that we’ve learned about custom storage engines, let’s look at reading from FieldFile. In the previous sections, we saw how to set the file on the model instance. Reading the data back again is just as easy – we have a couple of different methods that can help us depending on our use case.

In the following few code snippets, assume we are inside a view and have retrieved our model instance in some manner, and it’s stored in an m variable:

m = ExampleModel.object.get(pk=model_pk)

Copy

Explain
We can read all the data from the file with the read method:

data = m.file_field.read()

Copy

Explain
Or, we can manually open the file with the open method. This might be useful if we want to write our own generated data to the file:

with m.file_field.open("wb") as f:
    chunk = f.write(b"test")  # write bytes to the file

Copy

Explain
If we want to read the file in chunks, we can use the chunks method. This works the same as reading chunks from the uploaded file as we saw earlier:

for chunk in m.file_field.chunks():
    write_chunk(open_file, chunk)  # assume this method is
    defined somewhere

Copy

Explain
We can also manually open the file ourselves by using its path attribute:

open(m.file_field.path)

Copy

Explain
If we want to stream FileField for download, the best way is by using the FileResponse class, as we saw earlier. Combine this with the open method on FileField. Note that if we’re just trying to serve a media file, we should only implement a view to do this if we’re trying to restrict access to the file. Otherwise, we should just serve the file using MEDIA_URL and allow the web server to handle the request. Here’s how we’d write download_view to use FileField instead of the manually specified path:

def download_view(request, model_pk):
    if request.user.is_anonymous:
        raise PermissionDenied
    m = ExampleModel.objects.get(pk=model_pk)
    return FileResponse(m.file_field.open())  # Django
    sends the file then closes the handle

Copy

Explain
Django opens the correct path and closes it after the response. Django will also attempt to determine the correct MIME type for the file. We assume that FileField has its upload_to attribute set to a protected directory that the web server is preventing direct access to.

Storing existing files or content on FileField
We’ve seen how to store an uploaded file on an image field: simply assign it to the field like so:

m.file_field = request.FILES["file_upload"]

Copy

Explain
But how can we set the field value to that of an existing file that we might already have on disk? You might think you can use a standard Python file object, but this won’t work:

m.file_field = open("/path/to/file.txt", "rb")  # Don't do
                                                  this

Copy

Explain
You might also try setting the file using some content:

m.file_field = "new file content"  # Don't do this

Copy

Explain
This won’t work either.

You instead need to use the FileField save method, which accepts an instance of a Django File object or a ContentFile object (these classes’ full paths are django.core.files.File and django.core.files.base.ContentFile, respectively). We’ll briefly discuss the save method and its arguments and then return to these classes.

The FileField save method takes three arguments:

name: This is the name of the file you are saving and is the name the file will have when saved to the storage engine (in our case, to disk, inside MEDIA_ROOT).
content: This is an instance of File or ContentFile that we just saw; again, we will discuss these soon.
save: This argument is optional and defaults to True. This indicates whether or not to save the model instance to the database after saving the file. If set to False (i.e., the model is not saved), then the file will still be written to the storage engine (to disk), but the association is not stored on the model. The previous file path (or no file if one was not set) will still be stored in the database until the model instance’s save method is called manually. You should only set this argument to False if you intend to make other changes to the model instance and then save it manually.
Back to File and ContentFile: the one to use depends on what you want to store in FileField.

File is used as a wrapper around a Python file object, and you should use it if you have an existing file or file-like object that you want to save. File-like objects include io.BytesIO or io.StringIO instances. To instantiate a File instance, just pass the native file object to the constructor, for example:

f = open("/path/to/file.txt", "rb")
file_wrapper = File(f)

Copy

Explain
Use ContentFile when you already have some data loaded, either a str object or a bytes object. Pass the data to the ContentFile constructor:

string_content = ContentFile("A string value")
bytes_content = ContentField(b"A bytes value")

Copy

Explain
Now that you have either a File instance or a ContentFile instance, saving the data to FileField is easy, using the save method:

m = ExampleModel.objects.first()
with open("/path/to/file.txt") as f:
    file_wrapper = File(f)
    m.file_field.save("file.txt", f)

Copy

Explain
Since we did not pass a value for save to the save method, it will default to True, so the model instance is automatically persisted to the database.

Next, we will look at how to store an image that has been manipulated with a PIL back to an image field.

Writing PIL images to ImageField
In Exercise 8.05 – image uploads using Django forms, you used PIL to resize an image and save it to disk. When working with a model, you might want to perform a similar operation but have Django handle the file storage using ImageField so that you don’t have to do it manually. As in the exercise, you could save the image to disk and then use the File class to wrap the stored path – something like this:

image = Image.open(request.FILES["image_field"])
image.thumbnail((150, 150))
image.save("/tmp/thumbnail.jpg")  # save thumbnail to temp
                                    location
with open("/tmp/thumbnail.jpg", "rb") as f:
    image_wrapper = File(f)
    m.image_field.save("thumbnail.jpg", image_wrapper)
os.unlink("/tmp/thumbnail.jpg")  # clean up temp file

Copy

Explain
In this example, we’re having PIL store to a temporary location with the Image.save() method, and then re-opening the file.

This method works but is not ideal, as it involves writing the file to disk and then reading it out again, which can sometimes be slow. Instead, we can perform this whole process in memory.

Note

io.BytesIO and io.StringIO are useful objects. They behave like files but exist in memory only. BytesIO is used for storing raw bytes, and StringIO accepts Python 3’s native Unicode strings. You can use read, write, and seek, just like a normal file. Unlike a normal file, though, they don’t get written to disk and, instead, will disappear when your program terminates, or they go out of scope and are garbage collected. They are very useful if a function wants to write to something like a file, but you want to access the data immediately.

First, we will save the image data to an io.BytesIO object. Then, we’ll wrap the BytesIO object in a django.core.files.images.ImageFile instance (a subclass of File that is specifically for images and provides the width and height attributes). Once we have this ImageFile instance, we can use it in the save method of ImageField.

Note

ImageFile is a file or file-like wrapper just like File. It provides two extra attributes: width and height. ImageFile does not generate any errors if you use it to wrap a non-image. For example, you could use open() to open a text file and pass the file handle to the ImageFile constructor without issue. You can check whether the image file you passed in was valid by trying to access the width or height attributes: if these are None, then PIL was unable to decode the image data. You can check for the validity of these values yourself and throw an exception if they are None.

Let’s have a look at this in practice in a view:

from io import BytesIO
from PIL import Image
from django.core.files.images import ImageFile
def index(request, pk):
    # trim out logic for checking if method is POST
    # get a model instance, or create a new one
    m = ExampleModel.objects.get(pk=pk)
    # store the uploaded image in a variable for shorter
      code
    uploaded_image = request.FILES["image_field"]
    # load a PIL image instance from the uploaded file
    image = Image.open(uploaded)
    # perform the image resize
    image.thumbnail((150, 150))
    # Create a BytesIO file-like object to store
    image_data = BytesIO()
    # Write the Image data back out to the BytesIO object
    # Retain the existing format from the uploaded image
    image.save(fp=image_data, uploaded_image.format)
    # Wrap the BytesIO containing the image data
    image_file = ImageFile(image_data)
    # Save the wrapped image file data with the original
      name
    m.image_field.save(uploaded_image.name, image_file)
    # this also saves the model instance
    return redirect("/success-url/")

Copy

Explain
You can see this is a little bit more code, but it saves on writing the data to disk. You can choose to use either method (or another one that you come up with) depending on your needs.

Referring to media in templates
Once we have uploaded a file, we want to be able to refer to it in a template. For an uploaded image, such as a book cover, we will want to display the image on the page. We saw in Exercise 8.02 – template settings, and using MEDIA_URL in templates, how to build URL using MEDIA_URL in a template. When working with FileField or ImageField on a model instance, it is not necessary to do this, as Django provides this functionality for you.

The url attribute of FileField will automatically generate the full URL to the media file based on the MEDIA_URL in your settings.

Note

Note that references we make to FileField in this section also apply to ImageField, as it is a subclass of FileField.

This can be used anywhere that you have access to the instance and field, such as in a view or a template. The following example is in a view:

instance = ExampleModel.objects.first()
url = instance.file_field.url  # Get the URL

Copy

Explain
Or in a template (assuming instance has been passed to the template context):

<img src="{{ instance.file_field.url }}">

Copy

Explain
In the next exercise, we will create a new model with FileField and ImageField and then show how Django can automatically save these. We’ll also demonstrate how to retrieve the URL for an uploaded file.

Exercise 8.06 – FileField and ImageField on models

In this exercise, we will create a model with FileField and ImageField. After doing this, we will have to generate a migration and apply it. We’ll then change UploadForm we’ve been using, so it has both FileField and ImageField. The media_example view will be updated to store the uploaded files onto the model instance. Finally, we’ll add <img> into the example template to show the previously uploaded image:

In PyCharm, open the media_example app’s models.py file. Create a new model called ExampleModel, with two fields: ImageField named image_field, and FileField called file_field. ImageField should have upload_to set to images/, and FileField should have upload_to set to files/. The finished model should look like this:
class ExampleModel(models.Model):
    image_field =
        models.ImageField(upload_to="images/")
    file_field = models.FileField(upload_to="files/")

Copy

Explain
Your models.py file should now look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.06/media_project/media_example/models.py.

Open a terminal and navigate to the media_project project directory. Make sure your bookr virtual environment is active. Run the makemigrations management command to generate the migrations for this new model (for Windows, you can use python instead of python3 in the following code):
python3 manage.py makemigrations

Copy

Explain
Note

To learn how to create and activate a virtual environment, refer to the Preface section of the book.

The output should be like the following:

(bookr)$ python3 manage.py makemigrations
Migrations for 'media_example':
  media_example/migrations/0001_initial.py
    - Create model ExampleModel

Copy

Explain
Apply the migration by running the migrate management command:
python3 manage.py migrate

Copy

Explain
The output will be as follows:

(bookr)$ python3 manage.py migrate
Operations to perform:
    Apply all migrations: admin, auth, contenttypes,
    reviews, sessions
Running migrations:
    # output trimmed for brevity
    Applying media_example.0001_initial... OK

Copy

Explain
Note that all the initial Django migrations will also be applied since we did not apply those after creating the project.

Switch back to PyCharm and open the media_example app’s forms.py file. Rename the existing ImageField from file_upload to image_upload. Then, add a new FileField named file_upload. After making these changes, your UploadForm code should look like this:
class UploadForm(forms.Form):
    image_upload = forms.ImageField()
    file_upload = forms.FileField()

Copy

Explain
You can save and close the file. It should look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.06/media_project/media_example/forms.py.

Open the media_example app’s views.py file. First, import ExampleModel into the file. To do this, add this line at the top of the file after the existing import statements:
from .models import ExampleModel

Copy

Explain
Some imports will no longer be required, so you can remove these lines:

from PIL import Image
from django.conf import settings

Copy

Explain
In the media_example view, set a default for the instance you will render in case one is not created. After the function definition, define a variable called instance and set it to None:
def media_example(request):
    instance = None

Copy

Explain
You can completely remove the contents of the form.is_valid() branch as you no longer need to manually save the file. Instead, it will automatically be saved when the ExampleModel instance is saved. You will instantiate an ExampleModel instance and set the file and image fields from the uploaded form.
Add this code under the if form.is_valid(): line:

instance = ExampleModel()
instance.image_field =
    form.cleaned_data["image_upload"]
instance.file_field = form.cleaned_data["file_upload"]
instance.save()

Copy

Explain
Pass the instance through to the template in the context dictionary that is passed to render. Use the instance key:
return render(request, "media-example.html", {"form":
form, "instance": instance})

Copy

Explain
Now, your completed media_example view should look like this https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.06/media_project/media_example/views.py.

You can now save and close this file.

Open the media-example.html template. Add an <img> element that displays the last uploaded image. Under the closing </form> tag, add an if template tag that checks whether instance has been provided. If so, display <img> with a src attribute of instance.image_field.url:
{% if instance %}
    <img src="{{ instance.image_field.url }}">
{% endif %}

Copy

Explain
You can save and close this file. It should now look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.06/media_project/media_example/templates/media-example.html.

Start the Django dev server if it’s not already running, then navigate to http://127.0.0.1:8000/media-example/. You should see the form rendered with two fields:
Figure 8.20: UploadForm with two fields
Figure 8.20: UploadForm with two fields

Select a file for each field – for ImageField, you must select an image, but any type of file is allowed for FileField. See Figure 8.20, which shows the fields with files selected:
Figure 8.21: ImageField and FileField with files selected
Figure 8.21: ImageField and FileField with files selected

Then, submit the form. If the submission is successful, the page will reload, and the last image we uploaded will be displayed (Figure 8.22):

Figure 8.22: The last image that was uploaded is displayed
Figure 8.22: The last image that was uploaded is displayed

You can see how Django stores the files by looking in the MEDIA_ROOT directory. Figure 8.23 shows the directory layout in PyCharm:
Figure 8.23: Uploaded files that Django has created
Figure 8.23: Uploaded files that Django has created

You can see that Django has created the files and images directories. These were what you set in the upload_to arguments on ImageField and FileField of the model.

We could also verify these uploads by attempting to download them, for example, at http://127.0.0.1:8000/media/files/sample.txt or http://127.0.0.1:8000/media/images/cover.jpg.

In this exercise, we created ExampleModel with FileField and ImageField and saw how to store uploaded files on it. We saw how to generate a URL to an uploaded file for use in a template. We tried uploading some files and saw that Django automatically created the upload_to directories (media/files and media/images) and then stored the files inside.

In the next section, we will look at how we can simplify the process even further by using ModelForm to generate the form and save the model without having to manually set the files in the view.

ModelForms and file uploads
We’ve seen how using form.ImageField on a form can prevent non-images from being uploaded. We’ve also seen how models.ImageField makes it easy to store an image for a model. But we need to be aware that Django does not stop you from setting a non-image file to ImageField. For example, consider a form that has both FileField and ImageField:

class ExampleForm(forms.Form):
    uploaded_file = forms.FileField()
    uploaded_image = forms.ImageField()

Copy

Explain
In the following view, the form would not validate if the uploaded_image field on the form was not an image, so some data validity is ensured for uploaded data. The following is an example of this:

def view(request):
    form = ExampleForm(request.POST, request.FILES)
    if form.is_valid():
        m = ExampleModel()
        m.file_field = form.cleaned_data["uploaded_file"]
        m.image_field =
            forms.cleaned_data["uploaded_image"]
        m.save()
    return render(request, "template.html")

Copy

Explain
Since we’re sure the form is valid, we know that forms.cleaned_data["uploaded_image"] must contain an image. Therefore, we would never assign a non-image to the model instance’s image_field.

However, what if we made a mistake in our code and wrote something like the following:

m.image_field = forms.cleaned_data["uploaded_file"]

Copy

Explain
That is, if we accidentally reference FileField by mistake, Django does not validate that a (potential) non-image is being assigned to ImageField, and so it does not throw an exception or generate any kind of error. We can mitigate the potential for issues like this by using ModelForm.

We introduced ModelForm in Chapter 7, Advanced Form Validation and Model Forms. These are forms whose fields are automatically defined from a model. We saw that ModelForm has a save method that automatically creates or updates the model data in the database. When used with a model that has FileFIeld or ImageField, then the save method of ModelForm will also save uploaded files.

Here’s an example of using ModelForm to save a new model instance in a view. Here, we are just making sure to pass request.FILES to the ModelForm constructor:

class ExampleModelForm(forms.Model):
    class Meta:
        model = ExampleModel  # The same ExampleModel class
                                we've seen previously
        fields = "__all__"
def view(request):
    if request.method == "POST":
        form = ExampleModelForm(request.POST,
        request.FILES)
        form.save()
        return redirect("/success-page")
    else:
        form = ExampleModelForm()
    return (request, "template.html", {"form": form})

Copy

Explain
As with any ModelForm, the save method can be called with the commit argument set to False. Then the model instance will not be saved to the database, and the FileField and ImageField files will not be saved to disk. The save method should be called on the model instance itself – this will commit changes to the database and save the files. In this next short example, we set a value on the model instance before saving it:

def view(request):
    if request.method == "POST":
        form = ExampleModelForm(request.POST,
        request.FILES)
        m = form.save(False)
        m.attribute = "value"  # Set arbitrary value on the
                                 model instance before save
        m.save()  # save the model instance, also write the
                    files to disk
        return redirect("/success-page/")
    else:
        form = ExampleModelForm()
    return (request, "template.html", {"form": form})

Copy

Explain
Calling the save method on the model instance both saves the model data to the database and the uploaded files to disk. In the next exercise, we will build ModelForm from ExampleModel we created in Exercise 8.06 – FileField and ImageField on models, then test uploading files with it.

Exercise 8.07 – file and image uploads using ModelForm
In this exercise, you will update UploadForm to be a subclass of ModelForm and have it built automatically from ExampleModel. You will then change the media_example view to save the instance automatically from the form, so you can see how the amount of code can be reduced:

In PyCharm, open the media_example apps’ forms.py file. You need to use ExampleModel in this chapter, so use import to import it at the top of the file after from django import forms statement. Insert this line:
from .models import ExampleModel

Copy

Explain
Change UploadForm to be a subclass of forms.ModelForm. Remove the class body and replace it with a class Meta definition, its model should be ExampleModel. Set the fields attribute to __all__. After completing this step, UploadForm should look like this:
class UploadForm(forms.ModelForm):
    class Meta:
        model = ExampleModel
        fields = "__all__"

Copy

Explain
Save and close the file. It should now look like this: https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.07/media_project/media_example/forms.py.

Open the media_example app’s views.py file. Since you no longer need to reference ExampleModel directly, you can remove its import at the top of the file. Remove the following line:
from .models import ExampleModel

Copy

Explain
In the media_example view, remove the entirety of the form.is_valid() branch and replace it with a single line:
instance = form.save()

Copy

Explain
The form’s save method will handle persisting the instance to the database and saving the files. It will return an instance of ExampleModel, the same as the other ModelForm we have worked with in Chapter 7, Advanced Form Validation and Model Forms.

After completing this step, your media_example function should look like https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Exercise8.07/media_project/media_example/views.py. Save and close views.py.

Start the Django dev server if it’s not already running, then navigate to http://127.0.0.1:8000/media-example/. You should see the form rendered with two fields, Image field and File field (Figure 8.24):
Figure 8.24: UploadForm as a ModelForm rendered in the browser
Figure 8.24: UploadForm as a ModelForm rendered in the browser

Note that the names of these fields now match those of the model rather than the form, since the form just uses the model’s fields.

Browse and select an image and file (Figure 8.25), then submit the form:
Figure 8.25: Image and file selected
Figure 8.25: Image and file selected

The page will reload, and as in Exercise 8.06 – FileField and ImageField on models, you will see the previously uploaded image (Figure 8.26):
Figure 8.26: Image being displayed after upload
Figure 8.26: Image being displayed after upload

Finally, examine the contents of the media directory. You should see the directory layout matches that of Exercise 8.06 – FileField and ImageField on models, with images inside the images directory and files inside the files directory:
Figure 8.27: The uploaded files directory matches Exercise 6
Figure 8.27: The uploaded files directory matches Exercise 6

In this exercise, we changed UploadForm to a ModelForm subclass, which allowed us to automatically generate the upload fields. We could replace the code that stored the uploaded files on the models with a call to the form’s save method.

Before moving on to the activities for this chapter, we need to briefly discuss how to handle file saving when using an instance.

Handling file saving
As you know from working with ModelForms in Chapter 7, you can pass an instance argument to ModelForm to cause it to update an existing model instead of creating a new one when saving.

For example, do the following to update an example model in a view:

def update_view(request, pk):
    instance = ExampleModel.objects.get(pk=pk)
    form = UploadForm(request.POST, request.FILES,
    instance=instance)
    if form.valid():
        form.save()

Copy

Explain
When accessing the cleaned_data attribute of the form, we will get back the data that was contained in request.POST. If there was no value for that key, then we’ll get the value from the instance instead.

This normally doesn’t cause any problems, but when working with ImageField or FileField, the type of data being returned will differ from the request or the instance.

If a file was uploaded, then the cleaned data will be InMemoryUploadedFile or TemporaryUploadedFile (depending on its size; only small files will fit in memory). If no file was uploaded, then the type will be FieldFile for FileField or ImageFieldFile for ImageField.

To explain, consider this code:

def update_view(request, pk):
    instance = ExampleModel.objects.get(pk=pk)
    form = UploadForm(request.POST, request.FILES,
    instance=instance)
    if form.is_valid()
        form_file = form.cleaned_data["file_field"]
        form_image = form.cleaned_data["image_field"]

Copy

Explain
In the case where data was uploaded (that is, the user selected an image and file in the form), then form_file and form_image will be InMemoryUploadedFile or TemporaryUploadedFile. However, if the user did not upload anything for the fields (assuming the fields are not required in the form), then form_file will be a FieldFile instance, and form_image will be an ImageFieldFile instance.

To differentiate between them, there are a few different checks you could do. One of the simplest methods is to check for the existence of a path attribute. Since uploaded files haven’t been saved to disk yet, they have no path:

if hasattr(form_file, "path"):
    print("This is a FieldFile")
else:
    print("This is an uploaded file")

Copy

Explain
Sometimes you will need to check what kind of file you are working with before performing some action, and perhaps skip that action if the user hadn’t uploaded a new file. For example, we wouldn’t want to resize an image that was already assigned to a model. We’d only do the image resize on newly uploaded images:

if hasattr(image_file, "path"):
    print("This image was on the instances so no need to
           resize")
else:
    perform_resize(image_file)

Copy

Explain
You will need to make a check like this in the first activity for this chapter.

We’ve now covered everything you need to start enhancing Bookr with file uploads. In the activity for this chapter, we’ll add support for uploading a cover image and sample document (PDF, text file, and more) for a book. The book cover will be resized using PIL before it is saved.

Activity 8.01 – image and PDF upload of books
In this activity, you will start by cleaning up (deleting) the example views, templates, forms, models, and URL maps that we were using throughout the exercises in this chapter. You’ll then need to generate and apply a migration to delete ExampleModel from the database.

You can then start adding the Bookr enhancements, first by adding ImageField and FileField to the Book model to store the Book cover and sample. Then you will create a migration and apply it to add these fields to the database. You can then build a form that will display just these new fields. You’ll add a view that uses this form to save the model instance with the uploaded files after first resizing the image to a thumbnail size. You will be able to reuse the instance-form.html template from Chapter 7, Advanced Form Validation and Model Forms, with a minor change to allow file uploads.

These steps will help you complete the activity:

Update the Django settings to add the MEDIA_ROOT and MEDIA_URL settings.
The /media/ URL mapping should be added to the main urls.py file. Use the static view and utilize MEDIA_ROOT and MEDIA_URL from Django settings. Remember, this mapping should only be added if DEBUG is True.
Add ImageField (named cover) and FileField (named sample) to the Book model. The fields should upload to book_covers/ and book_samples/, respectively. They should both allow the null and blank values.
Run makemigrations and migrate again to apply the Book model changes to the database.
Create BookMediaForm as a subclass of ModelForm. Its model should be Book, and the fields should only be the fields you added in step 3.
Add a book_media view. This will not allow you to create Book, instead, it will only allow you to add media to an existing Book (so it must take pk as a required argument).
The book_media view should validate the form and use save to save it but not commit the instance. The uploaded cover should first be resized using the thumbnail method, as demonstrated in the Writing PIL images to ImageField section. The maximum size should be 300 px by 300 px. It should then be stored on the instance, and the instance should be saved. Remember that the cover field is not required, so you should check this before trying to manipulate the image, and you won’t need to resize the image if one is already on the instance. On a successful POST, register a success message that Book was updated, then redirect to the book_detail view.
Render instance-form.html, passing a context dictionary containing form, model_type, and instance, as you did in Chapter 6, Forms. Also, pass another item, is_file_upload, set to True. This variable will be used in the next step.
In the instance-form.html template, use the is_file_upload variable to add the correct enctype attribute to the form. This will allow you to switch the modes for the form to enable file uploads when required.
Finally, add a URL map that maps /books/<pk>/media/ to the book_media view.
When you’re finished, you should be able to start the Django dev server and load the book_media view at http://127.0.0.1:8000/books/<pk>/media/, for example, http://127.0.0.1:8000/books/2/media/. You should see BookMediaForm rendered in the browser, like in Figure 8.28:

Figure 8.28: BookMediaForm in the browser
Figure 8.28: BookMediaForm in the browser

Select a cover image and a sample file for the book. You can use the image at https://raw.githubusercontent.com/PacktPublishing/Web-Development-with-Django-Second-Edition/main/Chapter08/Activity8.01/bookr/fixtures/machine-learning-for-algorithmic-trading.png and the PDF at https://github.com/PacktPublishing/Web-Development-with-Django-Second-Edition/blob/main/Chapter08/Activity8.01/bookr/fixtures/machine-learning-for-trading.pdf (or you can use any other image/PDF of your choosing).

Figure 8.29: Book cover and sample selected
Figure 8.29: Book cover and sample selected

After submitting the form, you will be redirected to the Book Details view and see the success message (Figure 8.30):

Figure 8.30: Success message on the Book Details page
Figure 8.30: Success message on the Book Details page

If you go back to the same book’s media page, you should see the fields are now filled in with an option to clear the data from them:

Figure 8.31: BookMediaForm with existing values
Figure 8.31: BookMediaForm with existing values

In Activity 8.02 – displaying Cover and Sample Link, you will add these uploaded files to the Book Detail view, but for now, if you want to check that uploads have worked, you can look inside the media directory in the Bookr project:

Figure 8.32: Book media
Figure 8.32: Book media

You should see the directories that were created and the uploaded files, as per Figure 8.32. Open an uploaded image, and you should see its maximum dimension is 300 px.

Note

The solution to this activity can be found on https://github.com/PacktPublishing/Web-Development-with-Django-Second-Edition/tree/main/ActivitySolutions.

Activity 8.02 – displaying the cover and sample link
In this activity, you will update the book_detail.html template to show the cover for Book (if one is set). You will also add a link to download the sample again, only if one is set. You will use the FileField and ImageField url attributes to generate the URLs to the media files.

These steps will help you complete this activity:

Inside the Book Details display in the book_detail.html view, add an <img> element if the book has a cover image. Then, display the cover of the book inside it. Use <br> after the <img> tag, so the image is on its own line.
After the Publication Date display, add a link to the sample file. It should only be displayed if a sample file has been uploaded. Make sure you add another <br> tag, so it displays correctly.
In the section that has a link to add a review, add another link that goes to the media page for the book. Follow the same styling as the Add Review link.
When you’ve completed these steps, you should be able to load a book’s detail page. If the book has no cover or sample, then the page should look very similar to what it did before, except you should see the new link to the Media page at the bottom (Figure 8.33):

Figure 8.33: The new Media button visible on the Book Detail page
Figure 8.33: The new Media button visible on the Book Detail page

Once you have uploaded cover and/or sample for a book, the cover image and the sample link should be displayed (Figure 8.34):

Figure 8.34: The book cover and the ﻿sample link displayed
Figure 8.34: The book cover and the sample link displayed

Note

The solution for this activity can be found on https://github.com/PacktPublishing/Web-Development-with-Django-Second-Edition/tree/main/ActivitySolutions.

Summary
In this chapter, we added the MEDIA_ROOT and MEDIA_URL settings and a special URL map to serve media files. We then created a form and a view to upload files and save them to the media directory. We saw how to add the media context processor to automatically have access to the MEDIA_URL setting in all our templates. We then enhanced and simplified our form code by using a Django form with FileField or ImageField, instead of manually defining one in HTML.

We looked at some of the enhancements Django provides for images with ImageField, and how to interact with an image using Pillow. We showed an example view that would be able to serve files that required authentication using the FileResponse class. Then, we saw how to store files on models using FileField and ImageField and refer to them in a template using the FileField.url attribute. We were able to reduce the amount of code we had to write by automatically building ModelForm from a model instance. Finally, we did two activities to enhance Bookr by adding a cover image and a sample file to the Book model.

In Chapter 9, Sessions and Authentication, we will learn how to add authentication to a Django application to protect it from unauthorized users.





| ≪ [ 07 Advanced Form Validation and Model Forms ](/packtpub/2024/422-web_development_with_django_2ed/07_advanced_form_validation_and_model_forms) | 08 Media Serving and File Uploads | [ 09 Sessions and Authentication ](/packtpub/2024/422-web_development_with_django_2ed/09_sessions_and_authentication) ≫ |
|:----:|:----:|:----:|

> (1) Path: packtpub/2024/422-web_development_with_django_2ed/08_media_serving_and_file_uploads
> (2) Markdown
> (3) Title: 08 Media Serving and File Uploads
> (4) Short Description: Publication date: May 2023 Publisher Packt Pages 764
> (5) tags: Django
> Book Title: 422-Web Development with Django 2ed
> Link: https://subscription.packtpub.com/book/web-development/9781803230603/pref
> create: 2024-05-08 수 14:11:52
> Images: /packtpub/2024/422-web_development_with_django_2ed_img/08/
> .md Name: 08_media_serving_and_file_uploads.md

