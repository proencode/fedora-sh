
@ Q -> # 붙이고 줄 띄우기 => 0i# ^[A^M^[kk^[
@ W -> 현 위치에서 Copy 까지 역따옴표 => j0i```^M^[/^Copy$^[ddk0C```^M^[
@ E -> 찾은 글자 ~ SPACE 앞뒤로 backtick(`) 붙이기 => i`^[/ ^[i`^[/EEEEEEEEEE^[
@ R -> 찾은 글자 ~ POINT 앞뒤로 backtick(`) 붙이기 => i`^[/.^[i`^[/RRRRRRRRRR^[
@ T -> 찾은 글자 ~ COMMA 앞뒤로 backtick(`) 붙이기 => i`^[/,^[i`^[/TTTTTTTTTT^[
@ Y -> 찾은 글자 ~ COLON 앞뒤로 backtick(`) 붙이기 => i`^[/;^[i`^[/YYYYYYYYYY^[
@ U -> 찾은 글자~닫은괄호앞뒤로 backtick(`) 붙이기 => i`^[/)^[i`^[/UUUUUUUUUU^[

@ A -> 빈 줄에 블록 시작하기 => 0C```^[^Mk0
@ S -> 줄 앞에 > 나오면 안되므로 블록 마감하고 > 앞에 - 끼우기 => 0i```^M-^[^M0i```^[0
@ D -> 줄 아래에 블록 마감하고 한줄 더 띄우기 => 0^Mi```^M^M^[kk
@ F -> 이 줄을 타이틀로 만들기 => 0i#### ^[^M^[
    마크다운 입력시 vi 커맨드 표시 ; (^[)=Ctrl+[ ; (^M)=Ctrl+M
    인용구 작성시 ; 본문앞에는 꺽쇠 > 붙이고, 스타일 첨가시 끝줄에 종류별 구분을 표시한다.
    https://docs.requarks.io/en/editors/markdown > Blockquotes > Stylings >
    blue= {.is-info} ; green= {.is-success} ; yellow= {.is-warning} ; red= {.is-danger}

---------- cut line ----------

> Title: Modern Android 13 Development Cookbook
> 02.c2 / Creating Screens Using a Declarative UI and Exploring Compose Principles
> md Path: packtpub / 2307a-modern_android_13_development_cookbook-230811 /
> 02.c2-creating_screens_using_a_declarative_ui_and_exploring_compose_principles.md
> Images Folder: packtpub / img2307a-modern_android_13_development_cookbook-230811
> Short Description: By Madona S. Wambua Jul 2023 322 pages
> Link: https://subscription.packtpub.com/book/mobile/9781803235578/pref
> create: 2023-08-18 금 13:26:27

# Creating Screens Using a Declarative UI and Exploring Compose Principles

Mobile applications require a **User Interface (UI)** for user interactions. For instance, the old way of creating the UI was imperative in Android. This meant having a separate prototype of the application’s UI using unique **Extensible Markup Language (XML)** layouts and not the same language used to build your logic.

However, with Modern Android Development, there is a push to stop using imperative programming and start using a declarative way of making the UI, which means developers design the UI based on the data received. This design paradigm uses one programming language to create an entire application.

It is fair to acknowledge it may seem difficult for new developers to decide what to learn when building a UI: the old way of creating views or opting for the new Jetpack Compose. However, suppose you’ve built an Android application before the Jetpack Compose era.

In such a case, you may already know using XML is a bit tedious, especially if your code base is complex. However, utilizing Jetpack Compose as your first choice makes work easier. In addition, it simplifies UI development by ensuring developers use less code, as they take advantage of the intuitive Kotlin APIs. Hence, there is a logical push by new developers when creating views to use Jetpack Compose instead of XML.

However, knowing both can be beneficial since many applications still use XML layouts, and you might have to maintain the view but build new ones using Jetpack Compose. In this chapter, we will look at Jetpack Compose basics by trying to implement small examples using columns, rows, boxes, lazy columns, and more.

In this chapter, we’ll be covering the following recipes:

- Implementing Android views in Jetpack Compose
- Implementing a scrollable list in Jetpack Compose
- Implementing your first tab layout with a view pager using Jetpack Compose
- Implementing animations in Compose
- Implementing accessibility in Jetpack Compose
- Implementing declarative graphics using Jetpack Compose

# Technical requirements

The complete source code for this chapter can be found at https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two. To be able to view all the recipes, you will need to run all the preview functions separately. Hence, look for the @Preview composable function to view the UI created.

# Implementing Android views in Jetpack Compose

In every Android application, having a UI element is very crucial. A view in Android is a simple building block for a UI. A view ensures users can interact with your application through a tap or other motion. This recipe will look at different Compose UI elements and see how we can build them.

## Getting ready

In this recipe, we will create one project that we will re-use for the entire chapter, so let’s go ahead and follow the steps in Chapter 1, Getting Started with Modern Android Development Skills, on how to create your first Android project.

Create a project and call it `Compose Basics`. In addition, we will mostly use the Preview section to view the UI element we create.

## How to do it…

Once you have created the project, follow these steps to build several Compose UI elements:

1. Inside our project, let us go ahead and create a new package and call it components. This is where we will add all the components we create.
2. Create a Kotlin file and call it `UIComponents.kt`; inside `UIComponent`, go ahead and create a composable function, call it `EditTextExample()`, and call the `OutlinedTextField()` function; this will prompt you to import the required import, which is `androidx.Compose.material.OutlinedTextField`:

```
@Composable
fun EditTextExample() {
    OutlinedTextField()
}
```

3. When you look deep into `OutlineTextField` (see Figure 2.1), you will notice the function accepts several inputs, and this is very useful when you need to customize your own composable functions.
Figure 2.1 – The OutlinedTextField input
Figure 2.1 – The OutlinedTextField input

For our example, we will not do much with the UI we create and will rather just look at how we create them.
Now, to fully create our OutlinedTextField() based on the types of input we see it accepts, we can give it a text and color and we can decorate it using a Modifier(); that is, by giving it specific instructions such as fillMaxWidth(), which sets the max width. When we say fill, we are simply specifying it should be fully filled. We set .padding(top) to 16.dp, which applies additional space along each edge of the content in dp. It also has a value, which is the value to be entered in the OutlinedTextField, and an onValueChange lambda that listens to the input change.
We also give our OutlinedText some border colors when focused and when not focused to reflect the different states. Hence, if you start entering input, the box will change color to blue, as specified in the code:
@Composable

Copy

Explain
fun EditTextExample() {

Copy

Explain
    OutlinedTextField(

Copy

Explain
        value = "",

Copy

Explain
        onValueChange = {},

Copy

Explain
        label = { Text(stringResource(id =

Copy

Explain
        R.string.sample)) },

Copy

Explain
        modifier = Modifier

Copy

Explain
            .fillMaxWidth()

Copy

Explain
            .padding(top = 16.dp),

Copy

Explain
        colors =

Copy

Explain
            TextFieldDefaults.outlinedTextFieldColors(

Copy

Explain
                focusedBorderColor = Color.Blue,

Copy

Explain
                unfocusedBorderColor = Color.Black

Copy

Explain
            )

Copy

Explain
    )

Copy

Explain
}

Copy

Explain
We also have another type of TextField, which is not outlined, and if you compare what OutlinedTextField takes in as input, you will notice they are fairly similar:
@Composable

Copy

Explain
fun NotOutlinedEditTextExample() {

Copy

Explain
    TextField(

Copy

Explain
        value = "",

Copy

Explain
        onValueChange = {},

Copy

Explain
        label = { Text(stringResource(id =

Copy

Explain
        R.string.sample)) },

Copy

Explain
        modifier = Modifier

Copy

Explain
            .fillMaxWidth()

Copy

Explain
            .padding(top = 8.dp, bottom = 16.dp),

Copy

Explain
        colors =

Copy

Explain
            TextFieldDefaults.outlinedTextFieldColors(

Copy

Explain
                focusedBorderColor = Color.Blue,

Copy

Explain
                unfocusedBorderColor = Color.Black

Copy

Explain
            )

Copy

Explain
    )

Copy

Explain
}

Copy

Explain
You can run the application by adding the Compose functions inside the @Preview composable function. In our example, we can create UIElementPreview(), which is a preview function for displaying our UI. In Figure 2.2, the top view is OutlinedTextField, whereas the second one is a normal TextField.
Figure 2.2 – OutlinedTextField and TextField
Figure 2.2 – OutlinedTextField and TextField

Now, let’s go ahead and look at button examples. We will look at different ways to create buttons with different shapes. If you hover over the Button() composable function, you will see what it accepts as input, as shown in Figure 2.3.
Figure 2.3 – Button input
Figure 2.3 – Button input

In our second example, we will try to create a button with an icon on it. In addition, we will add text, which is crucial when creating buttons since we need to specify to users what action or what the button will be doing once it is clicked on.

So, go ahead and create a Compose function in the same Kotlin file and call it ButtonWithIcon(), and then import the Button() composable function.
Inside it, you will need to import an Icon() with painterResource input, a content description, Modifier, and tint. We will also need Text(), which will give our button a name. For our example, we will not use tint:
@Composable

Copy

Explain
fun ButtonWithIcon() {

Copy

Explain
    Button(onClick = {}) {

Copy

Explain
        Icon(

Copy

Explain
            painterResource(id =

Copy

Explain
                R.drawable.ic_baseline_shopping_bag_24                ),

Copy

Explain
            contentDescription = stringResource(

Copy

Explain
                id = R.string.shop),

Copy

Explain
            modifier = Modifier.size(20.dp)

Copy

Explain
        )

Copy

Explain
        Text(text = stringResource(id = R.string.buy),

Copy

Explain
            Modifier.padding(start = 10.dp))

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
Let us also go ahead and create a new composable function and call it CornerCutShapeButton(); in this example, we will try to create a button with cut corners:
@Composable

Copy

Explain
fun CornerCutShapeButton() {

Copy

Explain
    Button(onClick = {}, shape = CutCornerShape(10)) {

Copy

Explain
        Text(text = stringResource(

Copy

Explain
            id = R.string.cornerButton))  }}}}

Copy

Explain
Let us also go ahead and create a new composable function and call it RoundCornerShapeButton(); in this example, we will try to create a button with round corners:
@Composable

Copy

Explain
fun RoundCornerShapeButton() {

Copy

Explain
    Button(onClick = {}, shape =

Copy

Explain
    RoundedCornerShape(10.dp)) {

Copy

Explain
        Text(text = stringResource(

Copy

Explain
            id = R.string.rounded))

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
Let us also go ahead and create a new composable function and call it ElevatedButtonExample(); in this example, we will try to create a button with elevation:
@Composable

Copy

Explain
fun ElevatedButtonExample() {

Copy

Explain
    Button(

Copy

Explain
        onClick = {},

Copy

Explain
        elevation = ButtonDefaults.elevation(

Copy

Explain
            defaultElevation = 8.dp,

Copy

Explain
            pressedElevation = 10.dp,

Copy

Explain
            disabledElevation = 0.dp

Copy

Explain
        )

Copy

Explain
    ) {

Copy

Explain
        Text(text = stringResource(

Copy

Explain
            id = R.string.elevated))

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
When you run the application, you should have an image similar to Figure 2.4; the first button after TextField is ButtonWithIcon(), the second one is CornerCutShapeButton(), the third is RoundCornerShapeButton(), and, lastly, we have ElevatedButtonExample().
Figure 2.4 – The different button types and other UI elements
Figure 2.4 – The different button types and other UI elements

Now, let us look at one last example since we will be using different views and styles throughout the book and will learn more in the process. Now, let us look at an image view; the Image() composable function takes in several inputs, as shown in Figure 2.5.
Figure 2.5 – Different ImageView input types
Figure 2.5 – Different ImageView input types

In our example, Image() will only have a painter, which is not nullable, meaning you need to provide an image for this composable function, a content description for accessibility, and a modifier:
@Composable

Copy

Explain
fun ImageViewExample() {

Copy

Explain
    Image(

Copy

Explain
        painterResource(id = R.drawable.android),

Copy

Explain
        contentDescription = stringResource(

Copy

Explain
            id = R.string.image),

Copy

Explain
        modifier = Modifier.size(200.dp)

Copy

Explain
    )

Copy

Explain
}

Copy

Explain
You can also try to play around with others things, such as adding RadioButton() and CheckBox() elements and customizing them. When you run your application, you should have something similar to Figure 2.6.
Figure 2.6 – Se﻿veral UI components
Figure 2.6 – Several UI components

How it works…
Every composable function is annotated with the @Composable annotation. This annotation tells the Compose compiler that the provided compiler is intended to convert the provided data into a UI. It is also important to note each composable function name needs to be a noun and not a verb or an adjective, and Google provides these guidelines. Any composable function you create can accept parameters that enable the app logic to describe or modify your UI.

We mention the Compose compiler, which means that a compiler is any special program that takes the code we wrote, examines it, and translates it into something the computer can understand – or machine language.

In Icon(), painterResouce specifies the icon we will be adding to the button, the content description helps with accessibility, and the modifier is used to decorate our icon.

We can preview the UI elements we build by adding the @Preview annotation and adding showBackground = true:

@Preview(showBackground = true)

Copy

Explain
@Preview is powerful, and we will look at how you can utilize it better in future chapters.

Implementing a scrollable list in Jetpack Compose
When building Android applications, one thing that we can all agree on is you must know how to build a RecyclerView to display your data. With our new, modern way of building Android applications, if we need to use RecyclerView, we can use LazyColumn, which is similar. In this recipe, we will look at rows, columns, and LazyColumn, and build a scrollable list using our dummy data.

In addition, we will be learning some Kotlin in the process.

Getting ready
We will continue using the Compose Basics project to build a scrollable list; hence, to get started, you need to have done the previous recipe.

How to do it…
Follow these steps to build your first scrollable list:

Let us go ahead and build our first scrollable list, but first, we need to create our dummy data, and this is the item we want to be displayed on our list. Hence, create a package called favoritecity where our scrollable example will live.
Inside the favoritecity package, create a new data class and call it City; this will be our dummy data source – data class City ().
Let us model our City data class. Make sure you add the necessary imports once you have added the annotated values:
data class City(

Copy

Explain
    val id: Int,

Copy

Explain
    @StringRes val nameResourceId: Int,

Copy

Explain
    @DrawableRes val imageResourceId: Int

Copy

Explain
)

Copy

Explain
Now, in our dummy data, we need to create a Kotlin class and call this class CityDataSource. In this class, we will create a function called loadCities(), which will return our list of List<City>, which we will display in our scrollable list. Check the Technical requirements section for all the required imports to get all the code and images:
class CityDataSource {

Copy

Explain
    fun loadCities(): List<City> {

Copy

Explain
        return listOf<City>(

Copy

Explain
            City(1, R.string.spain, R.drawable.spain),

Copy

Explain
            City(2, R.string.new_york,

Copy

Explain
                R.drawable.newyork),

Copy

Explain
            City(3, R.string.tokyo, R.drawable.tokyo),

Copy

Explain
            City(4, R.string.switzerland,

Copy

Explain
                R.drawable.switzerland),

Copy

Explain
            City(5, R.string.singapore,

Copy

Explain
                R.drawable.singapore),

Copy

Explain
            City(6, R.string.paris, R.drawable.paris),

Copy

Explain
        )

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
Now, we have our dummy data, and it is time to display this on our scrollable list. Let’s create a new Kotlin file in our components package and call it CityComponents. In CityComponents, we will create our @Preview function:
@Preview(showBackground = true)

Copy

Explain
@Composable

Copy

Explain
private fun CityCardPreview() {

Copy

Explain
    CityApp()

Copy

Explain
}

Copy

Explain
Inside our @Preview function, we have another composable function, CityApp(); inside this function, we will call our CityList composable function, which has the list as a parameter. In addition, in this composable function, we will call LazyColumn, and items will be CityCard(cities). See the How it works section for further explanation about LazyColumn and items:
@Composable

Copy

Explain
fun CityList(cityList: List<City>) {

Copy

Explain
    LazyColumn {

Copy

Explain
        items(cityList) { cities ->

Copy

Explain
            CityCard(cities)

Copy

Explain
        }

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
Finally, let us construct our CityCard(city) composable function:
@Composable

Copy

Explain
fun CityCard(city: City) {

Copy

Explain
    Card(modifier = Modifier.padding(10.dp),

Copy

Explain
    elevation = 4.dp) {

Copy

Explain
        Column {

Copy

Explain
            Image(

Copy

Explain
                painter = painterResource(

Copy

Explain
                    city.imageResourceId),

Copy

Explain
                contentDescription = stringResource(

Copy

Explain
                    city.nameResourceId),

Copy

Explain
                modifier = Modifier

Copy

Explain
                    .fillMaxWidth()

Copy

Explain
                    .height(154.dp),

Copy

Explain
                contentScale = ContentScale.Crop

Copy

Explain
            )

Copy

Explain
            Text(

Copy

Explain
                text = LocalContext.current.getString(

Copy

Explain
                    city.nameResourceId),

Copy

Explain
                modifier = Modifier.padding(16.dp),

Copy

Explain
                style = MaterialTheme.typography.h5

Copy

Explain
            )

Copy

Explain
        }

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
When you run the CityCardPreview composable function, you should have a scrollable list, as seen in Figure 2.6.
Figure 2.7﻿ – A scrollable list of cities
Figure 2.7 – A scrollable list of cities

How it works…
In Kotlin, a list has two types, immutable and mutable. Immutable lists are items that cannot be modified, whereas mutable lists are items in the list that can be modified. To define a list, we can say a list is a generic ordered collection of elements, and these elements can be in the form of integers, strings, images, and so on, which is mostly informed by the type of data we want our lists to contain. For instance, in our example, we have a string and image helping identify our favorite cities by name and image.

In our City data class, we use @StringRes, and @DrawableRes in order to just pull this directly from the res folders for Drawable and String easily, and they also represent the ID for the images and string.

We created CityList and annotated it with the composable function and declared the list of city objects as our parameter in the function. A scrollable list in Jetpack Compose is made using LazyColumn. The main difference between LazyColumn and Column is that when using Column, you can only display small items, as Compose loads all items at once.

In addition, a column can only hold fixed composable functions, whereas LazyColumn, as the name suggests, loads the content as required on demand, making it good for loading more items when needed. In addition, LazyColumn comes with a scrolling ability inbuilt, which makes work easier for developers.

We also created a composable function, CityCard, where we import the Card() element from Compose. A card contains content and actions about a single object; in our example, for instance, our card has an image and the name of the city. A Card() element in Compose has the following inputs in its parameter:

@Composable
fun Card(
    modifier: Modifier = Modifier,
    shape: Shape = MaterialTheme.shapes.medium,
    backgroundColor: Color = MaterialTheme.colors.surface,
    contentColor: Color = contentColorFor(backgroundColor),
    border: BorderStroke? = null,
    elevation: Dp = 1.dp,
    content: @Composable () -> Unit
),

Copy

Explain
This means you can easily model your card to the best fitting; our card has padding and elevation, and the scope has a column. In this column, we have an image and text, which helps describe the image for more context.

See also
There is more to learn about lists and grids in Compose; you can use this link to learn more: https://developer.android.com/jetpack/compose/lists.

Implementing your first tab layout with a view pager using Jetpack Compose
In Android development, having a slide between pages is very common, with a significant use case being onboarding or even when you are trying to display specific data in a tabbed, carousel way. In this recipe, we will build a simple horizontal pager in Compose and see how we can utilize the new knowledge to build better and more modern Android apps.

Getting ready
In this example, we will build a horizontal pager that changes colors when selected to show the state is selected. We will look into states in Chapter 3, Handling the UI State in Jetpack Compose and Using Hilt, for better understanding. Open the Compose Basics project to get started.

How to do it…
Follow these steps to build your tab carousel:

Add the following pager dependencies to build.gradle(Module:app):
implementation "com.google.accompanist:accompanist-pager:0.x.x"

Copy

Explain
implementation "com.google.accompanist:accompanist-pager-indicators:0.x.x"

Copy

Explain
implementation 'androidx.Compose.material:material:1.x.x'

Copy

Explain
Jetpack Compose offers Accompanist, a group of libraries that aims to support it with commonly required features by developers – for instance, in our case, the pager.

In the same project from previous recipes, let’s create a package and call it pagerexample; inside it, create a Kotlin file and call it CityTabExample; inside this file, create a composable function and call it CityTabCarousel:
@Composable

Copy

Explain
fun CityTabCarousel(){}

Copy

Explain
Now, let us go ahead and build our CityTabCarousel; for our example, we will create a dummy list of pages with our cities from the previous project:
@Composable

Copy

Explain
fun CityTabCarousel(

Copy

Explain
    pages: MutableList<String> = arrayListOf(

Copy

Explain
        "Spain",

Copy

Explain
        "New York",

Copy

Explain
        "Tokyo",

Copy

Explain
        "Switzerland",

Copy

Explain
        "Singapore",

Copy

Explain
        "Paris" )) {. . .}

Copy

Explain
We will need to change the color of the button based on the state, and to do this; we need to use LocalContext, which provides the context we can use. We will also need to create a var pagerState = rememberPagerState(), which will remember our pager state, and finally, when clicked, we will need to move to the next city in our pager, which will be very helpful. Hence, go ahead and add the following to the CityTabCarousel composable function:
val context = LocalContext.current

Copy

Explain
var pagerState = rememberPagerState()

Copy

Explain
val coroutineScope = rememberCoroutineScope()

Copy

Explain
Now, let’s create the Column element and add our ScrollableTabRow() composable function:
Column {

Copy

Explain
    ScrollableTabRow(

Copy

Explain
        selectedTabIndex = pagerState.currentPage,

Copy

Explain
        indicator = { tabPositions ->

Copy

Explain
            TabRowDefaults.Indicator(...)

Copy

Explain
        },

Copy

Explain
        edgePadding = 0.dp,

Copy

Explain
        backgroundColor = Color(

Copy

Explain
            context.resources.getColor(R.color.white,

Copy

Explain
                null)),

Copy

Explain
    ) {

Copy

Explain
        pages.forEachIndexed { index, title ->

Copy

Explain
            val isSelected =

Copy

Explain
                pagerState.currentPage == index

Copy

Explain
            TabHeader(

Copy

Explain
                title,

Copy

Explain
                isSelected,

Copy

Explain
                onClick = { coroutineScope.launch {

Copy

Explain
                pagerState.animateScrollToPage(index)

Copy

Explain
                } },

Copy

Explain
            )

Copy

Explain
        }

Copy

Explain
    }

Copy

Explain
Add Text() and TabHeader() for HorizontalPager:
    HorizontalPager(

Copy

Explain
        count = pages.size,

Copy

Explain
        state = pagerState,

Copy

Explain
        modifier = Modifier

Copy

Explain
            .fillMaxWidth()

Copy

Explain
            .fillMaxHeight()

Copy

Explain
            .background(Color.White)

Copy

Explain
    ) { page ->

Copy

Explain
        Text(

Copy

Explain
            text = "Display City Name:

Copy

Explain
                ${pages[page]}",

Copy

Explain
            modifier = Modifier.fillMaxWidth(),

Copy

Explain
            style = TextStyle(

Copy

Explain
                textAlign = TextAlign.Center

Copy

Explain
            )

Copy

Explain
        )

Copy

Explain
    }

Copy

Explain
Please download the entire code for this recipe by following the link provided in the Technical requirements section to add all the required code. Finally, run the @Preview function, and your app should look like Figure 2.8.
Figure 2.8 – Tabs with cities
Figure 2.8 – Tabs with cities

How it works…
Accompanist comes with some significant libraries – for example, System UI Controller, AppCompact Compose Theme Adapter, Material Theme Adapter, Pager, Drawable Painter, and Flow Layouts, just to mention a few.

The ScrollableTabRow() that we use inside Column in the CityTabCarousel function contains a row of tabs and helps display an indicator underneath the currently focused or selected tab. In addition, as the name suggests, it enables scrolling and you do not have to implement further scrolling tooling. It also places its tab offsets at the starting edge, and you can quickly scroll tabs that are off-screen, as you will see when you run the @Preview function and play around with it.

When we invoke remember(), in Compose, this means we keep any value consistent across recomposition. Compose provides this function to help us store single objects in memory. When we trigger our application to run, remember() stores the initial value. As the word means, it simply retains the value and returns the stored value so that the composable function can use it.

Furthermore, whenever the stored value changes, you can update it, and the remember() function will keep it. The next time we trigger another run in our app and recomposition occurs, the remember() function will provide the latest stored value.

You will also notice our MutableList<String> is indexed at each position, and we do this to check which is selected. It is within this Lambda that we call TabHeader and showcase the selected tab pages. forEachIndexed performs the given action on each element, providing a sequential index of elements. We also ensure when a user clicks on a specific tab, we are on the right page:

onClick = { coroutineScope.launch { pagerState.animateScrollToPage(index) } }

Copy

Explain
HorizontalPager is a horizontally scrolling layout that allows our users to flip between items from left to right. It takes in several inputs, but we supply it with the count, state, and modifier to decorate it in our use case. In the Lambda, we display text – in our example, showing which page we are on, which helps when navigating, as shown in Figure 2.9:

Figure 2.9 – HorizontalPager
Figure 2.9 – HorizontalPager

Our TabHeader composable function has a Box(); a box in Jetpack Compose will always size itself to fit the content, and this is subject to the specified constraints. In our example, we decorate our Box with the selectable modifier, which configures components to be selectable as part of a mutually exclusive group, allowing each item to be selected only once at any given time.

Important note

Ensure your target and compile SDK targets 33. In addition, you will notice that most Accompanist’s libraries are experimental, which means they can change. There is debate on whether to use this in your production, so you should always consult your team on these APIs. To see the entire list of libraries supported by Accompanist, you can follow this link: https://github.com/google/accompanist.

Implementing animations in Compose
Animation in Android is the process of adding motion effects to views. This can be achieved using images, text, or even starting a new screen where the transition is noticeable using motion effects. Animations are vital in Modern Android Development since modern UIs are more interactive and adaptive to smoother experiences, and users like them.

Furthermore, applications these days are rated based on how great their UI and user experiences are, hence the need to ensure your application is modern and robust. In this example, we will build a collapsing toolbar, an animation that is widely used in the Android world.

Getting ready
We will continue using the Compose Basics project.

How to do it…
We will be building a collapsing toolbar in this recipe; there are other great animations you can now build utilizing the power of Compose. The power is in your hands:

We will not need to add any dependency to this recipe. We already have everything in place. So, let us go ahead and create a new package and add a Kotlin file, collapsingtoolbar.
Inside the Kotlin file, go ahead and create a new composable function, CollapsingTool BarExample():
@Composable

Copy

Explain
fun CollapsingToolbarExample() {...}

Copy

Explain
We will have all our needed composable functions in a box; you can refer to the previous recipe to refresh your memory on that. We will also need to define the height at which we will start to collapse our view, and this can be based on preference; for our example, we can set height to 260.dp:
private val height = 260.dp

Copy

Explain
private val titleToolbar = 50.dp

Copy

Explain
Let us go ahead and add more composable functions with dummy text data to display once we scroll our content. We can assume this app is used for reading information about the cities we display:
@Composable

Copy

Explain
fun CollapsingToolbarExample() {

Copy

Explain
    val scrollState: ScrollState =

Copy

Explain
        rememberScrollState(0)

Copy

Explain
    val headerHeight = with(LocalDensity.current) {

Copy

Explain
        height.toPx() }

Copy

Explain
    val toolbarHeight = with(LocalDensity.current) {

Copy

Explain
        titleToolbar.toPx() }

Copy

Explain
    Box(

Copy

Explain
        modifier = Modifier.fillMaxSize()

Copy

Explain
    ) {

Copy

Explain
        CollapsingHeader(scrollState, headerHeight)

Copy

Explain
        FactsAboutNewYork(scrollState)

Copy

Explain
        OurToolBar(scrollState, headerHeight,

Copy

Explain
            toolbarHeight)

Copy

Explain
        City()

Copy

Explain
    }

Copy

Explain
}

Copy

Explain
In our CollapsingHeader function, we pass in the scroll state and the headerHeight a float. We decorate Box with a Modifier.graphicLayer, where we set a parallax effect to make it look good and presentable.
We also ensure we add a Brush() and set the colors we need, and specify where it should start:
Box(

Copy

Explain
    Modifier

Copy

Explain
        .fillMaxSize()

Copy

Explain
        .background(

Copy

Explain
            brush = Brush.verticalGradient(

Copy

Explain
                colors = listOf(Color.Transparent,

Copy

Explain
                Color(0xFF6D38CA)),

Copy

Explain
                startY = 1 * headerHeight / 5

Copy

Explain
            )

Copy

Explain
        )

Copy

Explain
)

Copy

Explain
...

Copy

Explain
FactsAboutNewYork is not a complex composable function, just dummy text; then, finally, in ToolBar, we utilize AnimatedVisibility and declare our enter and exit transition:
AnimatedVisibility(

Copy

Explain
    visible = showToolbar,

Copy

Explain
    enter = fadeIn(animationSpec = tween(200)),

Copy

Explain
    exit = fadeOut(animationSpec = tween(200))

Copy

Explain
) {

Copy

Explain
...

Copy

Explain
Finally, run the @Preview function, and you will have a collapsible toolbar, which brings a smooth experience to your UI. In addition, get the entire code in the Technical requirements section.
Figure 2.10 – A collapsible toolbar
Figure 2.10 – A collapsible toolbar

How it works…
In Modern Android Development, the Jetpack Compose library has many animation APIs that are available as composable functions. For example, you might want your image or text to fade in and fade out.

Hence, if you are animating appearance and disappearance, which can be for an image, a text, a radio group, a button, and so on, you can use AnimatedVisibility to achieve this. Otherwise, if you are swapping content based on the state and want your content to crossfade, you can use CrossFade, or AnimatedContent.

val headerHeight = with(LocalDensity.current) { height.toPx() } provides density, which will be used to transform the DP and SP units, and we can use this when we provide the DP, which we will do and later convert into the body of our layout.

You can call the modifier and use graphicsLayer to update any of the content above it independently to minimize invalidated content. In addition, graphicsLayer can be used to apply effects such as scaling, rotation, opacity, shadow, or even clipping.

translationY = -scroll.value.toFloat() / 2f basically sets the vertical pixel offset of the layer relative to its top bound. The default value is always zero, but you can customize this to fit your needs. We also ensure the gradient is only applied to wrapping the title in startY = 1 * headerHeight / 5.

EnterTransition defines how the target content should appear; a target here can be an image, a text, or even a radio group. On the other hand, ExitTransition defines how the initial target content should disappear when exiting the app or navigating away.

AnimatedContent offers slideIntoContainer and slideOutOfContainer, and it animates its content as it changes based on the target state, which is remarkable. In addition, you can also encapsulate a transition and make it reusable by creating a class that holds all your animation values and an Update()function, which returns an instance of that class.

It is also fair to mention that, as with the old ways of doing animation in Android using MotionLayout, there are many ways to do transitions in Jetpack Compose. For instance, in Table 2.1, you will see the different types of transitions:

EnterTransition

ExitTransition

SlideIn

SlideOut

FadeIn

FadeOut

SlideInHorizontally

SlideOutHorizontally

SlideInVertically

SlideOutVertically

ScaleIn

SlaceOut

ExpandIn

ShrinkOut

ExpandHorizontally

ShinkHorizontally

ExpandVertically

ShrinkVertically

Table 2.1 – A table showing different types of transitions

In addition, you can add your own custom animation effects in Jetpack Compose beyond the already built-in enter and exit animations by simply accessing the elemental transition instance via the transition property inside the content lambda for AnimatedVisibility. You will also notice any animation states that have been added.

Implementing accessibility in Jetpack Compose
As we build Android applications, we need to always have accessibility in the back of our minds because this makes technology inclusive and ensures all people with special needs are considered as we build applications.

Accessibility should be a team effort. If well handled, the advantages include having more people using your application. An accessible application is better for everyone. You also reduce the risk of being sued.

There are different types of disabilities, such as visual, aural, and motor impairments. If you open your Accessibility settings, you will see the different options that people with disabilities use on their devices.

Getting ready
Like previous recipes, we will continue using our sample project from previous recipes; you do not need to install anything.

How to do it…
For this recipe, we will describe the visual elements, which are very vital:

By default, when we add an Image function, you might notice that it has two parameters, a painter for the image and a content description to visually describe the element:
Image(painter = , contentDescription = )

Copy

Explain
When you set the content description to null, you indicate to the Android framework that this element does not have an associated action or state. So, let’s go ahead and update all our content descriptions:
Image(

Copy

Explain
    modifier = modifier

Copy

Explain
    painter = painterResource(city.imageResourceId),

Copy

Explain
    contentDescription =

Copy

Explain
        stringResource(R.string.city_images))

Copy

Explain
)

Copy

Explain
Make sure you add the string to the string res folder:
<string name="city_images">City Images</string>

Copy

Explain
So, go ahead and ensure you add a content description for every image that requires it.
In Compose, you can easily indicate whether a text is a heading by specifying this in the modifier and using semantics to show that that is a heading. Let’s add that in our decorated text:
...

Copy

Explain
modifier = Modifier

Copy

Explain
    .padding(18.dp)

Copy

Explain
    .semantics { heading() }

Copy

Explain
...

Copy

Explain
Finally, we can go ahead and compile, run, and test whether our application is accessible by following this link on how to manually test using talkback or using automated testing: https://developer.android.com/guide/topics/ui/accessibility/testing.
How it works…
Jetpack Compose is built with accessibility in mind; that is to say, material components such as RadioButton, Switch, and so on have their size internally set, but only when these components can receive user interactions.

Furthermore, any screen element that users can click on or interact with should be large enough for reliable interaction. A standard format sets these elements to a size of at least 48dp for width and height.

For example, Switch has its onCheckChanged parameter set to a non-null value, including width and height of at least 48dp; we would have CheckableSwitch(), and NonCheckableSwitch():

@Composable
fun CheckableSwitch(){
    var checked by remember { mutableStateOf(false) }
    Switch(checked = checked, onCheckedChange = {} )
}
@Composable
fun NonCheckableSwitch(){
    var checked by remember { mutableStateOf(false) }
    Switch(checked = checked, onCheckedChange = null )
}

Copy

Explain
Once you have implemented accessibility in your applications, you can easily test it by installing analysis tools from the Play Store – uiautomatorviewer and lint. You can also automate your tests using Espresso or Roboelectric to check for accessibility support.

Finally, you can manually test your application for accessibility support by going to Settings, then to Accessibility, and selecting talkback. This is found at the top of the screen; then press On or Off to turn the talkback functionality on or off. Then, navigate to the dialog confirmation, and click OK to confirm permission.

There’s more…
There is more regarding accessibility that developers should consider as they build their applications, including a state with which they should be able to notify their users on whether a Switch button has been selected. This ensures their applications support accessibility and are up to standard.

Implementing declarative graphics using Jetpack Compose
In Android development, your application might have a different need, and this need might be building your own custom graphics for an intended purpose. This is very common in many stable and large Android code bases. The essential part of any custom view is its appearance. Furthermore, custom drawing can be a very easy or complex task based on the needs of your application. In Modern Android Development, Jetpack Compose makes it easier to work with custom graphics simply because the demand is immense. For example, many applications may need to control what happens on their screen accurately; the use case might be as simple as putting a circle on the screen or building more complex graphics to handle known use cases.

Getting ready
Open the Compose Basics project to get started with this recipe. You can find the entire code in the Technical requirements section.

How to do it…
In our project, let us create a new package and call it circularexample; inside this package, create a Kotlin file and call it DrawCircleCompose; inside the file, create a CircleProgressIndicatorExample composable function. You will not need to import anything for now:

Let us now go ahead and define our composable function. Since, in our example, we want to display a tracker in a circle, we need to float to fill in our circle. We will also define the colors to help us identify the progress:
@Composable

Copy

Explain
fun CircleProgressIndicatorExample(tracker: Float, progress: Float) {

Copy

Explain
    val circleColors = listOf(

Copy

Explain
        colorResource(id = R.color.purple_700),

Copy

Explain
        colorResource(id = R.color.teal_200)

Copy

Explain
    )

Copy

Explain
Now, let’s call Canvas to draw our arc. We give our circle the size of 200.dp with 8.dp padding. Where it gets interesting is in onDraw. startAngle is set at -90; the start angle is set in degrees to understand it better.
The zero represents 3 o’clock, and you can also play around with your start angle to see how -90 translates. The useCenter Boolean indicates whether arc is to close the center of the bounds. Hence, in our case, we set it to false. Then, finally, we set the style, which can be anything based on our preference:

Canvas(
    modifier = Modifier
        .size(200.dp)
        .padding(8.dp),
    onDraw = {
        this.drawIntoCanvas {
            drawArc(
                color = colorSecondary,
                startAngle = -90f,
                sweepAngle = 360f,
                useCenter = false,
                style = Stroke(width = 55f, cap =
                    StrokeCap.Butt),
                size = Size(size.width, size.height)
            )
colorResource(id = R.color.teal_200)
 . . .

Copy

Explain
We have just drawn the first part of the circle; now, we need to draw the progress with a Brush, which utilizes linearGradient:
drawArc(

Copy

Explain
    brush = Brush.linearGradient(colors =

Copy

Explain
        circleColors),

Copy

Explain
    startAngle = -90f,

Copy

Explain
    sweepAngle = progress(tracker, progress),

Copy

Explain
    useCenter = false,

Copy

Explain
    style = Stroke(width = 55f, cap =

Copy

Explain
        StrokeCap.Round),

Copy

Explain
    size = Size(size.width, size.height)

Copy

Explain
) . . .

Copy

Explain
. . .

Copy

Explain
Finally, our progress function tells sweepAngle where our progress should be based on our tracking abilities:
private fun progress(tracker: Float, progress: Float): Float {

Copy

Explain
    val totalProgress = (progress * 100) / tracker

Copy

Explain
    return ((360 * totalProgress) / 100)

Copy

Explain
}

Copy

Explain
. . .

Copy

Explain
Run the preview function, and you should see a circular progress indicator as in Figure 2.11.
Figure 2.11 – Showing a circular progress image
Figure 2.11 – Showing a circular progress image

Important note

The Canvas composable function uses Canvas to Compose an object, which, in turn, creates and helps manage a view-base Canvas. It is also important to mention that Compose makes it easier for developers by maintaining the state and creating and freeing any necessary helper objects.

How it works…
Generally, Canvas allows you to specify an area on the screen where you want to draw. In the old way of building Android applications, we also utilized Canvas, and now in Compose, it is more powerful and valuable.

linearGradient create a linear gradient with the specified colors along the provided start and end coordinates. For our example, we give it simple colors that come with the project.

The drawing functions have instrumental default parameters that you can use. For instance, by default, drawArc, as you can see, takes in several inputs:

Figure 2.12 – Showing what drawArc takes as input
Figure 2.12 – Showing what drawArc takes as input

sweepAngle in our example, which is the size of the arc in the degree that is drawn clockwise relative to startAngle, returns a function that calculates progress. This function can be customized to fit your needs. In our example, we pass in a tracker and progress and return a float.

Since we want to fill the circle, we create cal totalProgress, which checks progress * 100 divided by the tracker, and we return 360 (circle) * our progress divided by 100. You can customize this function to fit your needs. You can also write code to listen to where you are and make the progress move based on your input value from a listener you create.

There’s more…
There is more you can do with Canvas and custom drawing. One amazing way to enhance your knowledge on the topic is to look into old solutions posted on Stack Overflow, such as drawing a heart or any other shape, and see whether you can do the same in Compose.

Previous Chapter
Next Chapter









